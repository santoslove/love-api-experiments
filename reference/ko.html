<html><head>
    <title>L&Ouml;VE 0.10.2 Reference</title>
    <link href="https://fonts.googleapis.com/css?family=Quicksand:500,700" rel="stylesheet"><style>* {
    margin: 0;
    padding: 0;
    color: #333;
}

body {
    margin-left: 12px;
    margin-bottom: 24px;
    font-family: "Quicksand", sans-serif;
    font-weight: 500;
}

.section_heading a, .prefix a {
    color: #333;
}

a {
    color: #059dc5; /* Blue */
}

a:link {
    text-decoration: none;
}

a:hover  {
    text-decoration: underline;
}

.section_heading a:hover,
.function_heading a:hover {
    text-decoration: none;
}

.section_heading a,
.function_heading a {
    outline: none;
}

.side_navigation {
    position: fixed;
    margin-left: 2px;
    margin-top: 12px;
}

.container {
    margin-left: 80px;
}

p, td {
    font-size: 10pt;
}

.synopsis {
    font-size: 12pt;
    margin-top: 20px;
    margin-bottom: 12px;
}

.function_heading {
    margin-bottom: 14px;
    margin-top: 6px;
    font-size: 16pt;
    line-height: 1;
}

.section_heading {
    font-size: 28px;
}

.synopsis,
.ra_name,
.constant_name {
    font-family: "Consolas", monospace;
}

.ra_table {
    margin-bottom: 12px;
}

.ra_name {
    text-align: right;
    width: 120px;
}

.ra_type {
    padding-left: 16px;
    width: 100px;
}

.ra_name, .constant_name {
    font-weight: bold;
}

.function,
.section_navigation_link,
.section_navigation_subsection_heading {
    margin-left: 24px;
}

.section_navigation_link_minidescription {
    padding: 1px 0;
}

.section_navigation_link_minidescription {
    padding: 1px 0;
}

.section_navigation_subheading {
    margin-top: 14px;
    margin-bottom: 2px;
    font-weight: 700;
}

.section_navigation_subsection_heading {
    margin-top: 4px;
    margin-bottom: 2px;
    font-weight: 700;
}

.section_navigation_subheading {
    margin-bottom: 4px;
}

.constant_description {
    margin-bottom: 8px;
}

table {
    vertical-align: text-top;
}
td {
    vertical-align: top;
}

.function_heading a,
.constant_name {
    color: #E658A0; /* Pink */
}

.returns {
    color: #ab38c1; /* Purple */
}

.arguments {
    color: #ea9b4c; /* Orange */
}

.synopsis_background {
    padding: 2px 5px 2px 5px;
    background-color: #efefef;
    border-radius: 6px;
    box-decoration-break: clone;
    -webkit-box-decoration-break: clone;
}

body {
    background-color: #efefef; /* Grey */
}

.section {
    padding: 12px;
    padding-left: 22px;
    margin-bottom: 12px;
    background-color: #ffffff;
    border-radius: 8px 0 0 8px;
}

.first_section {
    border-radius: 0 0 0 8px;
    padding-top: 0;
}

.slash {
    color: #a7a7a7;
}

.section_heading,
.section_description, 
.variant_description,
.function_description,
.synopsis {
    margin-bottom: 12px;
}

td {
    padding-top: 8px;
}

.section_description, 
.variant_description {
    margin-top: 12px;
}

.relative {
    position: relative;
}
</style></head><body><div class = "side_navigation"><p><a href="#love">love</a></p><p><a href="#love.audio">audio</a></p><p><a href="#love.event">event</a></p><p><a href="#love.filesystem">filesystem</a></p><p><a href="#love.graphics">graphics</a></p><p><a href="#love.image">image</a></p><p><a href="#love.joystick">joystick</a></p><p><a href="#love.keyboard">keyboard</a></p><p><a href="#love.math">math</a></p><p><a href="#love.mouse">mouse</a></p><p><a href="#love.physics">physics</a></p><p><a href="#love.sound">sound</a></p><p><a href="#love.system">system</a></p><p><a href="#love.thread">thread</a></p><p><a href="#love.timer">timer</a></p><p><a href="#love.touch">touch</a></p><p><a href="#love.video">video</a></p><p><a href="#love.window">window</a></p></div><div class = "container"><div class = "section first_section"><p class = "section_heading"><a href = "#love" name = "love">love</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Data">Data</a>&emsp;모든 데이터 타입의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_subheading">Callbacks</p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.load">load</a>&emsp;게임 시작시 단 한번 호출되는 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.update">update</a>&emsp;매 프레임마다 게임의 상태를 갱신할 때 쓰이는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.draw">draw</a>&emsp;매 프레임마다 화면에 그림을 그리는 데 사용되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.quit">quit</a>&emsp;게임이 종료되었을 때 호출되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.run">run</a>&emsp;메인 루프를 돌리는 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.conf">conf</a>&emsp;구성. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.keypressed">keypressed</a>&emsp;키를 눌렀을 때 작동하는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.keyreleased">keyreleased</a>&emsp;키를 뗐을 때 작동하는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.textedited">textedited</a>&emsp;IME (Input Method Editor)의 후보 텍스트가 변경되면 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.textinput">textinput</a>&emsp;사용자가 텍스트를 입력했을 때 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.mousepressed">mousepressed</a>&emsp;마우스 버튼을 눌렀을 때 호출되는 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.mousereleased">mousereleased</a>&emsp;마우스 버튼을 뗐을 때 호출되는 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.mousemoved">mousemoved</a>&emsp;마우스가 움직일 때 트리거되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.mousefocus">mousefocus</a>&emsp;윈도우가 포커스를 받거나 잃었을 때 호출되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.wheelmoved">wheelmoved</a>&emsp;마우스 휠이 움직일 때 트리거되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.touchmoved">touchmoved</a>&emsp;터치 프레스가 터치 스크린 내부로 움직일 때 트리거되는 콜백 기능. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.touchpressed">touchpressed</a>&emsp;터치 스크린이 눌러지면 트리거되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.touchreleased">touchreleased</a>&emsp;터치 스크린이 터치되지 않을 때 트리거되는 콜백 기능. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.joystickpressed">joystickpressed</a>&emsp;조이스틱 버튼이 눌렸을 때 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.joystickreleased">joystickreleased</a>&emsp;조이스틱 버튼이 떼졌을 때 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.joystickaxis">joystickaxis</a>&emsp;조이스틱 축이 움직이면 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.joystickhat">joystickhat</a>&emsp;조이스틱 햇이 움직이면 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.joystickadded">joystickadded</a>&emsp;조이스틱이 연결되면 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.joystickremoved">joystickremoved</a>&emsp;조이스틱이 연결 해제되었을 때 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.gamepadpressed">gamepadpressed</a>&emsp;가상 게임패드 호환 조이스틱 버튼이 눌리면 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.gamepadreleased">gamepadreleased</a>&emsp;가상 게임패드 호환 조이스틱 버튼이 떼지면 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.gamepadaxis">gamepadaxis</a>&emsp;가상 게임패드 호환 조이스틱 축이 움직였을 때 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.resize">resize</a>&emsp;윈도우의 크기가 변경되면 호출됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.visible">visible</a>&emsp;최소화 등에 의해 윈도우가 완전히 숨겨졌을 때 호출되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.focus">focus</a>&emsp;윈도우가 포커스를 잃거나 얻었을 때 호출되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.filedropped">filedropped</a>&emsp;파일을 드래그하여 창에 놓을 때 트리거되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.directorydropped">directorydropped</a>&emsp;디렉토리를 드래그하여 창에 놓을 때 트리거되는 콜백 함수. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.errhand">errhand</a>&emsp;오류 메시지를 출력하기 위해 사용되는 오류 핸들러입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.threaderror">threaderror</a>&emsp;스레드에서 에러가 발생했을 때 호출되는 콜백 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.lowmemory">lowmemory</a>&emsp;모바일 장치에서 시스템 메모리가 부족한 경우 콜백 함수가 트리거됩니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.<a href="#love.getVersion">getVersion</a>&emsp;현재 실행되고 있는 L&Ouml;VE의 버전을 구합니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.getVersion" name = "love.getVersion"><span>love.</span><wbr>getVersion</a></p><p class = "function_description">현재 실행되고 있는 L&Ouml;VE의 버전을 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">major</span>, <span class = "returns">minor</span>, <span class = "returns">revision</span>, <span class = "returns">codename</span> = love.<wbr>getVersion()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">major</td><td class = "ra_type">number</td><td>L&Ouml;VE의 메이저 버전. 0.9.1에서 0을 뜻함.</td></tr><tr><td class = "returns ra_name">minor</td><td class = "ra_type">number</td><td>L&Ouml;VE의 마이너 버전. 0.9.1에서 9를 뜻함.</td></tr><tr><td class = "returns ra_name">revision</td><td class = "ra_type">number</td><td>L&Ouml;VE의 리비전 버전. 0.9.1에서 1을 뜻함.</td></tr><tr><td class = "returns ra_name">codename</td><td class = "ra_type">string</td><td>현재 버전의 코드네임.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.conf" name = "love.conf"><span>love.</span><wbr>conf</a></p><p class = "function_description">conf.lua라는 파일이 게임 폴더 (또는 .love 파일)에 있으면 L? VE 모듈이로드되기 전에 실행됩니다. 이 파일을 사용하여 나중에 L-VE 'boot'스크립트에서 호출되는 love.conf 기능을 덮어 쓸 수 있습니다. love.conf 함수를 사용하면 몇 가지 구성 옵션을 설정하고 윈도우의 기본 크기,로드되는 모듈 및 기타 사항을 변경할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>conf( <span class = "arguments">t</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">t</td><td class = "ra_type">table</td><td>love.conf 함수는 하나의 인자를 취합니다 : 여러분이 원하는대로 덮어 쓸 수있는 모든 기본값으로 채워진 테이블. 예를 들어 기본 창 크기를 변경하려면 다음과 같이하십시오.

function love.conf (t)
    t.window.width = 1024
    t.window.height = 768
종료

물리 모듈 또는 조이스틱 모듈이 필요하지 않은 경우 다음을 수행하십시오.

function love.conf (t)
    t.modules.joystick = false
    t.modules.physics = false
종료

사용하지 않는 모듈을 false로 설정하는 것은 게임을 출시 할 때 권장됩니다. 시동 시간을 약간 줄이고 (특히 조이스틱 모듈이 비활성화 된 경우) 특히 메모리 사용량을 줄입니다 (약간).

love.filesystem은 비활성화 할 수 없습니다. 그것은 필수입니다. 사랑 모듈 자체에 대해서도 마찬가지입니다. love.graphics는 사랑이 필요합니다. 사용할 수있는 창.</td></tr><tr><td class = "arguments ra_name">t.identity <span class = "default">(nil)</span></td><td class = "ra_type">string</td><td>이 플래그는 게임 저장 디렉토리의 이름을 결정합니다. 이름을 만들 수있는 위치가 아닌 이름 만 지정할 수 있습니다.
t.identity = "gabe_HL3"- 수정

t.identity = "c : / Users / gabe / HL3"- 올바르지 않습니다.
또는 <a href="#love.filesystem.setIdentity">love.filesystem.setIdentity</a>를 사용하여 구성 파일 외부에 저장 디렉토리를 설정할 수 있습니다.</td></tr><tr><td class = "arguments ra_name">t.version <span class = "default">("0.10.2")</span></td><td class = "ra_type">string</td><td>t.version은 게임이 만들어진 L-VE의 버전을 나타내는 문자열이어야합니다. "X.Y.Z"형식이어야합니다. 여기서 X는 주요 릴리스 번호이고 Y는 부 번호이며 Z는 패치 수준입니다. 호환되지 않는 경우 L-VE가 경고를 표시합니다. 기본값은 L-VE 실행 버전입니다.</td></tr><tr><td class = "arguments ra_name">t.console <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>콘솔을 게임 창 (Windows 전용)과 함께 열어야하는지 여부를 결정합니다. 참고 : OSX에서 터미널을 통해 L-VE를 실행하여 콘솔 출력을 얻을 수 있습니다.</td></tr><tr><td class = "arguments ra_name">t.accelerometerjoystick <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>iOS 및 Android의 장치 가속도계를 3 축 조이스틱으로 표시할지 여부를 설정합니다. 사용하지 않을 때 가속도계를 비활성화하면 CPU 사용량이 줄어들 수 있습니다.</td></tr><tr><td class = "arguments ra_name">t.externalstorage <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>Android에서 파일을 외부 저장소 (true) 또는 내부 저장소 (false)에 저장할지 여부를 설정합니다.</td></tr><tr><td class = "arguments ra_name">t.gammacorrect <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>시스템이 감마 보정을 지원하는지 여부를 결정합니다.</td></tr><tr><td class = "arguments ra_name">t.window</td><td class = "ra_type">table</td><td><a href="#love.window.setMode">love.window.setMode</a>가 코드에서 처음 호출 될 때까지 창 만들기를 연기 할 수 있습니다. 이렇게하려면, love.conf (또는 이전 버전에서는 t.screen = nil)에 t.window = nil을 설정하십시오.이 작업이 끝나면 love.graphics의 함수가 첫 번째 사랑 전에 호출되면 L-VE가 중단 될 수 있습니다. 코드에서 window.setMode.

t.window 테이블은 0.9.0 이전 버전에서 t.screen으로 명명되었습니다. t.screen 테이블은 0.9.0의 love.conf에 존재하지 않으며 t.window 테이블은 0.8.0의 love.conf에 존재하지 않습니다. 이것은 사용중인 L-VE 버전에 대해 올바른 테이블을 사용하지 않도록주의를 기울이면 love.conf가 실행되지 않으므로 (즉, 기본값으로 되돌아갑니다) 의미합니다.</td></tr><tr><td class = "arguments ra_name">t.modules</td><td class = "ra_type">table</td><td>모듈 옵션.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.directorydropped" name = "love.directorydropped"><span>love.</span><wbr>directorydropped</a></p><p class = "function_description">디렉토리를 드래그하여 창에 놓을 때 트리거되는 콜백 함수.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>directorydropped( <span class = "arguments">path</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">path</td><td class = "ra_type">string</td><td>디렉토리에 대한 전체 플랫폼 종속 경로. love.filesystem을 사용하여 디렉토리에 대한 읽기 액세스 권한을 얻으려면 <a href="#love.filesystem.mount">love.filesystem.mount</a>의 인수로 사용할 수 있습니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.draw" name = "love.draw"><span>love.</span><wbr>draw</a></p><p class = "function_description">매 프레임마다 화면에 그림을 그리는 데 사용되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>draw()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.errhand" name = "love.errhand"><span>love.</span><wbr>errhand</a></p><p class = "function_description">오류 메시지를 출력하기 위해 사용되는 오류 핸들러입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>errhand( <span class = "arguments">msg</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">msg</td><td class = "ra_type">string</td><td>오류 메시지입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filedropped" name = "love.filedropped"><span>love.</span><wbr>filedropped</a></p><p class = "function_description">파일을 드래그하여 창에 놓을 때 트리거되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>filedropped( <span class = "arguments">file</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">file</td><td class = "ra_type"><a href="#File">File</a></td><td>삭제 된 파일을 나타내는, 열려 있지 않은 File 객체입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.focus" name = "love.focus"><span>love.</span><wbr>focus</a></p><p class = "function_description">윈도우가 포커스를 잃거나 얻었을 때 호출되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>focus( <span class = "arguments">focus</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">focus</td><td class = "ra_type">boolean</td><td>포커스의 상태</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.gamepadaxis" name = "love.gamepadaxis"><span>love.</span><wbr>gamepadaxis</a></p><p class = "function_description">가상 게임패드 호환 조이스틱 축이 움직였을 때 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>gamepadaxis( <span class = "arguments">joystick</span>, <span class = "arguments">axis</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type"><a href="#Joystick">Joystick</a></td><td>조이스틱 객체.</td></tr><tr><td class = "arguments ra_name">axis</td><td class = "ra_type"><a href="#GamepadAxis">GamepadAxis</a></td><td>가상 게임패드 호환 조이스틱 축.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.gamepadpressed" name = "love.gamepadpressed"><span>love.</span><wbr>gamepadpressed</a></p><p class = "function_description">가상 게임패드 호환 조이스틱 버튼이 눌리면 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>gamepadpressed( <span class = "arguments">joystick</span>, <span class = "arguments">button</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type"><a href="#Joystick">Joystick</a></td><td>조이스틱 객체.</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type"><a href="#GamepadButton">GamepadButton</a></td><td>가상 게임패드 호환 조이스틱 버튼.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.gamepadreleased" name = "love.gamepadreleased"><span>love.</span><wbr>gamepadreleased</a></p><p class = "function_description">가상 게임패드 호환 조이스틱 버튼이 떼지면 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>gamepadreleased( <span class = "arguments">joystick</span>, <span class = "arguments">button</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type"><a href="#Joystick">Joystick</a></td><td>조이스틱 객체.</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type"><a href="#GamepadButton">GamepadButton</a></td><td>가상 게임패드 호환 조이스틱 버튼.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystickadded" name = "love.joystickadded"><span>love.</span><wbr>joystickadded</a></p><p class = "function_description">조이스틱이 연결되면 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>joystickadded( <span class = "arguments">joystick</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type"><a href="#Joystick">Joystick</a></td><td>새롭게 연결된 조이스틱 객체.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystickaxis" name = "love.joystickaxis"><span>love.</span><wbr>joystickaxis</a></p><p class = "function_description">조이스틱 축이 움직이면 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>joystickaxis( <span class = "arguments">joystick</span>, <span class = "arguments">axis</span>, <span class = "arguments">value</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type"><a href="#Joystick">Joystick</a></td><td>조이스틱 객체.</td></tr><tr><td class = "arguments ra_name">axis</td><td class = "ra_type">number</td><td>조이스틱 축 인덱스.</td></tr><tr><td class = "arguments ra_name">value</td><td class = "ra_type">number</td><td>새 조이스틱 축 값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystickhat" name = "love.joystickhat"><span>love.</span><wbr>joystickhat</a></p><p class = "function_description">조이스틱 햇이 움직이면 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>joystickhat( <span class = "arguments">joystick</span>, <span class = "arguments">hat</span>, <span class = "arguments">direction</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type"><a href="#Joystick">Joystick</a></td><td>조이스틱 객체.</td></tr><tr><td class = "arguments ra_name">hat</td><td class = "ra_type">number</td><td>조이스틱 햇 인덱스.</td></tr><tr><td class = "arguments ra_name">direction</td><td class = "ra_type"><a href="#JoystickHat">JoystickHat</a></td><td>새 조이스틱 햇 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystickpressed" name = "love.joystickpressed"><span>love.</span><wbr>joystickpressed</a></p><p class = "function_description">조이스틱 버튼이 눌렸을 때 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>joystickpressed( <span class = "arguments">joystick</span>, <span class = "arguments">button</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type">number</td><td>조이스틱 번호.</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type">number</td><td>버튼 번호.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystickreleased" name = "love.joystickreleased"><span>love.</span><wbr>joystickreleased</a></p><p class = "function_description">조이스틱 버튼이 떼졌을 때 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>joystickreleased( <span class = "arguments">joystick</span>, <span class = "arguments">button</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type">number</td><td>조이스틱 번호.</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type">number</td><td>버튼 번호.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystickremoved" name = "love.joystickremoved"><span>love.</span><wbr>joystickremoved</a></p><p class = "function_description">조이스틱이 연결 해제되었을 때 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>joystickremoved( <span class = "arguments">joystick</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">joystick</td><td class = "ra_type"><a href="#Joystick">Joystick</a></td><td>현재 연결이 끊긴 조이스틱 개체입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keypressed" name = "love.keypressed"><span>love.</span><wbr>keypressed</a></p><p class = "function_description">키를 눌렀을 때 작동하는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>keypressed( <span class = "arguments">key</span>, <span class = "arguments">scancode</span>, <span class = "arguments">isrepeat</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">key</td><td class = "ra_type"><a href="#KeyConstant">KeyConstant</a></td><td>누른 키의 문자.</td></tr><tr><td class = "arguments ra_name">scancode</td><td class = "ra_type"><a href="#Scancode">Scancode</a></td><td>누른 키를 나타내는 스캔 코드입니다.</td></tr><tr><td class = "arguments ra_name">isrepeat</td><td class = "ra_type">boolean</td><td>이 키 누르기 이벤트가 반복인지 여부입니다. 키 반복 사이의 지연은 사용자의 시스템 설정에 따라 다릅니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyreleased" name = "love.keyreleased"><span>love.</span><wbr>keyreleased</a></p><p class = "function_description">키를 뗐을 때 작동하는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>keyreleased( <span class = "arguments">key</span>, <span class = "arguments">scancode</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">key</td><td class = "ra_type"><a href="#KeyConstant">KeyConstant</a></td><td>해제 된 키의 문자입니다.</td></tr><tr><td class = "arguments ra_name">scancode</td><td class = "ra_type"><a href="#Scancode">Scancode</a></td><td>해제 된 키를 나타내는 스캔 코드입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.load" name = "love.load"><span>love.</span><wbr>load</a></p><p class = "function_description">게임 시작시 단 한번 호출되는 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>load( <span class = "arguments">arg</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">arg</td><td class = "ra_type">table</td><td>커맨드 라인으로 실행됐을 때 전달되는 인자 목록입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.lowmemory" name = "love.lowmemory"><span>love.</span><wbr>lowmemory</a></p><p class = "function_description">모바일 장치에서 시스템 메모리가 부족한 경우 콜백 함수가 트리거됩니다.<br /><br /> 모바일 운영 체제는 너무 많은 메모리를 사용하면 게임을 강제 종료시킬 수 있으므로이 이벤트가 트리거 될 때 비 핵심 리소스는 가능한 경우 제거해야합니다 (리소스를 참조하는 모든 변수를 nil로 설정하고 collectgarbage () 호출). 특히 소리와 이미지는 대부분의 메모리를 사용하는 경향이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>lowmemory()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mousefocus" name = "love.mousefocus"><span>love.</span><wbr>mousefocus</a></p><p class = "function_description">윈도우가 포커스를 받거나 잃었을 때 호출되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>mousefocus( <span class = "arguments">focus</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">focus</td><td class = "ra_type">boolean</td><td>윈도우 포커스</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mousemoved" name = "love.mousemoved"><span>love.</span><wbr>mousemoved</a></p><p class = "function_description">마우스가 움직일 때 트리거되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>mousemoved( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">dx</span>, <span class = "arguments">dy</span>, <span class = "arguments">istouch</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축상의 마우스 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축의 마우스 위치입니다.</td></tr><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>마지막으로 love.mousemoved가 호출 된 이후 x 축을 따라 이동 한 양입니다.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>마지막으로 love.mousemoved가 호출 된 이후 y 축을 따라 이동 한 양입니다.</td></tr><tr><td class = "arguments ra_name">istouch</td><td class = "ra_type">boolean</td><td>마우스 버튼 누름이 터치 스크린 터치 프레스에서 발생한 경우 True입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mousepressed" name = "love.mousepressed"><span>love.</span><wbr>mousepressed</a></p><p class = "function_description">마우스 버튼을 눌렀을 때 호출되는 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>mousepressed( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">button</span>, <span class = "arguments">isTouch</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>마우스 x 위치 (픽셀 단위).</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>마우스 y 위치 (픽셀 단위).</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type">number</td><td>누른 버튼 인덱스입니다. 1은 기본 마우스 버튼이고 2는 보조 마우스 버튼이고 3은 중간 버튼입니다. 추가 버튼은 마우스에 따라 다릅니다.</td></tr><tr><td class = "arguments ra_name">isTouch</td><td class = "ra_type">boolean</td><td>마우스 버튼 누름이 터치 스크린 터치 프레스에서 발생한 경우 True입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mousereleased" name = "love.mousereleased"><span>love.</span><wbr>mousereleased</a></p><p class = "function_description">마우스 버튼을 뗐을 때 호출되는 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>mousereleased( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">button</span>, <span class = "arguments">isTouch</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>마우스 x 위치 (픽셀 단위).</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>마우스 y 위치 (픽셀 단위).</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type">number</td><td>릴리스 된 버튼 인덱스입니다. 1은 기본 마우스 버튼이고 2는 보조 마우스 버튼이고 3은 중간 버튼입니다. 추가 버튼은 마우스에 따라 다릅니다.</td></tr><tr><td class = "arguments ra_name">isTouch</td><td class = "ra_type">boolean</td><td>마우스 버튼 누름이 터치 스크린 터치 릴리즈에서 비롯된 경우 true입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.quit" name = "love.quit"><span>love.</span><wbr>quit</a></p><p class = "function_description">게임이 종료되었을 때 호출되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">r</span> = love.<wbr>quit()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">r</td><td class = "ra_type">boolean</td><td>true면 종료를 유보합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.resize" name = "love.resize"><span>love.</span><wbr>resize</a></p><p class = "function_description">윈도우의 크기가 변경되면 호출됩니다.<br /><br />사용자가 윈도우의 크기를 변경하거나, <a href="#love.window.setMode">love.window.setMode</a>를 이용해 전체 화면에서 지원되지 않는 가로 세로로 화면 크기를 결정했을 경우 윈도우가 가장 적절한 크기를 선택할 때 호출됩니다.<br /><br /><a href="#love.window.setMode">love.window.setMode</a>에서 요구한 크기가 실제 윈도우 크기에 반영되지 못했을 때에도 이 이벤트를 발생시킵입니다. 전체 화면 모드와 관련된 자세한 내용은 FullscreenType을 참조하세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>resize( <span class = "arguments">w</span>, <span class = "arguments">h</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">w</td><td class = "ra_type">number</td><td>새로 설정된 너비.</td></tr><tr><td class = "arguments ra_name">h</td><td class = "ra_type">number</td><td>새로 설정된 높이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.run" name = "love.run"><span>love.</span><wbr>run</a></p><p class = "function_description">메인 루프를 돌리는 함수입니다. 기본적으로 잘 동작하게 정의되어 있으므로 특별한 경우가 아닌 이상 재정의하지 마세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>run()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.textedited" name = "love.textedited"><span>love.</span><wbr>textedited</a></p><p class = "function_description">IME (Input Method Editor)의 후보 텍스트가 변경되면 호출됩니다.<br /><br />후보 텍스트는 사용자가 결국 선택할 최종 텍스트가 아닙니다. 그것을 위해 love.textinput을 사용하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>textedited( <span class = "arguments">text</span>, <span class = "arguments">start</span>, <span class = "arguments">length</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">text</td><td class = "ra_type">string</td><td>UTF-8로 인코딩 된 유니 코드 후보 텍스트입니다.</td></tr><tr><td class = "arguments ra_name">start</td><td class = "ra_type">number</td><td>선택한 후보 텍스트의 시작 커서입니다.</td></tr><tr><td class = "arguments ra_name">length</td><td class = "ra_type">number</td><td>선택한 후보 텍스트의 길이입니다. 0 일 수도 있습니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.textinput" name = "love.textinput"><span>love.</span><wbr>textinput</a></p><p class = "function_description">사용자가 텍스트를 입력했을 때 호출됩니다. 예를 들어 사용자가 시프트 2를 눌렀을 때 텍스트 "@"이 만들어집니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>textinput( <span class = "arguments">text</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">text</td><td class = "ra_type">string</td><td>UTF-8로 인코딩된 텍스트.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.threaderror" name = "love.threaderror"><span>love.</span><wbr>threaderror</a></p><p class = "function_description">스레드에서 에러가 발생했을 때 호출되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>threaderror( <span class = "arguments">thread</span>, <span class = "arguments">errorstr</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">thread</td><td class = "ra_type"><a href="#Thread">Thread</a></td><td>에러가 발생한 스레드.</td></tr><tr><td class = "arguments ra_name">errorstr</td><td class = "ra_type">string</td><td>에러 메시지.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.touchmoved" name = "love.touchmoved"><span>love.</span><wbr>touchmoved</a></p><p class = "function_description">터치 프레스가 터치 스크린 내부로 움직일 때 트리거되는 콜백 기능.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>touchmoved( <span class = "arguments">id</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">dx</span>, <span class = "arguments">dy</span>, <span class = "arguments">pressure</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">id</td><td class = "ra_type">light userdata</td><td>터치 프레스의 식별자입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 x 축 위치 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 y 축 위치 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 x 축 이동 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 Y 축 이동 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">pressure</td><td class = "ra_type">number</td><td>적용되는 압력의 양. 대부분의 터치 스크린은 압력에 민감하지 않습니다.이 경우 압력은 1이됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.touchpressed" name = "love.touchpressed"><span>love.</span><wbr>touchpressed</a></p><p class = "function_description">터치 스크린이 눌러지면 트리거되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>touchpressed( <span class = "arguments">id</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">dx</span>, <span class = "arguments">dy</span>, <span class = "arguments">pressure</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">id</td><td class = "ra_type">light userdata</td><td>터치 프레스의 식별자입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>창 내부의 터치 프레스의 x 축 위치 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>창 안의 터치 프레스의 y 축 위치 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>윈도우 내부의 터치 프레스의 x 축 이동 (픽셀 단위)입니다. 항상 0이어야합니다.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>창 내부의 터치 프레스의 y 축 이동 (픽셀 단위)입니다. 항상 0이어야합니다.</td></tr><tr><td class = "arguments ra_name">pressure</td><td class = "ra_type">number</td><td>적용되는 압력의 양. 대부분의 터치 스크린은 압력에 민감하지 않습니다.이 경우 압력은 1이됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.touchreleased" name = "love.touchreleased"><span>love.</span><wbr>touchreleased</a></p><p class = "function_description">터치 스크린이 터치되지 않을 때 트리거되는 콜백 기능.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>touchreleased( <span class = "arguments">id</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">dx</span>, <span class = "arguments">dy</span>, <span class = "arguments">pressure</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">id</td><td class = "ra_type">light userdata</td><td>터치 프레스의 식별자입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 x 축 위치 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 y 축 위치 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 x 축 이동 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>윈도우 내부의 터치의 Y 축 이동 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">pressure</td><td class = "ra_type">number</td><td>적용되는 압력의 양. 대부분의 터치 스크린은 압력에 민감하지 않습니다.이 경우 압력은 1이됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.update" name = "love.update"><span>love.</span><wbr>update</a></p><p class = "function_description">매 프레임마다 게임의 상태를 갱신할 때 쓰이는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>update( <span class = "arguments">dt</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">dt</td><td class = "ra_type">number</td><td>마지막 업데이트 이후의 시간 (초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.visible" name = "love.visible"><span>love.</span><wbr>visible</a></p><p class = "function_description">최소화 등에 의해 윈도우가 완전히 숨겨졌을 때 호출되는 콜백 함수입니다. 최소화한 상태에서 다시 창을 띄울 때에도 호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>visible( <span class = "arguments">visible</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">visible</td><td class = "ra_type">boolean</td><td>윈도우 가시성.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.wheelmoved" name = "love.wheelmoved"><span>love.</span><wbr>wheelmoved</a></p><p class = "function_description">마우스 휠이 움직일 때 트리거되는 콜백 함수입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.<wbr>wheelmoved( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>수평 마우스 휠 이동량입니다. 양수 값은 오른쪽으로 이동 함을 나타냅니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>수직 마우스 휠의 이동량입니다. 양수 값은 상향 이동을 나타냅니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Data" name = "Data">Data</a></p><p class = "section_description">모든 데이터 타입의 최상위 타입입니다.</p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Data:<a href="#Data:getPointer">getPointer</a>&emsp;데이터의 포인터를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Data:<a href="#Data:getSize">getSize</a>&emsp;데이터의 크기를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Data:<a href="#Data:getString">getString</a>&emsp;모든 데이터를 문자열로 반환합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_subheading">Subtypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedData">CompressedData</a>&emsp;특정 알고리즘을 사용하여 압축 된 바이트 데이터를 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedImageData">CompressedImageData</a>&emsp;RAM에 압축 된 상태로 유지되도록 설계된 압축 된 이미지 데이터를 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FileData">FileData</a>&emsp;파일 내부의 콘텐츠를 가리키는 데이터 입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ImageData">ImageData</a>&emsp;원시 (디코딩 된) 이미지 데이터. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SoundData">SoundData</a>&emsp;실제 오디오 데이터를 메모리에 가지고 있는 객체입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Data:getPointer" name = "Data:getPointer"><span>Data:</span><wbr>getPointer</a></p><p class = "function_description">데이터의 포인터를 얻어옵니다. LuaJIT의 FFI과 같은 라이브러리에서 유용하게 사용될 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">pointer</span> = Data:<wbr>getPointer()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">pointer</td><td class = "ra_type">light userdata</td><td>데이터를 가리키는 포인터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Data:getSize" name = "Data:getSize"><span>Data:</span><wbr>getSize</a></p><p class = "function_description">데이터의 크기를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">size</span> = Data:<wbr>getSize()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>바이트 단위로 계산된 데이터의 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Data:getString" name = "Data:getString"><span>Data:</span><wbr>getString</a></p><p class = "function_description">모든 데이터를 문자열로 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">data</span> = Data:<wbr>getString()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">data</td><td class = "ra_type">string</td><td>순수한 데이터.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Drawable" name = "Drawable">Drawable</a></p><p class = "section_description">화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. 이것은 직접 생성 할 수없는 추상 유형입니다.</p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_subheading">Subtypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Canvas">Canvas</a>&emsp;캔버스는 스크린 외부 렌더링에 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Image">Image</a>&emsp;드로어 블 이미지 유형. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Mesh">Mesh</a>&emsp;임의의 텍스처 모양을 ​​그리는 데 사용되는 2D 폴리곤 메쉬입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ParticleSystem">ParticleSystem</a>&emsp;화재와 같은 시원한 효과를 내기 위해 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SpriteBatch">SpriteBatch</a>&emsp;단일 이미지를 사용하여 love.graphics.draw를 한 번 호출하면 이미지의 동일한 복사본을 여러 개 그릴 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Text">Text</a>&emsp;텍스트를 그릴 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Texture">Texture</a>&emsp;텍스처를 나타내는 드로어 블 오브젝트의 슈퍼 클래스입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Video">Video</a>&emsp;드로어 블 비디오. </p></div><div class = "section"><p class = "section_heading"><a href = "#Object" name = "Object">Object</a></p><p class = "section_description">L&Ouml;VE의 최상위 타입입니다.</p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Object:<a href="#Object:type">type</a>&emsp;객체의 타입을 문자열로 리턴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Object:<a href="#Object:typeOf">typeOf</a>&emsp;객체가 특정 타입인지 검사합니다. </p><p class = "section_navigation_subheading">Subtypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#BezierCurve">BezierCurve</a>&emsp;베지에 곡선입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Body">Body</a>&emsp;몸체는 속도와 위치가있는 물체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Canvas">Canvas</a>&emsp;캔버스는 스크린 외부 렌더링에 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ChainShape">ChainShape</a>&emsp;ChainShape는 여러 선 세그먼트로 구성됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Channel">Channel</a>&emsp;서로 다른 스레드 사이에 데이터를 주고받는 데 사용되는 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CircleShape">CircleShape</a>&emsp;원은 모양을 확장하고 반경과 로컬 위치를 추가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedData">CompressedData</a>&emsp;특정 알고리즘을 사용하여 압축 된 바이트 데이터를 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedImageData">CompressedImageData</a>&emsp;RAM에 압축 된 상태로 유지되도록 설계된 압축 된 이미지 데이터를 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Contact">Contact</a>&emsp;연락처는 세계의 충돌을 관리하기 위해 만들어진 개체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Cursor">Cursor</a>&emsp;커서 모양을 표현합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Data">Data</a>&emsp;모든 데이터 타입의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#DistanceJoint">DistanceJoint</a>&emsp;두 시체를 같은 거리에 두십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#EdgeShape">EdgeShape</a>&emsp;EdgeShape는 선 세그먼트입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#File">File</a>&emsp;파일 시스템의 파일을 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FileData">FileData</a>&emsp;파일 내부의 콘텐츠를 가리키는 데이터 입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Fixture">Fixture</a>&emsp;치구는 몸체에 도형을 부착합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Font">Font</a>&emsp;화면에 그릴 수있는 문자의 모양을 정의합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FrictionJoint">FrictionJoint</a>&emsp;FrictionJoint는 몸체에 마찰을가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#GearJoint">GearJoint</a>&emsp;시체를 기어처럼 작동하도록 유지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Image">Image</a>&emsp;드로어 블 이미지 유형. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ImageData">ImageData</a>&emsp;원시 (디코딩 된) 이미지 데이터. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joystick">Joystick</a>&emsp;물리적 조이스틱을 표현합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Mesh">Mesh</a>&emsp;임의의 텍스처 모양을 ​​그리는 데 사용되는 2D 폴리곤 메쉬입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MotorJoint">MotorJoint</a>&emsp;두 바디 간의 상대 모션을 제어합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MouseJoint">MouseJoint</a>&emsp;마우스로 개체를 제어하는 ​​데 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ParticleSystem">ParticleSystem</a>&emsp;화재와 같은 시원한 효과를 내기 위해 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PolygonShape">PolygonShape</a>&emsp;다각형은 8면까지 볼록한 다각형입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PrismaticJoint">PrismaticJoint</a>&emsp;Bodies 간의 상대 모션을 하나의 공유 축으로 제한합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PulleyJoint">PulleyJoint</a>&emsp;풀리를 통해 연결된 시체를 시뮬레이션 할 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Quad">Quad</a>&emsp;텍스처 좌표 정보가있는 사변형 (4면과 4 개의 모서리가있는 다각형)입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RandomGenerator">RandomGenerator</a>&emsp;자기 고유의 상태를 가지는 난수 생성기입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RevoluteJoint">RevoluteJoint</a>&emsp;두 개체가 공유 지점을 중심으로 회전하도록 허용합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RopeJoint">RopeJoint</a>&emsp;RopeJoint는 두 바디에서 두 점 사이의 최대 거리를 적용합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shader">Shader</a>&emsp;셰이더는 고급 하드웨어 가속 픽셀 또는 버텍스 조작에 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shape">Shape</a>&emsp;모양은 love.physics에서 사용 된 단단한 2 차원 기하학적 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SoundData">SoundData</a>&emsp;실제 오디오 데이터를 메모리에 가지고 있는 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Source">Source</a>&emsp;오디오를 표현합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SpriteBatch">SpriteBatch</a>&emsp;단일 이미지를 사용하여 love.graphics.draw를 한 번 호출하면 이미지의 동일한 복사본을 여러 개 그릴 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Text">Text</a>&emsp;텍스트를 그릴 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Texture">Texture</a>&emsp;텍스처를 나타내는 드로어 블 오브젝트의 슈퍼 클래스입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Thread">Thread</a>&emsp;스레드를 표현하는 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Video">Video</a>&emsp;드로어 블 비디오. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#WeldJoint">WeldJoint</a>&emsp;WeldJoint는 본질적으로 두 개의 몸체를 서로 붙입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#WheelJoint">WheelJoint</a>&emsp;두 번째 본문의 한 점을 첫 번째 본문의 한 행으로 제한합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#World">World</a>&emsp;세상은 모든 몸과 관절을 포함하는 대상입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Object:type" name = "Object:type"><span>Object:</span><wbr>type</a></p><p class = "function_description">객체의 타입을 문자열로 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">type</span> = Object:<wbr>type()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">type</td><td class = "ra_type">string</td><td>타입의 이름.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Object:typeOf" name = "Object:typeOf"><span>Object:</span><wbr>typeOf</a></p><p class = "function_description">객체가 특정 타입인지 검사합니다. 객체가 검사하려는 타입과 같은 타입이거나 상위 타입일 때 이 함수는 true를 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">b</span> = Object:<wbr>typeOf( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">b</td><td class = "ra_type">boolean</td><td>해당되면 true, 아니면 false를 리턴.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>검사하려는 타입의 이름.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.audio" name = "love.audio">love.audio</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Source">Source</a>&emsp;오디오를 표현합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.getSourceCount">getSourceCount</a>&emsp;동시에 재생되고 있는 오디오 소스의 개수를 받아옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.pause">pause</a>&emsp;모든 오디오를 일시정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.play">play</a>&emsp;특정 오디오 소스를 재생합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.resume">resume</a>&emsp;모든 오디오를 다시 재생합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.rewind">rewind</a>&emsp;모든 오디오를 되감습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.getDistanceModel">get</a><span class = "slash">/</span><a href="#love.audio.setDistanceModel">setDistanceModel</a>&emsp;거리 감쇠 방식을 결정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.getDopplerScale">get</a><span class = "slash">/</span><a href="#love.audio.setDopplerScale">setDopplerScale</a>&emsp;속도 기반 도플러 효과의 전역 배율 인수를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.getOrientation">get</a><span class = "slash">/</span><a href="#love.audio.setOrientation">setOrientation</a>&emsp;듣는이의 머리 방향을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.getPosition">get</a><span class = "slash">/</span><a href="#love.audio.setPosition">setPosition</a>&emsp;듣는이의 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.getVelocity">get</a><span class = "slash">/</span><a href="#love.audio.setVelocity">setVelocity</a>&emsp;듣는이의 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.getVolume">get</a><span class = "slash">/</span><a href="#love.audio.setVolume">setVolume</a>&emsp;마스터 볼륨을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.stop">stop</a>&emsp;재생중인 모든 오디오를 정지합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#DistanceModel">DistanceModel</a>&emsp;거리 감쇠 방식을 표현합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SourceType">SourceType</a>&emsp;오디오 소스가 가진 음원의 메모리 등재 방식을 표현합니다.  </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#TimeUnit">TimeUnit</a>&emsp;시간 표현 단위입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.getDistanceModel" name = "love.audio.getDistanceModel"><span>love.audio.</span><wbr>getDistanceModel</a></p><p class = "function_description">거리 감쇠 방식을 결정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">model</span> = love.audio.<wbr>getDistanceModel()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">model</td><td class = "ra_type"><a href="#DistanceModel">DistanceModel</a></td><td>거리 감쇠 방식.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.getDopplerScale" name = "love.audio.getDopplerScale"><span>love.audio.</span><wbr>getDopplerScale</a></p><p class = "function_description">속도 기반 도플러 효과에 대한 현재 전역 배율 인수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">scale</span> = love.audio.<wbr>getDopplerScale()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">scale</td><td class = "ra_type">number</td><td>현재의 도플러 스케일 팩터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.getSourceCount" name = "love.audio.getSourceCount"><span>love.audio.</span><wbr>getSourceCount</a></p><p class = "function_description">동시에 재생되고 있는 오디오 소스의 개수를 받아옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">numSources</span> = love.audio.<wbr>getSourceCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">numSources</td><td class = "ra_type">number</td><td>동시에 재생되고 있는 오디오 소스의 개수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.getOrientation" name = "love.audio.getOrientation"><span>love.audio.</span><wbr>getOrientation</a></p><p class = "function_description">듣는이의 머리 방향을 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fx</span>, <span class = "returns">fy</span>, <span class = "returns">fz</span>, <span class = "returns">ux</span>, <span class = "returns">uy</span>, <span class = "returns">uz</span> = love.audio.<wbr>getOrientation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fx</td><td class = "ra_type">number</td><td>청취자 방향의 전방 벡터의 X 성분.</td></tr><tr><td class = "returns ra_name">fy</td><td class = "ra_type">number</td><td>청취자 방향의 전방 벡터의 Y 성분.</td></tr><tr><td class = "returns ra_name">fz</td><td class = "ra_type">number</td><td>리스너 방향의 전방 벡터의 Z 성분입니다.</td></tr><tr><td class = "returns ra_name">ux</td><td class = "ra_type">number</td><td>청취자 방향의 위쪽 벡터의 X 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">uy</td><td class = "ra_type">number</td><td>리스너 방향의 위쪽 벡터의 Y 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">uz</td><td class = "ra_type">number</td><td>리스너 방향의 상향 벡터의 Z 성분입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.getPosition" name = "love.audio.getPosition"><span>love.audio.</span><wbr>getPosition</a></p><p class = "function_description">듣는이의 위치를 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">z</span> = love.audio.<wbr>getPosition()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>듣는이의 x축 위치.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>듣는이의 y축 위치.</td></tr><tr><td class = "returns ra_name">z</td><td class = "ra_type">number</td><td>듣는이의 z축 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.getVelocity" name = "love.audio.getVelocity"><span>love.audio.</span><wbr>getVelocity</a></p><p class = "function_description">듣는이의 속도를 받아옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">z</span> = love.audio.<wbr>getVelocity()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>듣는이의 x축 속도.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>듣는이의 y축 속도.</td></tr><tr><td class = "returns ra_name">z</td><td class = "ra_type">number</td><td>듣는이의 z축 속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.getVolume" name = "love.audio.getVolume"><span>love.audio.</span><wbr>getVolume</a></p><p class = "function_description">마스터 볼륨을 조사합니다. 마스터 볼륨은 모든 볼륨을 올리거나 내립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">volume</span> = love.audio.<wbr>getVolume()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">volume</td><td class = "ra_type">number</td><td>1이면 최대 볼륨. 0이면 음소거.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.newSource" name = "love.audio.newSource"><span>love.audio.</span><wbr>newSource</a></p><p class = "function_description">파일, 디코더, <a href="#SoundData">SoundData</a>로부터 새로운 오디오 소스를 생성합니다.<br /><br /><a href="#SoundData">SoundData</a>를 통해 만들어진 오디오 소스의 메모리 등재 방식은 그 특성상 "static"으로 강제됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">source</span> = love.audio.<wbr>newSource( <span class = "arguments">file</span>, <span class = "arguments">type</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>지정된 오디오를 재생할 수있는 새로운 Source입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a></td><td>소스를 생성 할 경로 / 파일.</td></tr><tr><td class = "arguments ra_name">type <span class = "default">("stream")</span></td><td class = "ra_type"><a href="#SourceType">SourceType</a></td><td>스트리밍 또는 정적 소스.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">source</span> = love.audio.<wbr>newSource( <span class = "arguments">soundData</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>지정된 오디오를 재생할 수있는 새로운 Source입니다. 반환 된 오디오의 SourceType은 "정적"입니다.</td></tr><tr><td class = "arguments ra_name">soundData</td><td class = "ra_type"><a href="#SoundData">SoundData</a> / <a href="#FileData">FileData</a></td><td>Source를 생성하는 SoundData / FileData입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.pause" name = "love.audio.pause"><span>love.audio.</span><wbr>pause</a></p><p class = "function_description">모든 오디오를 일시정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>pause()</span></span></p><p class = "variant_description">This function will pause all currently active <a href="#Source">Sources</a>.</p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>pause( <span class = "arguments">source</span> )</span></span></p><p class = "variant_description">This function will only pause the specified <a href="#Source">Source</a>.</p><table class = "ra_table"><tr><td class = "arguments ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>일시정지할 오디오 소스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.play" name = "love.audio.play"><span>love.audio.</span><wbr>play</a></p><p class = "function_description">특정 오디오 소스를 재생합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>play( <span class = "arguments">source</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>재생할 오디오 소스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.resume" name = "love.audio.resume"><span>love.audio.</span><wbr>resume</a></p><p class = "function_description">모든 오디오를 다시 재생합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>resume()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>resume( <span class = "arguments">source</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>다시 재생할 오디오 소스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.rewind" name = "love.audio.rewind"><span>love.audio.</span><wbr>rewind</a></p><p class = "function_description">모든 오디오를 되감습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>rewind()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>rewind( <span class = "arguments">source</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>되감을 오디오 소스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.setDistanceModel" name = "love.audio.setDistanceModel"><span>love.audio.</span><wbr>setDistanceModel</a></p><p class = "function_description">거리 감쇠 방식을 결정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>setDistanceModel( <span class = "arguments">model</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">model</td><td class = "ra_type"><a href="#DistanceModel">DistanceModel</a></td><td>거리 감쇠 방식.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.setDopplerScale" name = "love.audio.setDopplerScale"><span>love.audio.</span><wbr>setDopplerScale</a></p><p class = "function_description">속도 기반 도플러 효과의 전역 배율 인수를 설정합니다. 기본 축척 값은 1입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>setDopplerScale( <span class = "arguments">scale</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">scale</td><td class = "ra_type">number</td><td>새로운 도플러 축척 계수. 눈금은 0보다 커야합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.setOrientation" name = "love.audio.setOrientation"><span>love.audio.</span><wbr>setOrientation</a></p><p class = "function_description">듣는이의 머리 방향을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>setOrientation( <span class = "arguments">fx</span>, <span class = "arguments">fy</span>, <span class = "arguments">fz</span>, <span class = "arguments">ux</span>, <span class = "arguments">uy</span>, <span class = "arguments">uz</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">fx</td><td class = "ra_type">number</td><td>청취자 방향의 전방 벡터의 X 성분.</td></tr><tr><td class = "arguments ra_name">fy</td><td class = "ra_type">number</td><td>청취자 방향의 전방 벡터의 Y 성분.</td></tr><tr><td class = "arguments ra_name">fz</td><td class = "ra_type">number</td><td>리스너 방향의 전방 벡터의 Z 성분입니다.</td></tr><tr><td class = "arguments ra_name">ux</td><td class = "ra_type">number</td><td>청취자 방향의 위쪽 벡터의 X 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">uy</td><td class = "ra_type">number</td><td>리스너 방향의 위쪽 벡터의 Y 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">uz</td><td class = "ra_type">number</td><td>리스너 방향의 상향 벡터의 Z 성분입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.setPosition" name = "love.audio.setPosition"><span>love.audio.</span><wbr>setPosition</a></p><p class = "function_description">듣는이의 위치를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>setPosition( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">z</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>듣는이의 x축 위치.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>듣는이의 y축 위치.</td></tr><tr><td class = "arguments ra_name">z</td><td class = "ra_type">number</td><td>듣는이의 z축 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.setVelocity" name = "love.audio.setVelocity"><span>love.audio.</span><wbr>setVelocity</a></p><p class = "function_description">듣는이의 속도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>setVelocity( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">z</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>듣는이의 x축 속도.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>듣는이의 y축 속도.</td></tr><tr><td class = "arguments ra_name">z</td><td class = "ra_type">number</td><td>듣는이의 z축 속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.setVolume" name = "love.audio.setVolume"><span>love.audio.</span><wbr>setVolume</a></p><p class = "function_description">마스터 볼륨을 설정합니다. 마스터 볼륨은 모든 볼륨을 올리거나 내립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>setVolume( <span class = "arguments">volume</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">volume</td><td class = "ra_type">number</td><td>1이면 최대 볼륨. 0이면 음소거.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.audio.stop" name = "love.audio.stop"><span>love.audio.</span><wbr>stop</a></p><p class = "function_description">재생중인 모든 오디오를 정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>stop()</span></span></p><p class = "variant_description">이 기능은 현재 활성화 된 모든 소스를 중지합니다.</p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.audio.<wbr>stop( <span class = "arguments">source</span> )</span></span></p><p class = "variant_description">이 기능은 지정된 소스를 중지합니다.</p><table class = "ra_table"><tr><td class = "arguments ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>정지할 오디오 소스.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#DistanceModel" name = "DistanceModel">DistanceModel</a></p><p class = "constant_name">none</p><p class = "constant_description">감쇠 안 함.</p><p class = "constant_name">inverse</p><p class = "constant_description">역감쇠.</p><p class = "constant_name">inverseclamped</p><p class = "constant_description">역 거리 감쇄. 게인이 고정됩니다. 버전 0.9.2 및 이전 버전에서이 이름은 inverse clamped입니다.</p><p class = "constant_name">linear</p><p class = "constant_description">선형 감쇠.</p><p class = "constant_name">linearclamped</p><p class = "constant_description">선형 감쇠. 게인이 고정됩니다. 버전 0.9.2 및 이전 버전에서 이것은 선형 클램프 (linear clamped)로 명명됩니다.</p><p class = "constant_name">exponent</p><p class = "constant_description">지수형 감쇠.</p><p class = "constant_name">exponentclamped</p><p class = "constant_description">지수 감쇠. 게인이 고정됩니다. 버전 0.9.2 및 이전 버전에서 이것은 지명 된 지수입니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#SourceType" name = "SourceType">SourceType</a></p><p class = "constant_name">static</p><p class = "constant_description">처음부터 끝까지 전부 디코딩해 둡니다.</p><p class = "constant_name">stream</p><p class = "constant_description">재생되고 있는 부분에 맞추어 점진적으로 디코딩합니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#TimeUnit" name = "TimeUnit">TimeUnit</a></p><p class = "constant_name">seconds</p><p class = "constant_description">초 단위.</p><p class = "constant_name">samples</p><p class = "constant_description">오디오 샘플 기준.</p></div><div class = "section"><p class = "section_heading"><a href = "#Source" name = "Source">Source</a></p><p class = "section_description">오디오를 표현합니다. 이 객체를 이용해 실제로 소리를 재생할 수 있습니다.<br /><br />재생 외에도 볼륨, 피치 변경과 같은 여러가지 동작을 지원합니다.<br /><br />재생 상태에 관한 자세한 동작은 아래에 제시된 표를 따릅니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.audio.<a href="#love.audio.newSource">newSource</a>&emsp;파일, 디코더, SoundData로부터 새로운 오디오 소스를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:play">play</a>&emsp;재생합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:stop">stop</a>&emsp;정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:pause">pause</a>&emsp;일시정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:resume">resume</a>&emsp;일시정지한 오디오 소스를 재개합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:rewind">rewind</a>&emsp;되감습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:tell">tell</a><span class = "slash">/</span><a href="#Source:seek">seek</a>&emsp;재생중인 위치를 임의로 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:isLooping">is</a><span class = "slash">/</span><a href="#Source:setLooping">setLooping</a>&emsp;재생시 무한 반복을 할 것인지 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getPitch">get</a><span class = "slash">/</span><a href="#Source:setPitch">setPitch</a>&emsp;피치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getVolume">get</a><span class = "slash">/</span><a href="#Source:setVolume">setVolume</a>&emsp;볼륨을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:isPlaying">isPlaying</a>&emsp;재생중인지 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:isStopped">isStopped</a>&emsp;정지되어 있는지 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:isPaused">isPaused</a>&emsp;일시 정지되어 있는지 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getPosition">get</a><span class = "slash">/</span><a href="#Source:setPosition">setPosition</a>&emsp;오디오 소스의 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getDirection">get</a><span class = "slash">/</span><a href="#Source:setDirection">setDirection</a>&emsp;오디오 소스의 방향을 정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getRolloff">get</a><span class = "slash">/</span><a href="#Source:setRolloff">setRolloff</a>&emsp;롤 오프 율을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getVelocity">get</a><span class = "slash">/</span><a href="#Source:setVelocity">setVelocity</a>&emsp;오디오 소스의 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getCone">get</a><span class = "slash">/</span><a href="#Source:setCone">setCone</a>&emsp;오디오 소스의 볼륨 원뿔을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getAttenuationDistances">get</a><span class = "slash">/</span><a href="#Source:setAttenuationDistances">setAttenuationDistances</a>&emsp;오디오 소스의 최대 감쇠 거리와 참조 감쇠 거리를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getVolumeLimits">get</a><span class = "slash">/</span><a href="#Source:setVolumeLimits">setVolumeLimits</a>&emsp;볼륨 한계를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getType">getType</a>&emsp;Source의 유형 (정적 또는 스트림)을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getChannels">getChannels</a>&emsp;채널 수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:getDuration">getDuration</a>&emsp;Source의 존속 기간을 취득합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Source:<a href="#Source:clone">clone</a>&emsp;정지 상태로 복제본을 생성합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Source:clone" name = "Source:clone"><span>Source:</span><wbr>clone</a></p><p class = "function_description">정지 상태로 복제본을 생성합니다.<br /><br />Static 소스의 경우 <a href="#love.audio.newSource">love.audio.newSource</a>보다 Source:clone으로 생성하는 게 성능상의 이점도 있고 여러모로 좋습니다. 같은 음향 파일을 여러 개 사용해야 할 경우 이 함수를 사용해보세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">source</span> = Source:<wbr>clone()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>복제된 소스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getAttenuationDistances" name = "Source:getAttenuationDistances"><span>Source:</span><wbr>getAttenuationDistances</a></p><p class = "function_description">오디오 소스의 최대 감쇠 거리와 참조 감쇠 거리를 구합니다. 이 값은 현재 DistanceModel과 함께, 듣는이로부터의 거리를 기반으로 하여 소리 감쇠에 영향을 끼칩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ref</span>, <span class = "returns">max</span> = Source:<wbr>getAttenuationDistances()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ref</td><td class = "ra_type">number</td><td>현재 참조 감쇠 거리. 현재 DistanceModel이 고정이면, 소리가 더이상 감쇠되지 않을 때 최소 감쇠 거리로 동작합니다.</td></tr><tr><td class = "returns ra_name">max</td><td class = "ra_type">number</td><td>현재 최대 감쇠 거리.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getChannels" name = "Source:getChannels"><span>Source:</span><wbr>getChannels</a></p><p class = "function_description">채널 수를 구합니다. 1채널(모노) 오디오 소스만이 음향 위치/방향 효과 설정을 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">channels</span> = Source:<wbr>getChannels()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">channels</td><td class = "ra_type">number</td><td>모노는 1, 스테레오는 2.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getCone" name = "Source:getCone"><span>Source:</span><wbr>getCone</a></p><p class = "function_description">오디오 소스의 볼륨 원뿔을 얻어옵니다. 원뿔 각도는 오디오 소스의 방향을 기반으로 하여 볼륨에 영향을 줍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">innerAngle</span>, <span class = "returns">outerAngle</span>, <span class = "returns">outerVolume</span> = Source:<wbr>getCone()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">innerAngle</td><td class = "ra_type">number</td><td>오디오 소스의 방향으로부터의 내부 각도(라디안). 듣는이가 이 각도로 정의된 원뿔의 내부에 들어오면 정상적인 볼륨으로 재생됨.</td></tr><tr><td class = "returns ra_name">outerAngle</td><td class = "ra_type">number</td><td>오디오 소스의 방향으로부터의 외부 각도(라디안). 듣는이가 내부 각도와 외부 각도 사이에 들어오면 기본 볼륨과 외부 볼륨 사이의 값으로 재생됨.</td></tr><tr><td class = "returns ra_name">outerVolume</td><td class = "ra_type">number</td><td>외부 볼륨. 듣는이가 외부 각도 원뿔과 내부 각도 원뿔을 모두 빠져나갔을 경우 들리는 볼륨의 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getDirection" name = "Source:getDirection"><span>Source:</span><wbr>getDirection</a></p><p class = "function_description">오디오 소스의 방향을 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">z</span> = Source:<wbr>getDirection()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>오디오 소스의 x축 방향 벡터.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>오디오 소스의 y축 방향 벡터.</td></tr><tr><td class = "returns ra_name">z</td><td class = "ra_type">number</td><td>오디오 소스의 z축 방향 벡터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getDuration" name = "Source:getDuration"><span>Source:</span><wbr>getDuration</a></p><p class = "function_description">Source의 존속 기간을 취득합니다. 스트리밍 소스의 경우, 항상 샘플 정확성이있는 것은 아닙니다. 기간을 전혀 결정할 수없는 경우는 -1을 돌려주는 경우가 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">duration</span> = Source:<wbr>getDuration( <span class = "arguments">unit</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">duration</td><td class = "ra_type">number</td><td>소스 지속 시간입니다. 확인할 수없는 경우 -1입니다.</td></tr><tr><td class = "arguments ra_name">unit <span class = "default">("seconds")</span></td><td class = "ra_type"><a href="#TimeUnit">TimeUnit</a></td><td>반환 값의 시간 단위입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getPitch" name = "Source:getPitch"><span>Source:</span><wbr>getPitch</a></p><p class = "function_description">피치를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">pitch</span> = Source:<wbr>getPitch()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">pitch</td><td class = "ra_type">number</td><td>현재 피치. 1.0이 기본 피치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getPosition" name = "Source:getPosition"><span>Source:</span><wbr>getPosition</a></p><p class = "function_description">오디오 소스의 위치를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">z</span> = Source:<wbr>getPosition()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>오디오 소스의 x축 위치.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>오디오 소스의 y축 위치.</td></tr><tr><td class = "returns ra_name">z</td><td class = "ra_type">number</td><td>오디오 소스의 z축 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getRolloff" name = "Source:getRolloff"><span>Source:</span><wbr>getRolloff</a></p><p class = "function_description">롤 오프 율을 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rolloff</span> = Source:<wbr>getRolloff()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rolloff</td><td class = "ra_type">number</td><td>롤 오프 율.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getType" name = "Source:getType"><span>Source:</span><wbr>getType</a></p><p class = "function_description">Source의 유형 (정적 또는 스트림)을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">sourcetype</span> = Source:<wbr>getType()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">sourcetype</td><td class = "ra_type"><a href="#SourceType">SourceType</a></td><td>소스의 유형.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getVelocity" name = "Source:getVelocity"><span>Source:</span><wbr>getVelocity</a></p><p class = "function_description">오디오 소스의 속도를 받아옵니다.<br /><br />도플러 효과를 줄 때 사용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">z</span> = Source:<wbr>getVelocity()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>x축 속도 벡터.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>y축 속도 벡터.</td></tr><tr><td class = "returns ra_name">z</td><td class = "ra_type">number</td><td>z축 속도 벡터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getVolume" name = "Source:getVolume"><span>Source:</span><wbr>getVolume</a></p><p class = "function_description">볼륨을 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">volume</span> = Source:<wbr>getVolume()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">volume</td><td class = "ra_type">number</td><td>오디오 볼륨. 1.0이 기본값(이자 최댓값).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:getVolumeLimits" name = "Source:getVolumeLimits"><span>Source:</span><wbr>getVolumeLimits</a></p><p class = "function_description">볼륨 한계를 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = Source:<wbr>getVolumeLimits()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>최소 볼륨.</td></tr><tr><td class = "returns ra_name">max</td><td class = "ra_type">number</td><td>최대 볼륨.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:isLooping" name = "Source:isLooping"><span>Source:</span><wbr>isLooping</a></p><p class = "function_description">재생시 무한 반복이 설정되어 있는지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">loop</span> = Source:<wbr>isLooping()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">loop</td><td class = "ra_type">boolean</td><td>재생시 무한 반복이 설정되어 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:isPaused" name = "Source:isPaused"><span>Source:</span><wbr>isPaused</a></p><p class = "function_description">일시 정지되어 있는지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">paused</span> = Source:<wbr>isPaused()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">paused</td><td class = "ra_type">boolean</td><td>일시 정지되어 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:isPlaying" name = "Source:isPlaying"><span>Source:</span><wbr>isPlaying</a></p><p class = "function_description">재생중인지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">playing</span> = Source:<wbr>isPlaying()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">playing</td><td class = "ra_type">boolean</td><td>재생중이면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:isStopped" name = "Source:isStopped"><span>Source:</span><wbr>isStopped</a></p><p class = "function_description">정지되어 있는지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">stopped</span> = Source:<wbr>isStopped()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">stopped</td><td class = "ra_type">boolean</td><td>정지되어 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:pause" name = "Source:pause"><span>Source:</span><wbr>pause</a></p><p class = "function_description">일시정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>pause()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:play" name = "Source:play"><span>Source:</span><wbr>play</a></p><p class = "function_description">재생합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = Source:<wbr>play()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>Source가 성공적으로 재생되기 시작하면 True이고 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:resume" name = "Source:resume"><span>Source:</span><wbr>resume</a></p><p class = "function_description">일시정지한 오디오 소스를 재개합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>resume()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:rewind" name = "Source:rewind"><span>Source:</span><wbr>rewind</a></p><p class = "function_description">되감습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>rewind()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:seek" name = "Source:seek"><span>Source:</span><wbr>seek</a></p><p class = "function_description">재생중인 위치를 임의로 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>seek( <span class = "arguments">position</span>, <span class = "arguments">unit</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">position</td><td class = "ra_type">number</td><td>임의 위치.</td></tr><tr><td class = "arguments ra_name">unit <span class = "default">("seconds")</span></td><td class = "ra_type"><a href="#TimeUnit">TimeUnit</a></td><td>시간 표현 단위.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setDirection" name = "Source:setDirection"><span>Source:</span><wbr>setDirection</a></p><p class = "function_description">오디오 소스의 방향을 정합니다. 영벡터는 방향이 없음을 의미합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setDirection( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">z</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>오디오 소스의 x축 방향 벡터.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>오디오 소스의 y축 방향 벡터.</td></tr><tr><td class = "arguments ra_name">z</td><td class = "ra_type">number</td><td>오디오 소스의 z축 방향 벡터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setAttenuationDistances" name = "Source:setAttenuationDistances"><span>Source:</span><wbr>setAttenuationDistances</a></p><p class = "function_description">오디오 소스의 최대 감쇠 거리와 참조 감쇠 거리를 설정합니다. 이 값은 현재 DistanceModel과 함께, 듣는이로부터의 거리를 기반으로 하여 소리 감쇠에 영향을 끼칩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setAttenuationDistances( <span class = "arguments">ref</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ref</td><td class = "ra_type">number</td><td>현재 참조 감쇠 거리. 현재 DistanceModel이 고정이면, 소리가 더이상 감쇠되지 않을 때 최소 감쇠 거리로 동작합니다.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>현재 최대 감쇠 거리.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setCone" name = "Source:setCone"><span>Source:</span><wbr>setCone</a></p><p class = "function_description">오디오 소스의 볼륨 원뿔을 설정합니다. 원뿔 각도는 오디오 소스의 방향을 기반으로 하여 볼륨에 영향을 줍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setCone( <span class = "arguments">innerAngle</span>, <span class = "arguments">outerAngle</span>, <span class = "arguments">outerVolume</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">innerAngle</td><td class = "ra_type">number</td><td>오디오 소스의 방향으로부터의 내부 각도(라디안). 듣는이가 이 각도로 정의된 원뿔의 내부에 들어오면 기본 볼륨으로 재생됨.</td></tr><tr><td class = "arguments ra_name">outerAngle</td><td class = "ra_type">number</td><td>오디오 소스의 방향으로부터의 외부 각도(라디안). 듣는이가 내부 각도와 외부 각도 사이에 들어오면 기본 볼륨과 외부 볼륨 사이의 값으로 재생됨.</td></tr><tr><td class = "arguments ra_name">outerVolume <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>외부 볼륨. 듣는이가 외부 각도 원뿔과 내부 각도 원뿔을 모두 빠져나갔을 경우 들리는 볼륨의 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setLooping" name = "Source:setLooping"><span>Source:</span><wbr>setLooping</a></p><p class = "function_description">재생시 무한 반복을 할 것인지 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setLooping( <span class = "arguments">loop</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">loop</td><td class = "ra_type">boolean</td><td>재생시 무한 반복을 원하면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setPitch" name = "Source:setPitch"><span>Source:</span><wbr>setPitch</a></p><p class = "function_description">피치를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setPitch( <span class = "arguments">pitch</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">pitch</td><td class = "ra_type">number</td><td>1.0을 기준으로 하여, 12면 1옥타브 위로, -12면 1옥타브 아래로. 0은 유효하지 않은 값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setPosition" name = "Source:setPosition"><span>Source:</span><wbr>setPosition</a></p><p class = "function_description">오디오 소스의 위치를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setPosition( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">z</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>오디오 소스의 x축 위치.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>오디오 소스의 y축 위치.</td></tr><tr><td class = "arguments ra_name">z</td><td class = "ra_type">number</td><td>오디오 소스의 z축 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setRolloff" name = "Source:setRolloff"><span>Source:</span><wbr>setRolloff</a></p><p class = "function_description">롤 오프 율을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setRolloff( <span class = "arguments">rolloff</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">rolloff</td><td class = "ra_type">number</td><td>롤 오프 율.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setVelocity" name = "Source:setVelocity"><span>Source:</span><wbr>setVelocity</a></p><p class = "function_description">오디오 소스의 속도를 설정합니다.<br /><br />도플러 효과를 줄 때 사용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setVelocity( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">z</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x축 속도 벡터.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y축 속도 벡터.</td></tr><tr><td class = "arguments ra_name">z</td><td class = "ra_type">number</td><td>z축 속도 벡터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setVolume" name = "Source:setVolume"><span>Source:</span><wbr>setVolume</a></p><p class = "function_description">볼륨을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setVolume( <span class = "arguments">volume</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">volume</td><td class = "ra_type">number</td><td>오디오 볼륨. 1.0이 기본값(이자 최댓값).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:setVolumeLimits" name = "Source:setVolumeLimits"><span>Source:</span><wbr>setVolumeLimits</a></p><p class = "function_description">볼륨 한계를 설정합니다. 한계는 0과 1 사이의 값이어야 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>setVolumeLimits( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>최소 볼륨.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>최대 볼륨.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:stop" name = "Source:stop"><span>Source:</span><wbr>stop</a></p><p class = "function_description">정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Source:<wbr>stop()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Source:tell" name = "Source:tell"><span>Source:</span><wbr>tell</a></p><p class = "function_description">현재 재생하고 있는 지점을 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">position</span> = Source:<wbr>tell( <span class = "arguments">unit</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">position</td><td class = "ra_type">number</td><td>현재 재생하고 있는 위치.</td></tr><tr><td class = "arguments ra_name">unit <span class = "default">("seconds")</span></td><td class = "ra_type"><a href="#TimeUnit">TimeUnit</a></td><td>시간 표현 단위.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.event" name = "love.event">love.event</a></p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.event.<a href="#love.event.clear">clear</a>&emsp;이벤트 큐를 비웁니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.event.<a href="#love.event.poll">poll</a>&emsp;이벤트 큐의 메시지들을 순회할 반복자를 리턴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.event.<a href="#love.event.pump">pump</a>&emsp;이벤트 큐 내의 모든 이벤트를 실행하는 저수준 함수입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.event.<a href="#love.event.push">push</a>&emsp;이벤트 큐에 이벤트를 추가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.event.<a href="#love.event.quit">quit</a>&emsp;L&Ouml;VE 프로그램을 종료합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.event.<a href="#love.event.wait">wait</a>&emsp;이벤트를 하나 얻어오되, 큐에 이벤트가 없다면 하나라도 추가될 때까지 무한정 대기합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Event">Event</a>&emsp;시스템에 의해 정의된 이벤트들의 이름을 나타냅니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.event.clear" name = "love.event.clear"><span>love.event.</span><wbr>clear</a></p><p class = "function_description">이벤트 큐를 비웁니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.event.<wbr>clear()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.event.poll" name = "love.event.poll"><span>love.event.</span><wbr>poll</a></p><p class = "function_description">이벤트 큐의 메시지들을 순회할 반복자를 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">i</span> = love.event.<wbr>poll()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">i</td><td class = "ra_type">function</td><td>for 루프에서 사용할 수있는 반복기 함수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.event.pump" name = "love.event.pump"><span>love.event.</span><wbr>pump</a></p><p class = "function_description">이벤트 큐 내의 모든 이벤트를 실행하는 저수준 함수입니다. 때문에 사용자 수준에서 호출될 일은 많지 않고, 대부분 love.run을 재정의하는 데 사용됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.event.<wbr>pump()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.event.push" name = "love.event.push"><span>love.event.</span><wbr>push</a></p><p class = "function_description">이벤트 큐에 이벤트를 추가합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.event.<wbr>push( <span class = "arguments">e</span>, <span class = "arguments">a</span>, <span class = "arguments">b</span>, <span class = "arguments">c</span>, <span class = "arguments">d</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">e</td><td class = "ra_type"><a href="#Event">Event</a></td><td>이벤트 이름.</td></tr><tr><td class = "arguments ra_name">a <span class = "default">(nil)</span></td><td class = "ra_type">Variant</td><td>첫 번째 이벤트 인수.</td></tr><tr><td class = "arguments ra_name">b <span class = "default">(nil)</span></td><td class = "ra_type">Variant</td><td>두 번째 이벤트 인수.</td></tr><tr><td class = "arguments ra_name">c <span class = "default">(nil)</span></td><td class = "ra_type">Variant</td><td>세 번째 사건 인수.</td></tr><tr><td class = "arguments ra_name">d <span class = "default">(nil)</span></td><td class = "ra_type">Variant</td><td>넷째 사건 인수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.event.quit" name = "love.event.quit"><span>love.event.</span><wbr>quit</a></p><p class = "function_description">L&Ouml;VE 프로그램을 종료합니다.<br /><br />종료 이벤트를 이벤트 큐에 추가합니다. 종료 이벤트는 이벤트 핸들러에게 L&Ouml;VE를 종료하겠다고 보내는 신호입니다. 종료를 진행 도중 love.quit 콜백 함수에서 종료를 유보할 수도 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.event.<wbr>quit()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.event.<wbr>quit( <span class = "arguments">exitstatus</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">exitstatus <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>응용 프로그램을 닫을 때 사용할 프로그램 종료 상태입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.event.<wbr>quit( <span class = "arguments">"restart"</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">"restart"</td><td class = "ra_type">string</td><td>실행 파일을 다시 실행하지 않고 게임을 다시 시작합니다. 이렇게하면 주 루아 (Lua) 상태 인스턴스가 완전히 종료되고 새로운 인스턴스가 만들어집니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.event.wait" name = "love.event.wait"><span>love.event.</span><wbr>wait</a></p><p class = "function_description">이벤트를 하나 얻어오되, 큐에 이벤트가 없다면 하나라도 추가될 때까지 무한정 대기합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">e</span>, <span class = "returns">a</span>, <span class = "returns">b</span>, <span class = "returns">c</span>, <span class = "returns">d</span> = love.event.<wbr>wait()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">e</td><td class = "ra_type"><a href="#Event">Event</a></td><td>이벤트 유형입니다.</td></tr><tr><td class = "returns ra_name">a</td><td class = "ra_type">Variant</td><td>첫 번째 이벤트 인수.</td></tr><tr><td class = "returns ra_name">b</td><td class = "ra_type">Variant</td><td>두 번째 이벤트 인수.</td></tr><tr><td class = "returns ra_name">c</td><td class = "ra_type">Variant</td><td>세 번째 사건 인수.</td></tr><tr><td class = "returns ra_name">d</td><td class = "ra_type">Variant</td><td>넷째 사건 인수.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Event" name = "Event">Event</a></p><p class = "constant_name">focus</p><p class = "constant_description">윈도우가 포커스를 얻거나 잃었을 때</p><p class = "constant_name">joystickaxis</p><p class = "constant_description">조이스틱 축의 위치 변화 시</p><p class = "constant_name">joystickhat</p><p class = "constant_description">조이스틱 햇의 위치 변화 시</p><p class = "constant_name">joystickpressed</p><p class = "constant_description">조이스틱을 눌렀을 때</p><p class = "constant_name">joystickreleased</p><p class = "constant_description">조이스틱을 뗐을 때</p><p class = "constant_name">keypressed</p><p class = "constant_description">키를 눌렀을 때</p><p class = "constant_name">keyreleased</p><p class = "constant_description">키를 뗐을 때</p><p class = "constant_name">mousefocus</p><p class = "constant_description">윈도우가 마우스 포커스를 잃거나 얻었을 때</p><p class = "constant_name">mousepressed</p><p class = "constant_description">마우스를 눌렀을 때</p><p class = "constant_name">mousereleased</p><p class = "constant_description">마우스를 뗐을 때</p><p class = "constant_name">resize</p><p class = "constant_description">사용자에 의해 윈도우의 크기가 변경되었을 때</p><p class = "constant_name">threaderror</p><p class = "constant_description">스레드로 인한 루아 오류 발생 시</p><p class = "constant_name">quit</p><p class = "constant_description">종료</p><p class = "constant_name">visible</p><p class = "constant_description">사용자에 의해 윈도우가 최소화되거나 복귀되었을 때</p></div><div class = "section"><p class = "section_heading"><a href = "#love.filesystem" name = "love.filesystem">love.filesystem</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#File">File</a>&emsp;파일 시스템의 파일을 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FileData">FileData</a>&emsp;파일 내부의 콘텐츠를 가리키는 데이터 입니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.append">append</a>&emsp;이미 존재하는 파일에 데이터를 추가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.createDirectory">createDirectory</a>&emsp;디렉토리를 생성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.exists">exists</a>&emsp;파일이나 디렉토리가 존재하는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getAppdataDirectory">getAppdataDirectory</a>&emsp;앱데이터 디렉토리를 받아옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getDirectoryItems">getDirectoryItems</a>&emsp;특정 디렉토리 내에 있는 모든 파일과 하위 디렉토리를 나열한 테이블을 리턴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getLastModified">getLastModified</a>&emsp;해당 파일을 마지막으로 수정한 날짜를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getRealDirectory">getRealDirectory</a>&emsp;파일 경로가있는 디렉토리의 플랫폼 별 절대 경로를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getSaveDirectory">getSaveDirectory</a>&emsp;세이브 디렉토리의 완전한 경로를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getSize">getSize</a>&emsp;파일의 바이트 수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getSourceBaseDirectory">getSourceBaseDirectory</a>&emsp;.love 파일이 들어있는 디렉토리의 전체 경로를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getUserDirectory">getUserDirectory</a>&emsp;사용자 디렉토리를 받아옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getWorkingDirectory">getWorkingDirectory</a>&emsp;현재 작업 디렉토리를 받아옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.init">init</a>&emsp;love.filesystem을 초기화합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.isDirectory">isDirectory</a>&emsp;무언가가 디렉토리인지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.isFile">isFile</a>&emsp;무언가가 파일인지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.isFused">isFused</a>&emsp;게임이 퓨즈 모드로 설정되어 있는지 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.isSymlink">isSymlink</a>&emsp;파일 경로가 실제로 심볼 링크인지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.lines">lines</a>&emsp;텍스트 파일을 한 줄씩 읽는 반복자를 리턴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.load">load</a>&emsp;루아 파일을 불러오기만 합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.mount">mount</a>&emsp;zip 파일을 마운트합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.read">read</a>&emsp;파일을 읽습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.remove">remove</a>&emsp;파일이나 디렉토리를 제거합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getIdentity">get</a><span class = "slash">/</span><a href="#love.filesystem.setIdentity">setIdentity</a>&emsp;여러분의 게임에서 사용할 세이브 디렉토리의 이름을 정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getRequirePath">get</a><span class = "slash">/</span><a href="#love.filesystem.setRequirePath">setRequirePath</a>&emsp;require가 호출 될 때 검색 될 파일 시스템 경로를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.getSource">get</a><span class = "slash">/</span><a href="#love.filesystem.setSource">setSource</a>&emsp;소스 코드가 있는 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.areSymlinksEnabled">are</a><span class = "slash">/</span><a href="#love.filesystem.setSymlinksEnabled">setSymlinksEnabled</a>&emsp;love.filesystem이 기호 링크를 따를 지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.unmount">unmount</a>&emsp;love.filesystem.mount로 마운트된 zip 파일을 언마운트 합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.write">write</a>&emsp;세이브 디렉토리에 파일을 씁니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#BufferMode">BufferMode</a>&emsp;파일로부터 데이터를 출력할 때 어떻게 버퍼링할 것인지에 대한 방법입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FileDecoder">FileDecoder</a>&emsp;지정된 FileData를 디코드하는 방법. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FileMode">FileMode</a>&emsp;파일을 열 때 사용하는 여러 가지 모드입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.append" name = "love.filesystem.append"><span>love.filesystem.</span><wbr>append</a></p><p class = "function_description">이미 존재하는 파일에 데이터를 추가합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span>, <span class = "returns">errormsg</span> = love.filesystem.<wbr>append( <span class = "arguments">name</span>, <span class = "arguments">data</span>, <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공하면 true, 실패하면 nil.</td></tr><tr><td class = "returns ra_name">errormsg</td><td class = "ra_type">string</td><td>실패시 에러 메시지.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>파일의 경로와 이름.</td></tr><tr><td class = "arguments ra_name">data</td><td class = "ra_type">string</td><td>파일에 추가할 문자열.</td></tr><tr><td class = "arguments ra_name">size <span class = "default">(all)</span></td><td class = "ra_type">number</td><td>쓸 총 바이트 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.areSymlinksEnabled" name = "love.filesystem.areSymlinksEnabled"><span>love.filesystem.</span><wbr>areSymlinksEnabled</a></p><p class = "function_description">love.filesystem이 기호 링크를 따르는 지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enable</span> = love.filesystem.<wbr>areSymlinksEnabled()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enable</td><td class = "ra_type">boolean</td><td>love.filesystem이 기호 링크를 따를 지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.createDirectory" name = "love.filesystem.createDirectory"><span>love.filesystem.</span><wbr>createDirectory</a></p><p class = "function_description">디렉토리를 생성합니다.<br /><br />이 함수는 재귀적으로 디렉토리를 생성하는데, 만약 "foo/bar"를 만들라는 요청이 들어왔을 경우 먼저 "foo"를 만든 후 "foo/bar"를 만듭니다.<br /><br />만약 디렉토리가 이미 존재할 경우 만들지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.filesystem.<wbr>createDirectory( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>디렉토리가 생성되었으면 true.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>생성할 디렉토리의 이름.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.exists" name = "love.filesystem.exists"><span>love.filesystem.</span><wbr>exists</a></p><p class = "function_description">파일이나 디렉토리가 존재하는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">exists</span> = love.filesystem.<wbr>exists( <span class = "arguments">filename</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">exists</td><td class = "ra_type">boolean</td><td>존재하면 true.</td></tr><tr><td class = "arguments ra_name">filename</td><td class = "ra_type">string</td><td>파일이나 디렉토리의 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getAppdataDirectory" name = "love.filesystem.getAppdataDirectory"><span>love.filesystem.</span><wbr>getAppdataDirectory</a></p><p class = "function_description">앱데이터 디렉토리를 받아옵니다. (getUserDirectory와 같을 수도 있음)</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">path</span> = love.filesystem.<wbr>getAppdataDirectory()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">path</td><td class = "ra_type">string</td><td>앱데이터 디렉토리 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getDirectoryItems" name = "love.filesystem.getDirectoryItems"><span>love.filesystem.</span><wbr>getDirectoryItems</a></p><p class = "function_description">특정 디렉토리 내에 있는 모든 파일과 하위 디렉토리를 나열한 테이블을 리턴합니다.<br /><br />테이블은 정렬되어 있지 않습니다.<br /><br />.love 압축 파일과 세이브 디렉토리 둘다 파일이 존재할 경우 두 군데에서 전부 다 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">items</span> = love.filesystem.<wbr>getDirectoryItems( <span class = "arguments">dir</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">items</td><td class = "ra_type">table</td><td>모든 파일과 하위 디렉토리가 있는 테이블.</td></tr><tr><td class = "arguments ra_name">dir</td><td class = "ra_type">string</td><td>살펴볼 디렉토리.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getIdentity" name = "love.filesystem.getIdentity"><span>love.filesystem.</span><wbr>getIdentity</a></p><p class = "function_description">여러분의 게임에서 사용하고 있는 세이브 디렉토리의 이름을 구합니다.<br /><br />이 함수는 해당 폴더의 이름만 리턴하지 전체 경로를 리턴하지는 않으니 주의하세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.filesystem.<wbr>getIdentity( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>쓰기 디렉토리로 사용되는 ID.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getLastModified" name = "love.filesystem.getLastModified"><span>love.filesystem.</span><wbr>getLastModified</a></p><p class = "function_description">해당 파일을 마지막으로 수정한 날짜를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">modtime</span>, <span class = "returns">errormsg</span> = love.filesystem.<wbr>getLastModified( <span class = "arguments">filename</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">modtime</td><td class = "ra_type">number</td><td>Unix 에포크 이후의 최종 수정 시간 (초). 실패시에는 nil.</td></tr><tr><td class = "returns ra_name">errormsg</td><td class = "ra_type">string</td><td>실패하면 오류 메시지가 표시됩니다.</td></tr><tr><td class = "arguments ra_name">filename</td><td class = "ra_type">string</td><td>파일의 경로와 이름.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getRealDirectory" name = "love.filesystem.getRealDirectory"><span>love.filesystem.</span><wbr>getRealDirectory</a></p><p class = "function_description">파일 경로가있는 디렉토리의 플랫폼 별 절대 경로를 가져옵니다.<br /><br />이것은 파일이 저장 디렉토리 또는 게임의 소스 .love에 있는지 여부를 판별하는 데 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">realdir</span> = love.filesystem.<wbr>getRealDirectory( <span class = "arguments">filepath</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">realdir</td><td class = "ra_type">string</td><td>파일 경로를 포함하는 디렉토리의 플 '폼 특정 전체 경로.</td></tr><tr><td class = "arguments ra_name">filepath</td><td class = "ra_type">string</td><td>디렉토리를 가져올 파일 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getRequirePath" name = "love.filesystem.getRequirePath"><span>love.filesystem.</span><wbr>getRequirePath</a></p><p class = "function_description">require가 호출 될 때 검색 될 파일 시스템 경로를 가져옵니다.<br /><br />이 함수가 반환하는 경로 문자열은 세미콜론으로 구분 된 일련의 경로 템플릿입니다. require에 전달 된 인수는 각 템플릿의 물음표 ( "?") 문자 대신 삽입됩니다 (require에 전달 된 인수의 점 문자가 디렉토리 구분 기호로 대체 된 후).<br /><br />경로는 게임의 소스 및 저장 디렉토리뿐만 아니라 <a href="#love.filesystem.mount">love.filesystem.mount</a>로 마운트 된 경로와 관련이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">paths</span> = love.filesystem.<wbr>getRequirePath()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">paths</td><td class = "ra_type">string</td><td>require 함수가 사랑의 파일 시스템을 검사 할 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getSaveDirectory" name = "love.filesystem.getSaveDirectory"><span>love.filesystem.</span><wbr>getSaveDirectory</a></p><p class = "function_description">세이브 디렉토리의 완전한 경로를 얻어옵니다.<br /><br />이 함수는 표준 입출력 라이브러리 등에서 세이브 디렉토리에 접근할 때 유용하게 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">path</span> = love.filesystem.<wbr>getSaveDirectory()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">path</td><td class = "ra_type">string</td><td>세이브 디렉토리의 절대 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getSize" name = "love.filesystem.getSize"><span>love.filesystem.</span><wbr>getSize</a></p><p class = "function_description">파일의 바이트 수를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">size</span>, <span class = "returns">errormsg</span> = love.filesystem.<wbr>getSize( <span class = "arguments">filename</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>파일의 바이트 수. 실패하면 nil.</td></tr><tr><td class = "returns ra_name">errormsg</td><td class = "ra_type">string</td><td>실패시 발생하는 에러 메시지.</td></tr><tr><td class = "arguments ra_name">filename</td><td class = "ra_type">string</td><td>파일의 이름과 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getSource" name = "love.filesystem.getSource"><span>love.filesystem.</span><wbr>getSource</a></p><p class = "function_description">.love 파일 또는 디렉터리의 전체 경로를 가져옵니다. 게임이 L-VE 실행 파일에 융합되면 실행 파일이 반환됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">path</span> = love.filesystem.<wbr>getSource()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">path</td><td class = "ra_type">string</td><td>.love 파일 또는 디렉토리의 전체 플랫폼 종속 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getSourceBaseDirectory" name = "love.filesystem.getSourceBaseDirectory"><span>love.filesystem.</span><wbr>getSourceBaseDirectory</a></p><p class = "function_description">.love 파일이 들어있는 디렉토리의 전체 경로를 가져옵니다. 게임이 L-VE 실행 파일에 융합되면 실행 파일이 들어있는 디렉토리가 반환됩니다.<br /><br /><a href="#love.filesystem.isFused">love.filesystem.isFused</a>가 true이면이 함수가 반환하는 경로를 <a href="#love.filesystem.mount">love.filesystem.mount</a>에 전달할 수 있습니다. 그러면 love.filesystem에서 읽을 수있는 기본 게임이 포함 된 디렉토리가 만들어집니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">path</span> = love.filesystem.<wbr>getSourceBaseDirectory()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">path</td><td class = "ra_type">string</td><td>.love 파일이 들어있는 디렉토리의 전체 플랫폼 종속 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getUserDirectory" name = "love.filesystem.getUserDirectory"><span>love.filesystem.</span><wbr>getUserDirectory</a></p><p class = "function_description">사용자 디렉토리를 받아옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">path</span> = love.filesystem.<wbr>getUserDirectory()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">path</td><td class = "ra_type">string</td><td>사용자 디렉토리 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.getWorkingDirectory" name = "love.filesystem.getWorkingDirectory"><span>love.filesystem.</span><wbr>getWorkingDirectory</a></p><p class = "function_description">현재 작업 디렉토리를 받아옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">path</span> = love.filesystem.<wbr>getWorkingDirectory()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">path</td><td class = "ra_type">string</td><td>현재 작업 디렉토리.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.init" name = "love.filesystem.init"><span>love.filesystem.</span><wbr>init</a></p><p class = "function_description">love.filesystem을 초기화합니다. 내부적으로 사용되는 함수이므로 함부로 호출하지 마세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.filesystem.<wbr>init( <span class = "arguments">appname</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">appname</td><td class = "ra_type">string</td><td>응용 프로그램 바이너리 이름은 일반적으로 좋아합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.isDirectory" name = "love.filesystem.isDirectory"><span>love.filesystem.</span><wbr>isDirectory</a></p><p class = "function_description">무언가가 디렉토리인지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">isDir</span> = love.filesystem.<wbr>isDirectory( <span class = "arguments">path</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">isDir</td><td class = "ra_type">boolean</td><td>지정된 이름을 가진 디렉토리가 있으면 참입니다. 그렇지 않으면 거짓.</td></tr><tr><td class = "arguments ra_name">path</td><td class = "ra_type">string</td><td>잠재적 인 디렉토리 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.isFile" name = "love.filesystem.isFile"><span>love.filesystem.</span><wbr>isFile</a></p><p class = "function_description">무언가가 파일인지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">isFile</span> = love.filesystem.<wbr>isFile( <span class = "arguments">path</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">isFile</td><td class = "ra_type">boolean</td><td>파일이면 true.</td></tr><tr><td class = "arguments ra_name">path</td><td class = "ra_type">string</td><td>파일의 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.isFused" name = "love.filesystem.isFused"><span>love.filesystem.</span><wbr>isFused</a></p><p class = "function_description">게임이 퓨즈 모드로 설정되어 있는지 조사합니다.<br /><br />퓨즈 모드가 설정되어 있을 경우 세이브 디렉토리에 접근할 때 %appdata%\LOVE\ 대신 %appdata%를 사용합니다. 이를 통해 세이브 디렉토리에 저장되어 있는 C나 루아 라이브러리를 읽을 수 있습니다.<br /><br />퓨즈 모드는 .love를 퓨즈 모드로 설정해두거나(Game Distribution 참조) 또는 게임 실행시 명령줄에 "--fused"을 붙임으로서 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fused</span> = love.filesystem.<wbr>isFused()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fused</td><td class = "ra_type">boolean</td><td>퓨즈 모드라면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.isSymlink" name = "love.filesystem.isSymlink"><span>love.filesystem.</span><wbr>isSymlink</a></p><p class = "function_description">파일 경로가 실제로 심볼 링크인지 여부를 가져옵니다.<br /><br />심볼릭 링크가 활성화되어 있지 않으면 (<a href="#love.filesystem.setSymlinksEnabled">love.filesystem.setSymlinksEnabled</a>를 통해)이 함수는 항상 false를 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">symlink</span> = love.filesystem.<wbr>isSymlink( <span class = "arguments">path</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">symlink</td><td class = "ra_type">boolean</td><td>경로가 심볼 링크이면 true이고, 그렇지 않으면 false입니다.</td></tr><tr><td class = "arguments ra_name">path</td><td class = "ra_type">string</td><td>점검 할 파일 또는 디렉토리 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.lines" name = "love.filesystem.lines"><span>love.filesystem.</span><wbr>lines</a></p><p class = "function_description">텍스트 파일을 한 줄씩 읽는 반복자를 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">iterator</span> = love.filesystem.<wbr>lines( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">iterator</td><td class = "ra_type">function</td><td>텍스트 파일을 한 줄씩 읽는 반복자.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>파일의 이름과 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.load" name = "love.filesystem.load"><span>love.filesystem.</span><wbr>load</a></p><p class = "function_description">루아 파일을 불러오기만 합니다. 불러옴과 동시에 실행하지는 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">chunk</span> = love.filesystem.<wbr>load( <span class = "arguments">name</span>, <span class = "arguments">errormsg</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">chunk</td><td class = "ra_type">function</td><td>로드 된 청크.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>파일의 이름 (및 경로).</td></tr><tr><td class = "arguments ra_name">errormsg <span class = "default">(nil)</span></td><td class = "ra_type">string</td><td>파일을 열 수 없으면 오류 메시지가 표시됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.mount" name = "love.filesystem.mount"><span>love.filesystem.</span><wbr>mount</a></p><p class = "function_description">zip 파일을 마운트합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.filesystem.<wbr>mount( <span class = "arguments">archive</span>, <span class = "arguments">mountpoint</span>, <span class = "arguments">appendToPath</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>아카이브가 성공적으로 마운트되면 true를 반환하고 그렇지 않으면 false를 반환합니다.</td></tr><tr><td class = "arguments ra_name">archive</td><td class = "ra_type">string</td><td>게임의 저장 디렉토리에있는 폴더 또는 zip 파일을 마운트합니다.</td></tr><tr><td class = "arguments ra_name">mountpoint</td><td class = "ra_type">string</td><td>아카이브가 마운트 될 새 경로입니다.</td></tr><tr><td class = "arguments ra_name">appendToPath <span class = "default">(false)</span></td><td class = "ra_type">string</td><td>이미 마운트 된 아카이브 전후에 파일 경로를 읽을 때 아카이브를 검색할지 여부. 여기에는 게임의 소스와 저장 디렉토리가 포함됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.newFile" name = "love.filesystem.newFile"><span>love.filesystem.</span><wbr>newFile</a></p><p class = "function_description">새 파일 객체를 생성합니다.<br /><br />파일에 대한 접근 이전에 먼저 파일을 열어야 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">file</span>, <span class = "returns">errorstr</span> = love.filesystem.<wbr>newFile( <span class = "arguments">filename</span>, <span class = "arguments">mode</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">file</td><td class = "ra_type"><a href="#File">File</a></td><td>새 파일 객체.</td></tr><tr><td class = "returns ra_name">errorstr</td><td class = "ra_type">string</td><td>에러가 발생하였을 경우 메시지.</td></tr><tr><td class = "arguments ra_name">filename</td><td class = "ra_type">string</td><td>파일 이름.</td></tr><tr><td class = "arguments ra_name">mode <span class = "default">("c")</span></td><td class = "ra_type"><a href="#FileMode">FileMode</a></td><td>파일 모드.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.newFileData" name = "love.filesystem.newFileData"><span>love.filesystem.</span><wbr>newFileData</a></p><p class = "function_description">새 FileData 객체를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">data</span> = love.filesystem.<wbr>newFileData( <span class = "arguments">contents</span>, <span class = "arguments">name</span>, <span class = "arguments">decoder</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">data</td><td class = "ra_type"><a href="#FileData">FileData</a></td><td>새 FileData.</td></tr><tr><td class = "arguments ra_name">contents</td><td class = "ra_type">string</td><td>파일의 콘텐츠.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>파일 이름.</td></tr><tr><td class = "arguments ra_name">decoder <span class = "default">("file")</span></td><td class = "ra_type"><a href="#FileDecoder">FileDecoder</a></td><td>파일을 디코딩할 때 사용.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">data</span>, <span class = "returns">err</span> = love.filesystem.<wbr>newFileData( <span class = "arguments">filepath</span> )</span></span></p><p class = "variant_description">하드디스크의 파일로부터 FileData 생성.</p><table class = "ra_table"><tr><td class = "returns ra_name">data</td><td class = "ra_type"><a href="#FileData">FileData</a></td><td>새 FileData.</td></tr><tr><td class = "returns ra_name">err</td><td class = "ra_type">string</td><td>문제가 발생했을 경우 에러 메시지.</td></tr><tr><td class = "arguments ra_name">filepath</td><td class = "ra_type">string</td><td>파일 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.read" name = "love.filesystem.read"><span>love.filesystem.</span><wbr>read</a></p><p class = "function_description">파일을 읽습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">contents</span>, <span class = "returns">size</span> = love.filesystem.<wbr>read( <span class = "arguments">name</span>, <span class = "arguments">bytes</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">contents</td><td class = "ra_type">string</td><td>읽힌 문자열.</td></tr><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>읽힌 바이트 수.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>파일의 경로와 이름.</td></tr><tr><td class = "arguments ra_name">bytes <span class = "default">(all)</span></td><td class = "ra_type">number</td><td>읽을 바이트 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.remove" name = "love.filesystem.remove"><span>love.filesystem.</span><wbr>remove</a></p><p class = "function_description">파일이나 디렉토리를 제거합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.filesystem.<wbr>remove( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>삭제에 성공하면 true.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>제거할 파일이나 디렉토리.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.setIdentity" name = "love.filesystem.setIdentity"><span>love.filesystem.</span><wbr>setIdentity</a></p><p class = "function_description">여러분의 게임에서 사용할 세이브 디렉토리의 이름을 정합니다.<br /><br />이 함수는 해당 폴더의 이름만 설정하며 전체 경로를 설정할 수는 않으니 주의하세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.filesystem.<wbr>setIdentity( <span class = "arguments">name</span>, <span class = "arguments">appendToPath</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>세이브 디렉토리의 이름.</td></tr><tr><td class = "arguments ra_name">appendToPath <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>.love 압축 파일 또는 그 외 <a href="#love.filesystem.mount">love.filesystem.mount</a>로 마운트된 저장소의 앞이나 뒤에 파일 경로를 읽을 때 아카이브가 검색되어야 하면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.setRequirePath" name = "love.filesystem.setRequirePath"><span>love.filesystem.</span><wbr>setRequirePath</a></p><p class = "function_description">require가 호출 될 때 검색 될 파일 시스템 경로를 설정합니다.<br /><br />이 함수에 주어진 경로 문자열은 세미콜론으로 구분 된 일련의 경로 템플릿입니다. require에 전달 된 인수는 각 템플릿의 물음표 ( "?") 문자 대신 삽입됩니다 (require에 전달 된 인수의 점 문자가 디렉토리 구분 기호로 대체 된 후).<br /><br />경로는 게임의 소스 및 저장 디렉토리뿐만 아니라 <a href="#love.filesystem.mount">love.filesystem.mount</a>로 마운트 된 경로와 관련이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.filesystem.<wbr>setRequirePath( <span class = "arguments">paths</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">paths</td><td class = "ra_type">string</td><td>require 함수가 사랑의 파일 시스템을 검사 할 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.setSource" name = "love.filesystem.setSource"><span>love.filesystem.</span><wbr>setSource</a></p><p class = "function_description">소스 코드가 있는 위치를 설정합니다. 이 함수는 L&Ouml;VE에 의해 자동적으로 호출되니 건들지 마세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.filesystem.<wbr>setSource( <span class = "arguments">path</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">path</td><td class = "ra_type">string</td><td>소스 코드가 있는 위치의 절대 경로.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.setSymlinksEnabled" name = "love.filesystem.setSymlinksEnabled"><span>love.filesystem.</span><wbr>setSymlinksEnabled</a></p><p class = "function_description">love.filesystem이 기호 링크를 따를 지 여부를 설정합니다. 버전 0.10.0 이상에서는 기본적으로 활성화되어 있으며 0.9.2에서는 기본적으로 비활성화되어 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.filesystem.<wbr>setSymlinksEnabled( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>love.filesystem이 기호 링크를 따라야하는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.unmount" name = "love.filesystem.unmount"><span>love.filesystem.</span><wbr>unmount</a></p><p class = "function_description"><a href="#love.filesystem.mount">love.filesystem.mount</a>로 마운트된 zip 파일을 언마운트 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.filesystem.<wbr>unmount( <span class = "arguments">archive</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>아카이브가 성공적으로 마운트 해제되면 true를 반환하고 그렇지 않으면 false를 반환합니다.</td></tr><tr><td class = "arguments ra_name">archive</td><td class = "ra_type">string</td><td>현재 마운트 된 게임 저장 디렉토리의 폴더 또는 zip 파일.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.filesystem.write" name = "love.filesystem.write"><span>love.filesystem.</span><wbr>write</a></p><p class = "function_description">세이브 디렉토리에 파일을 씁니다. 파일이 이미 존재한다면 강제로 덮어씁니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span>, <span class = "returns">message</span> = love.filesystem.<wbr>write( <span class = "arguments">name</span>, <span class = "arguments">data</span>, <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>조작이 성공했을 경우.</td></tr><tr><td class = "returns ra_name">message</td><td class = "ra_type">string</td><td>작업이 실패한 경우 오류 메시지가 표시됩니다.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>파일의 이름 (및 경로).</td></tr><tr><td class = "arguments ra_name">data</td><td class = "ra_type">string</td><td>파일에 쓸 문자열 데이터입니다.</td></tr><tr><td class = "arguments ra_name">size <span class = "default">(all)</span></td><td class = "ra_type">number</td><td>쓸 바이트 수.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span>, <span class = "returns">message</span> = love.filesystem.<wbr>write( <span class = "arguments">name</span>, <span class = "arguments">data</span>, <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>조작이 성공했을 경우.</td></tr><tr><td class = "returns ra_name">message</td><td class = "ra_type">string</td><td>작업이 실패한 경우 오류 메시지가 표시됩니다.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>파일의 이름 (및 경로).</td></tr><tr><td class = "arguments ra_name">data</td><td class = "ra_type"><a href="#Data">Data</a></td><td>파일에 쓸 데이터 객체입니다.</td></tr><tr><td class = "arguments ra_name">size <span class = "default">(all)</span></td><td class = "ra_type">number</td><td>쓸 바이트 수.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#BufferMode" name = "BufferMode">BufferMode</a></p><p class = "constant_name">none</p><p class = "constant_description">버퍼링하지 않습니다. 쓰기 동작과 추가 동작의 결과가 바로 나타납니다.</p><p class = "constant_name">line</p><p class = "constant_description">한 줄씩 버퍼링합니다. 새 줄이 등장하거나 버퍼의 크기가 꽉 찰 때까지 쓰기 동작와 추가 동작을 버퍼링합니다.</p><p class = "constant_name">full</p><p class = "constant_description">끝까지 버퍼링합니다. 버퍼의 크기가 꽉 찰 때까지 쓰기 동작과 추가 동작을 버퍼링합니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#FileDecoder" name = "FileDecoder">FileDecoder</a></p><p class = "constant_name">file</p><p class = "constant_description">데이터가 인코딩되지 않았습니다.</p><p class = "constant_name">base64</p><p class = "constant_description">데이터는 base64로 인코딩됩니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#FileMode" name = "FileMode">FileMode</a></p><p class = "constant_name">r</p><p class = "constant_description">읽기 전용 모드.</p><p class = "constant_name">w</p><p class = "constant_description">쓰기 전용 모드.</p><p class = "constant_name">a</p><p class = "constant_description">추가 전용 모드.</p><p class = "constant_name">c</p><p class = "constant_description">파일을 열지 않음(파일이 닫혀 있음을 나타냄).</p></div><div class = "section"><p class = "section_heading"><a href = "#File" name = "File">File</a></p><p class = "section_description">파일 시스템의 파일을 나타냅니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.newFile">newFile</a>&emsp;새 파일 객체를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:open">open</a>&emsp;읽기나 쓰기 따위를 하기 위해 파일을 엽니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:close">close</a>&emsp;파일을 닫습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:read">read</a>&emsp;파일을 읽습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:lines">lines</a>&emsp;텍스트 파일을 한 줄씩 읽는 반복자를 리턴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:write">write</a>&emsp;데이터를 파일에 씁니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:getBuffer">get</a><span class = "slash">/</span><a href="#File:setBuffer">setBuffer</a>&emsp;파일 쓰기와 추가 시 사용할 버퍼링 모드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:flush">flush</a>&emsp;버퍼를 완전히 비웁니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:getMode">getMode</a>&emsp;파일 모드를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:isOpen">isOpen</a>&emsp;파일이 열려 있는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:isEOF">isEOF</a>&emsp;파일 끝에 도달했는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:getFilename">getFilename</a>&emsp;File 객체가 작성된 파일 이름을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:getSize">getSize</a>&emsp;파일의 크기를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">File:<a href="#File:tell">tell</a><span class = "slash">/</span><a href="#File:seek">seek</a>&emsp;파일의 포인터 위치를 변경합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#File:close" name = "File:close"><span>File:</span><wbr>close</a></p><p class = "function_description">파일을 닫습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = File:<wbr>close()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공적으로 닫았을 경우 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:flush" name = "File:flush"><span>File:</span><wbr>flush</a></p><p class = "function_description">버퍼를 완전히 비웁니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span>, <span class = "returns">err</span> = File:<wbr>flush()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공적으로 비웠으면 true.</td></tr><tr><td class = "returns ra_name">err</td><td class = "ra_type">string</td><td>에러 메시지.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:getBuffer" name = "File:getBuffer"><span>File:</span><wbr>getBuffer</a></p><p class = "function_description">버퍼링 모드를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mode</span>, <span class = "returns">size</span> = File:<wbr>getBuffer()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mode</td><td class = "ra_type"><a href="#BufferMode">BufferMode</a></td><td>현재 버퍼링 모드.</td></tr><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>버퍼 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:getFilename" name = "File:getFilename"><span>File:</span><wbr>getFilename</a></p><p class = "function_description">File 객체가 작성된 파일 이름을 가져옵니다. 파일 객체가 love.filedropped 콜백에서 비롯된 경우 파일 이름은 전체 플랫폼 종속 파일 경로가됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">filename</span> = File:<wbr>getFilename()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">filename</td><td class = "ra_type">string</td><td>파일의 파일 이름입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:getMode" name = "File:getMode"><span>File:</span><wbr>getMode</a></p><p class = "function_description">파일 모드를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mode</span> = File:<wbr>getMode()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mode</td><td class = "ra_type"><a href="#FileMode">FileMode</a></td><td>파일 모드.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:getSize" name = "File:getSize"><span>File:</span><wbr>getSize</a></p><p class = "function_description">파일의 크기를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">size</span> = File:<wbr>getSize()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>파일의 크기(바이트).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:isEOF" name = "File:isEOF"><span>File:</span><wbr>isEOF</a></p><p class = "function_description">파일 끝에 도달했는지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">eof</span> = File:<wbr>isEOF()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">eof</td><td class = "ra_type">boolean</td><td>EOF에 도달했는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:isOpen" name = "File:isOpen"><span>File:</span><wbr>isOpen</a></p><p class = "function_description">파일이 열려 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">open</span> = File:<wbr>isOpen()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">open</td><td class = "ra_type">boolean</td><td>열려 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:lines" name = "File:lines"><span>File:</span><wbr>lines</a></p><p class = "function_description">텍스트 파일을 한 줄씩 읽는 반복자를 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">iterator</span> = File:<wbr>lines()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">iterator</td><td class = "ra_type">function</td><td>텍스트 파일을 한 줄씩 읽는 반복자.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:open" name = "File:open"><span>File:</span><wbr>open</a></p><p class = "function_description">읽기나 쓰기 따위를 하기 위해 파일을 엽니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = File:<wbr>open( <span class = "arguments">mode</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공했으면 true.</td></tr><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#FileMode">FileMode</a></td><td>파일 모드.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:read" name = "File:read"><span>File:</span><wbr>read</a></p><p class = "function_description">파일을 읽습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">contents</span>, <span class = "returns">size</span> = File:<wbr>read( <span class = "arguments">bytes</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">contents</td><td class = "ra_type">string</td><td>읽힌 문자열.</td></tr><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>읽힌 바이트 수.</td></tr><tr><td class = "arguments ra_name">bytes <span class = "default">(all)</span></td><td class = "ra_type">number</td><td>읽을 바이트 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:seek" name = "File:seek"><span>File:</span><wbr>seek</a></p><p class = "function_description">파일의 포인터 위치를 변경합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = File:<wbr>seek( <span class = "arguments">position</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>위치 변경에 성공했으면 true.</td></tr><tr><td class = "arguments ra_name">position</td><td class = "ra_type">number</td><td>포인터 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:setBuffer" name = "File:setBuffer"><span>File:</span><wbr>setBuffer</a></p><p class = "function_description">파일 쓰기와 추가 시 사용할 버퍼링 모드를 설정합니다. 버퍼링이 켜져 있으면 파일로의 출력 시 버퍼의 크기가 꽉 차기 전까지는 실제 적용되지 않습니다(버퍼링 모드에 따라 그러지 않는 경우도 있음).<br /><br />File:flush는 강제로 버퍼를 비워 모두 출력하게 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span>, <span class = "returns">errorstr</span> = File:<wbr>setBuffer( <span class = "arguments">mode</span>, <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공적으로 설정되었으면 true.</td></tr><tr><td class = "returns ra_name">errorstr</td><td class = "ra_type">string</td><td>에러가 발생하였으면 메시지를 리턴.</td></tr><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#BufferMode">BufferMode</a></td><td>사용할 버퍼링 모드.</td></tr><tr><td class = "arguments ra_name">size <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>버퍼의 크기(바이트).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:tell" name = "File:tell"><span>File:</span><wbr>tell</a></p><p class = "function_description">파일 내의 위치를 ​​돌려줍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">pos</span> = File:<wbr>tell()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">pos</td><td class = "ra_type">number</td><td>현재 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#File:write" name = "File:write"><span>File:</span><wbr>write</a></p><p class = "function_description">데이터를 파일에 씁니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = File:<wbr>write( <span class = "arguments">data</span>, <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>쓰는데 성공했으면 true.</td></tr><tr><td class = "arguments ra_name">data</td><td class = "ra_type">string</td><td>쓸 문자열 데이터.</td></tr><tr><td class = "arguments ra_name">size <span class = "default">(all)</span></td><td class = "ra_type">number</td><td>쓸 바이트 수.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#FileData" name = "FileData">FileData</a></p><p class = "section_description">파일 내부의 콘텐츠를 가리키는 데이터 입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.filesystem.<a href="#love.filesystem.newFileData">newFileData</a>&emsp;새 FileData 객체를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">FileData:<a href="#FileData:getFilename">getFilename</a>&emsp;FileData의 파일 이름을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">FileData:<a href="#FileData:getExtension">getExtension</a>&emsp;확장자를 얻어옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Data">Data</a>&emsp;모든 데이터 타입의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#FileData:getExtension" name = "FileData:getExtension"><span>FileData:</span><wbr>getExtension</a></p><p class = "function_description">확장자를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ext</span> = FileData:<wbr>getExtension()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ext</td><td class = "ra_type">string</td><td>확장자.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#FileData:getFilename" name = "FileData:getFilename"><span>FileData:</span><wbr>getFilename</a></p><p class = "function_description">FileData의 파일 이름을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">name</span> = FileData:<wbr>getFilename()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">name</td><td class = "ra_type">string</td><td>FileData가 나타내는 파일의 이름입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.graphics" name = "love.graphics">love.graphics</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Canvas">Canvas</a>&emsp;캔버스는 스크린 외부 렌더링에 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Font">Font</a>&emsp;화면에 그릴 수있는 문자의 모양을 정의합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Mesh">Mesh</a>&emsp;임의의 텍스처 모양을 ​​그리는 데 사용되는 2D 폴리곤 메쉬입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Image">Image</a>&emsp;드로어 블 이미지 유형. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ParticleSystem">ParticleSystem</a>&emsp;화재와 같은 시원한 효과를 내기 위해 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Quad">Quad</a>&emsp;텍스처 좌표 정보가있는 사변형 (4면과 4 개의 모서리가있는 다각형)입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shader">Shader</a>&emsp;셰이더는 고급 하드웨어 가속 픽셀 또는 버텍스 조작에 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SpriteBatch">SpriteBatch</a>&emsp;단일 이미지를 사용하여 love.graphics.draw를 한 번 호출하면 이미지의 동일한 복사본을 여러 개 그릴 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Text">Text</a>&emsp;텍스트를 그릴 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Texture">Texture</a>&emsp;텍스처를 나타내는 드로어 블 오브젝트의 슈퍼 클래스입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Video">Video</a>&emsp;드로어 블 비디오. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.draw">draw</a>&emsp;선택적 회전, 크기 조절 및 전단 기능을 사용하여 Drawable 객체 (이미지, 캔바스, SpriteBatch, 입자 시스템, 메쉬 또는 비디오)를 화면에 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.print">print</a>&emsp;화면에 텍스트를 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.printf">printf</a>&emsp;단어 줄 바꿈 및 맞춤을 사용하여 서식이 지정된 텍스트를 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.line">line</a>&emsp;점 사이에 선을 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.polygon">polygon</a>&emsp;다각형을 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.rectangle">rectangle</a>&emsp;직사각형을 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.circle">circle</a>&emsp;원을 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.ellipse">ellipse</a>&emsp;타원을 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.arc">arc</a>&emsp;위치 (x, y)에 채워지거나 채워지지 않은 호를 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.points">points</a>&emsp;하나 이상의 점을 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.stencil">stencil</a>&emsp;지오메트리를 스텐실로 그립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getStencilTest">get</a><span class = "slash">/</span><a href="#love.graphics.setStencilTest">setStencilTest</a>&emsp;스텐실 테스트를 구성하거나 비활성화합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.push">push</a>&emsp;현재 좌표 변환을 복사하여 변환 스택에 푸시합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.pop">pop</a>&emsp;변환 스택에서 현재 좌표 변환을 팝합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.reset">reset</a>&emsp;현재 그래픽 설정을 재설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getFont">get</a><span class = "slash">/</span><a href="#love.graphics.setFont">setFont</a>&emsp;이미로드 된 Font를 현재 글꼴로 설정하거나 파일과 크기에서 새 글꼴을 만들고로드하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getBackgroundColor">get</a><span class = "slash">/</span><a href="#love.graphics.setBackgroundColor">setBackgroundColor</a>&emsp;배경색을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getBlendMode">get</a><span class = "slash">/</span><a href="#love.graphics.setBlendMode">setBlendMode</a>&emsp;혼합 모드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getCanvas">get</a><span class = "slash">/</span><a href="#love.graphics.setCanvas">setCanvas</a>&emsp;캔버스에 드로잉 작업을 캡처합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getColor">get</a><span class = "slash">/</span><a href="#love.graphics.setColor">setColor</a>&emsp;묘화에 사용하는 색을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getColorMask">get</a><span class = "slash">/</span><a href="#love.graphics.setColorMask">setColorMask</a>&emsp;색상 마스크를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getDefaultFilter">get</a><span class = "slash">/</span><a href="#love.graphics.setDefaultFilter">setDefaultFilter</a>&emsp;이미지, 캔버스 및 글꼴에 사용되는 기본 배율 필터를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getLineJoin">get</a><span class = "slash">/</span><a href="#love.graphics.setLineJoin">setLineJoin</a>&emsp;라인 결합 스타일을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getLineStyle">get</a><span class = "slash">/</span><a href="#love.graphics.setLineStyle">setLineStyle</a>&emsp;선 스타일을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getLineWidth">get</a><span class = "slash">/</span><a href="#love.graphics.setLineWidth">setLineWidth</a>&emsp;선의 폭을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getShader">get</a><span class = "slash">/</span><a href="#love.graphics.setShader">setShader</a>&emsp;셰이더를 현재 픽셀 효과 또는 버텍스 셰이더로 설정하거나 재설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getPointSize">get</a><span class = "slash">/</span><a href="#love.graphics.setPointSize">setPointSize</a>&emsp;포인트 크기를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getScissor">get</a><span class = "slash">/</span><a href="#love.graphics.setScissor">setScissor</a>&emsp;가위를 설정 또는 해제합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.intersectScissor">intersectScissor</a>&emsp;가위를 지정된 사각형과 기존 가위의 교차에 의해 생성 된 사각형으로 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.origin">origin</a>&emsp;현재 좌표 변환을 다시 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.rotate">rotate</a>&emsp;좌표계를 2 차원으로 회전합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.scale">scale</a>&emsp;좌표계의 크기를 2 차원으로 조정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.shear">shear</a>&emsp;좌표계를 변경합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.translate">translate</a>&emsp;좌표계를 2 차원으로 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getDimensions">getDimensions</a>&emsp;윈도우의 폭과 높이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getHeight">getHeight</a>&emsp;윈도우 높이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getWidth">getWidth</a>&emsp;윈도우의 폭을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getCanvasFormats">getCanvasFormats</a>&emsp;사용 가능한 Canvas 형식과 각 형식이 지원되는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getCompressedImageFormats">getCompressedImageFormats</a>&emsp;사용 가능한 압축 이미지 형식과 각 압축 이미지 형식의 지원 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getStats">getStats</a>&emsp;성능 관련 렌더링 통계를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getSystemLimits">getSystemLimits</a>&emsp;love.graphics 기능의 시스템 종속 최대 값을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getRendererInfo">getRendererInfo</a>&emsp;시스템의 비디오 카드 및 드라이버에 대한 정보를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.getSupported">getSupported</a>&emsp;선택적 그래픽 기능과 해당 기능이 시스템에서 지원되는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.isGammaCorrect">isGammaCorrect</a>&emsp;감마 보정이 지원되는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newScreenshot">newScreenshot</a>&emsp;스크린 샷을 만들고 이미지 데이터를 반환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.isWireframe">is</a><span class = "slash">/</span><a href="#love.graphics.setWireframe">setWireframe</a>&emsp;와이어 프레임 선을 그릴 때 사용할지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.clear">clear</a>&emsp;L&Ouml;VE 0.9.2 이전 버전의 배경색 또는 0.10.0 이상으로 지정된 색으로 화면을 지 웁니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.discard">discard</a>&emsp;화면 또는 활성 캔버스의 내용을 삭제 (휴지통)합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.present">present</a>&emsp;화면에 그리기 작업의 결과를 표시합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#AlignMode">AlignMode</a>&emsp;텍스트의 정렬 방식을 지정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ArcType">ArcType</a>&emsp;그릴 수있는 다양한 종류의 호. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#AreaSpreadDistribution">AreaSpreadDistribution</a>&emsp;입자 면적 분포의 유형. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#BlendAlphaMode">BlendAlphaMode</a>&emsp;알파 블렌딩에 영향을 미치는 여러 가지 방법이 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#BlendMode">BlendMode</a>&emsp;다양한 방식의 알파 블렌딩 모드를 지정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CanvasFormat">CanvasFormat</a>&emsp;캔버스 포맷. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompareMode">CompareMode</a>&emsp;픽셀 별 스텐실 테스트 비교 유형이 다릅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#DrawMode">DrawMode</a>&emsp;외곽선을 그릴 건지 채워넣을 것인지 그리기 모드를 결정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FilterMode">FilterMode</a>&emsp;이미지가 확대 및 축소될 때 어떻게 필터링할 것인지 지정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#GraphicsFeature">GraphicsFeature</a>&emsp;love.graphics.getSupported를 사용하여 확인할 수있는 그래픽 기능. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#GraphicsLimit">GraphicsLimit</a>&emsp;love.graphics.getSystemLimits를 사용하여 시스템 종속 그래픽 제한 유형을 확인했습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#LineJoin">LineJoin</a>&emsp;조인 유형입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#LineStyle">LineStyle</a>&emsp;선의 스타일을 지정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MeshDrawMode">MeshDrawMode</a>&emsp;메쉬의 정점을 그리는 방법. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ParticleInsertMode">ParticleInsertMode</a>&emsp;새로 생성 된 입자가 ParticleSystem에 추가되는 방법. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SpriteBatchUsage">SpriteBatchUsage</a>&emsp;SpriteBatches 및 Meshes가 데이터 저장 및 액세스를 최적화하기위한 사용 힌트. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#StackType">StackType</a>&emsp;love.graphics.push와 함께 사용되는 그래픽 상태 스택 유형입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#StencilAction">StencilAction</a>&emsp;스텐실 함수가 닿는 픽셀의 스텐실 값을 수정하는 방법 </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#WrapMode">WrapMode</a>&emsp;이미지가 이미지 크기보다 큰 4 배 크기의 쿼드 내에서 어떻게 랩핑됩니까? 이것은 {0, 1}의 범위 밖에있는 텍스처 좌표로 메쉬를 그린 방법과 {0, 1} 범위를 벗어난 텍스쳐 좌표로 샘플링 할 때 텍셀 셰이더 함수에 의해 반환되는 색에 영향을 미칩니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.arc" name = "love.graphics.arc"><span>love.graphics.</span><wbr>arc</a></p><p class = "function_description">위치 (x, y)에 채워지거나 채워지지 않은 호를 그립니다. 호는 각도 1에서 각도 2까지 라디안 단위로 그려집니다. segments 매개 변수는 호를 그리는 데 사용되는 세그먼트 수를 결정합니다. 세그먼트가 많을수록 가장자리가 매끄러 워집니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>arc( <span class = "arguments">drawmode</span>, <span class = "arguments">arctype</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">radius</span>, <span class = "arguments">angle1</span>, <span class = "arguments">angle2</span>, <span class = "arguments">segments</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">drawmode</td><td class = "ra_type"><a href="#DrawMode">DrawMode</a></td><td>호를 그리는 법.</td></tr><tr><td class = "arguments ra_name">arctype <span class = "default">("pie")</span></td><td class = "ra_type"><a href="#ArcType">ArcType</a></td><td>그릴 호의 유형입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">radius</td><td class = "ra_type">number</td><td>호의 반지름입니다.</td></tr><tr><td class = "arguments ra_name">angle1</td><td class = "ra_type">number</td><td>아크가 시작되는 각도입니다.</td></tr><tr><td class = "arguments ra_name">angle2</td><td class = "ra_type">number</td><td>호가 끝나는 각도입니다.</td></tr><tr><td class = "arguments ra_name">segments <span class = "default">(10)</span></td><td class = "ra_type">number</td><td>호 그리기에 사용되는 세그먼트 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.circle" name = "love.graphics.circle"><span>love.graphics.</span><wbr>circle</a></p><p class = "function_description">원을 그립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>circle( <span class = "arguments">mode</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">radius</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#DrawMode">DrawMode</a></td><td>원을 그리는 법.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">radius</td><td class = "ra_type">number</td><td>원의 반지름입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>circle( <span class = "arguments">mode</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">radius</span>, <span class = "arguments">segments</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#DrawMode">DrawMode</a></td><td>원을 그리는 법.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">radius</td><td class = "ra_type">number</td><td>원의 반지름입니다.</td></tr><tr><td class = "arguments ra_name">segments</td><td class = "ra_type">number</td><td>원 그리기에 사용되는 세그먼트 수입니다. 참고 : 세그먼트 매개 변수의 기본 변수는 다양한 버전의 L-VE에 따라 다릅니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.clear" name = "love.graphics.clear"><span>love.graphics.</span><wbr>clear</a></p><p class = "function_description">L&Ouml;VE 0.9.2 이전 버전의 배경색 또는 0.10.0 이상으로 지정된 색으로 화면을 지 웁니다.<br /><br />이 함수는 기본 love.run 함수에서 love.draw 전에 자동으로 호출됩니다. 이 함수의 일반적인 사용법은 love.run의 예제를 참조하십시오.<br /><br />가위 영역은 해제 된 영역을 경계합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>clear()</span></span></p><p class = "variant_description">Clears the screen to the background color in 0.9.2 and earlier, or to transparent black (0, 0, 0, 0) in L&Ouml;VE 0.10.0 and newer.</p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>clear( <span class = "arguments">r</span>, <span class = "arguments">g</span>, <span class = "arguments">b</span>, <span class = "arguments">a</span> )</span></span></p><p class = "variant_description">지정된 색상 스크린 또는 활성 Canvas 삭제.</p><table class = "ra_table"><tr><td class = "arguments ra_name">r</td><td class = "ra_type">number</td><td>화면을 지울 색상의 빨간색 채널입니다.</td></tr><tr><td class = "arguments ra_name">g</td><td class = "ra_type">number</td><td>화면을 지우는 색상의 녹색 채널입니다.</td></tr><tr><td class = "arguments ra_name">b</td><td class = "ra_type">number</td><td>화면을 지우는 색상의 파란색 채널입니다.</td></tr><tr><td class = "arguments ra_name">a <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>화면을 지울 색상의 알파 채널입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>clear( <span class = "arguments">color</span>, <span class = "arguments">...</span> )</span></span></p><p class = "variant_description">Clears multiple active Canvases to different colors, if multiple Canvases are active at once via <a href="#love.graphics.setCanvas">love.graphics.setCanvas</a>.</p><table class = "ra_table"><tr><td class = "arguments ra_name">color</td><td class = "ra_type">table</td><td>첫 번째 활성 Canvas를 지울 색상이 들어있는 {r, g, b, a} 형태의 표.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">table</td><td>각 활성 캔버스에 대한 추가 테이블.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.discard" name = "love.graphics.discard"><span>love.graphics.</span><wbr>discard</a></p><p class = "function_description">화면 또는 활성 캔버스의 내용을 삭제 (휴지통)합니다. 틈새 유스 케이스가있는 성능 최적화 함수입니다.<br /><br />활성 캔버스가 방금 변경되고 전체 화면을 덮는 무언가를 그리는 데 "대체"BlendMode를 사용하려는 경우 <a href="#love.graphics.clear">love.graphics.clear</a>를 호출하는 대신 love.graphics.discard를 호출하거나 아무 작업도 수행하지 않으면 모바일 성능이 향상 될 수 있습니다 장치.<br /><br />일부 데스크탑 시스템에서는이 기능이 아무 것도 수행하지 않을 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>discard( <span class = "arguments">discardcolor</span>, <span class = "arguments">discardstencil</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">discardcolor <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>활성 캔버스 (활성 캔버스가없는 경우 화면의 내용)의 텍스처를 삭제할지 여부입니다.</td></tr><tr><td class = "arguments ra_name">discardstencil <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>화면 / 활성 캔버스의 스텐실 버퍼 내용을 버릴 지 여부.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>discard( <span class = "arguments">discardcolors</span>, <span class = "arguments">discardstencil</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">discardcolors</td><td class = "ra_type">table</td><td>여러 개의 동시 Canvas가 활성 상태 일 때 각 활성 Canvas의 질감을 무시할지 여부를 나타내는 부울 값을 포함하는 배열입니다.</td></tr><tr><td class = "arguments ra_name">discardstencil <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>화면 / 활성 캔버스의 스텐실 버퍼 내용을 버릴 지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.draw" name = "love.graphics.draw"><span>love.graphics.</span><wbr>draw</a></p><p class = "function_description">선택적 회전, 크기 조절 및 전단 기능을 사용하여 <a href="#Drawable">Drawable</a> 객체 (이미지, 캔바스, <a href="#SpriteBatch">SpriteBatch</a>, 입자 시스템, 메쉬 또는 비디오)를 화면에 그립니다.<br /><br />객체는 로컬 좌표계를 기준으로 그려집니다. 원점은 기본적으로 <a href="#Image">Image</a> 및 <a href="#Canvas">Canvas</a>의 왼쪽 위 모서리에 있습니다. 모든 크기 조절, 기울이기 및 회전 인수는 해당 점을 기준으로 객체를 변형합니다. 또한 화면 좌표계에서 원점의 ​​위치를 ​​지정할 수 있습니다.<br /><br />원점을 중심으로 오프셋하여 객체를 중심에 대해 회전시킬 수 있습니다. 회전 각도는 라디안 단위로 지정해야합니다. 음수 배율 인수를 사용하여 중심선을 뒤집을 수도 있습니다.<br /><br />오프셋은 회전, 스케일링 또는 전단 전에 적용됩니다. 회전 전에 스케일링과 전단이 적용됩니다.<br /><br />물체의 오른쪽 및 아래쪽 가장자리는 전단 요소에 의해 정의 된 각도로 이동합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>draw( <span class = "arguments">drawable</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">drawable</td><td class = "ra_type"><a href="#Drawable">Drawable</a></td><td>Drawable 객체입니다.</td></tr><tr><td class = "arguments ra_name">x <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>물체를 그리는 위치 (x 축)입니다.</td></tr><tr><td class = "arguments ra_name">y <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오브젝트를 그리는 위치입니다 (y 축).</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축). 부정적 일 수 있습니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축). 부정적 일 수 있습니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축). (값 20은 드로어 블 오브젝트를 왼쪽으로 20 픽셀 이동시키는 효과가 있습니다.)</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축). (값 20은 효율적으로 드로어 블 오브젝트를 20 픽셀 위로 이동시킵니다.)</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>draw( <span class = "arguments">texture</span>, <span class = "arguments">quad</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>Quad를 텍스처링하기위한 텍스처 (이미지 또는 캔버스).</td></tr><tr><td class = "arguments ra_name">quad</td><td class = "ra_type"><a href="#Quad">Quad</a></td><td>화면에 그리는 쿼드.</td></tr><tr><td class = "arguments ra_name">x <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>물체를 그리는 위치 (x 축)입니다.</td></tr><tr><td class = "arguments ra_name">y <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오브젝트를 그리는 위치입니다 (y 축).</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축). 부정적 일 수 있습니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축). 부정적 일 수 있습니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축).</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축)</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.ellipse" name = "love.graphics.ellipse"><span>love.graphics.</span><wbr>ellipse</a></p><p class = "function_description">타원을 그립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>ellipse( <span class = "arguments">mode</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">radiusx</span>, <span class = "arguments">radiusy</span>, <span class = "arguments">segments</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#DrawMode">DrawMode</a></td><td>타원을 그리는 법.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따른 중심의 위치입니다.</td></tr><tr><td class = "arguments ra_name">radiusx</td><td class = "ra_type">number</td><td>x 축을 따라 타원의 반지름 (타원의 너비의 절반)입니다.</td></tr><tr><td class = "arguments ra_name">radiusy</td><td class = "ra_type">number</td><td>y 축을 따라 타원의 반경 (타원 높이의 절반)입니다.</td></tr><tr><td class = "arguments ra_name">segments <span class = "default">(based on size)</span></td><td class = "ra_type">number</td><td>타원 그리기에 사용되는 세그먼트 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getBackgroundColor" name = "love.graphics.getBackgroundColor"><span>love.graphics.</span><wbr>getBackgroundColor</a></p><p class = "function_description">현재 배경색을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">r</span>, <span class = "returns">g</span>, <span class = "returns">b</span>, <span class = "returns">a</span> = love.graphics.<wbr>getBackgroundColor()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">r</td><td class = "ra_type">number</td><td>빨간색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">g</td><td class = "ra_type">number</td><td>녹색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">b</td><td class = "ra_type">number</td><td>파란색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">a</td><td class = "ra_type">number</td><td>알파 성분 (0-255).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getBlendMode" name = "love.graphics.getBlendMode"><span>love.graphics.</span><wbr>getBlendMode</a></p><p class = "function_description">혼합 모드를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mode</span>, <span class = "returns">alphamode</span> = love.graphics.<wbr>getBlendMode()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mode</td><td class = "ra_type"><a href="#BlendMode">BlendMode</a></td><td>현재 혼합 모드입니다.</td></tr><tr><td class = "returns ra_name">alphamode</td><td class = "ra_type"><a href="#BlendAlphaMode">BlendAlphaMode</a></td><td>현재 블렌드 알파 모드는 그려진 오브젝트의 알파가 블렌딩에 미치는 영향을 결정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getCanvas" name = "love.graphics.getCanvas"><span>love.graphics.</span><wbr>getCanvas</a></p><p class = "function_description">현재 대상 Canvas를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">canvas</span> = love.graphics.<wbr>getCanvas()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">canvas</td><td class = "ra_type"><a href="#Canvas">Canvas</a></td><td>setCanvas로 설정된 Canvas입니다. 실제 화면으로 그리는 경우 nil을 반환합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getCanvasFormats" name = "love.graphics.getCanvasFormats"><span>love.graphics.</span><wbr>getCanvasFormats</a></p><p class = "function_description">사용 가능한 Canvas 형식과 각 형식이 지원되는지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">formats</span> = love.graphics.<wbr>getCanvasFormats()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">formats</td><td class = "ra_type">table</td><td>CanvasFormats를 키로 포함하는 테이블과 그 형식이 값으로 지원되는지 여부를 나타내는 부울 값. 모든 시스템이 모든 형식을 지원하는 것은 아닙니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getColor" name = "love.graphics.getColor"><span>love.graphics.</span><wbr>getColor</a></p><p class = "function_description">현재의 색을 취득합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">r</span>, <span class = "returns">g</span>, <span class = "returns">b</span>, <span class = "returns">a</span> = love.graphics.<wbr>getColor()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">r</td><td class = "ra_type">number</td><td>빨간색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">g</td><td class = "ra_type">number</td><td>빨간색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">b</td><td class = "ra_type">number</td><td>파란색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">a</td><td class = "ra_type">number</td><td>알파 성분 (0-255).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getColorMask" name = "love.graphics.getColorMask"><span>love.graphics.</span><wbr>getColorMask</a></p><p class = "function_description">그리기 할 때 사용되는 활성 색상 구성 요소를 가져옵니다. 일반적으로 <a href="#love.graphics.setColorMask">love.graphics.setColorMask</a>가 사용되지 않으면 4 개의 구성 요소가 모두 활성화됩니다.<br /><br />색상 마스크는 그려진 객체 색상의 개별 구성 요소가 화면의 색상에 영향을 미치는지 여부를 결정합니다. 그들은 <a href="#love.graphics.clear">love.graphics.clear</a>와 Canvas에 영향을 미칩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">r</span>, <span class = "returns">g</span>, <span class = "returns">b</span>, <span class = "returns">a</span> = love.graphics.<wbr>getColorMask()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">r</td><td class = "ra_type">boolean</td><td>렌더링시 빨강 색 구성 요소가 활성 상태인지 여부입니다.</td></tr><tr><td class = "returns ra_name">g</td><td class = "ra_type">boolean</td><td>렌더링시 녹색 컴포넌트가 활성 상태인지 여부.</td></tr><tr><td class = "returns ra_name">b</td><td class = "ra_type">boolean</td><td>렌더링시 파란색 구성 요소가 활성 상태인지 여부입니다.</td></tr><tr><td class = "returns ra_name">a</td><td class = "ra_type">boolean</td><td>렌더링시 알파 색상 구성 요소가 활성화되어 있는지 여부입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getCompressedImageFormats" name = "love.graphics.getCompressedImageFormats"><span>love.graphics.</span><wbr>getCompressedImageFormats</a></p><p class = "function_description">사용 가능한 압축 이미지 형식과 각 압축 이미지 형식의 지원 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">formats</span> = love.graphics.<wbr>getCompressedImageFormats()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">formats</td><td class = "ra_type">table</td><td>CompressedFormats가 키로서 포함되는 테이블. 형식이 값으로서 서포트 될지 어떨지를 나타내는 boolean입니다. 모든 시스템이 모든 형식을 지원하는 것은 아닙니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getDefaultFilter" name = "love.graphics.getDefaultFilter"><span>love.graphics.</span><wbr>getDefaultFilter</a></p><p class = "function_description">이미지, 캔바스 및 글꼴과 함께 사용되는 기본 배율 필터를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">mag</span>, <span class = "returns">anisotropy</span> = love.graphics.<wbr>getDefaultFilter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지 크기를 줄일 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">mag</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지를 확대 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">anisotropy</td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대 양.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getDimensions" name = "love.graphics.getDimensions"><span>love.graphics.</span><wbr>getDimensions</a></p><p class = "function_description">윈도우의 폭과 높이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = love.graphics.<wbr>getDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>창 너비입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>창 높이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getFont" name = "love.graphics.getFont"><span>love.graphics.</span><wbr>getFont</a></p><p class = "function_description">현재의 Font 객체를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">font</span> = love.graphics.<wbr>getFont()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>현재의 Font. 설정되어 있지 않은 경우는 nil</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getHeight" name = "love.graphics.getHeight"><span>love.graphics.</span><wbr>getHeight</a></p><p class = "function_description">윈도우 높이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = love.graphics.<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>창 높이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getLineJoin" name = "love.graphics.getLineJoin"><span>love.graphics.</span><wbr>getLineJoin</a></p><p class = "function_description">라인 결합 스타일을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">join</span> = love.graphics.<wbr>getLineJoin()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">join</td><td class = "ra_type"><a href="#LineJoin">LineJoin</a></td><td>LineJoin 스타일입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getLineStyle" name = "love.graphics.getLineStyle"><span>love.graphics.</span><wbr>getLineStyle</a></p><p class = "function_description">선 스타일을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">style</span> = love.graphics.<wbr>getLineStyle()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">style</td><td class = "ra_type"><a href="#LineStyle">LineStyle</a></td><td>현재 선 스타일.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getLineWidth" name = "love.graphics.getLineWidth"><span>love.graphics.</span><wbr>getLineWidth</a></p><p class = "function_description">현재의 선폭을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = love.graphics.<wbr>getLineWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>현재의 선폭입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getShader" name = "love.graphics.getShader"><span>love.graphics.</span><wbr>getShader</a></p><p class = "function_description">현재 셰이더를 가져옵니다. 설정되지 않은 경우 nil을 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shader</span> = love.graphics.<wbr>getShader()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shader</td><td class = "ra_type"><a href="#Shader">Shader</a></td><td>현재 셰이더입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getStats" name = "love.graphics.getStats"><span>love.graphics.</span><wbr>getStats</a></p><p class = "function_description">성능 관련 렌더링 통계를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">stats</span> = love.graphics.<wbr>getStats()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">stats</td><td class = "ra_type">table</td><td>다음 필드가있는 표 :</td></tr><tr><td class = "returns ra_name">stats.drawcalls</td><td class = "ra_type">number</td><td>현재 프레임에서 현재까지 수행 된 그리기 호출 수입니다.</td></tr><tr><td class = "returns ra_name">stats.canvasswitches</td><td class = "ra_type">number</td><td>현재 프레임에서 활성 캔버스가 지금까지 전환 된 횟수입니다.</td></tr><tr><td class = "returns ra_name">stats.texturememory</td><td class = "ra_type">number</td><td>로드 된 모든 이미지, 캔버스 및 글꼴에서 사용되는 비디오 메모리의 추정 ​​총 크기 (바이트)입니다.</td></tr><tr><td class = "returns ra_name">stats.images</td><td class = "ra_type">number</td><td>현재로드 된 Image 객체의 수입니다.</td></tr><tr><td class = "returns ra_name">stats.canvases</td><td class = "ra_type">number</td><td>현재로드 된 Canvas 객체의 수입니다.</td></tr><tr><td class = "returns ra_name">stats.fonts</td><td class = "ra_type">number</td><td>현재로드되고있는 Font 객체의 수입니다.</td></tr><tr><td class = "returns ra_name">stats.shaderswitches</td><td class = "ra_type">number</td><td>현재 프레임에서 현재 활성 셰이더가 변경된 횟수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getStencilTest" name = "love.graphics.getStencilTest"><span>love.graphics.</span><wbr>getStencilTest</a></p><p class = "function_description">스텐실 테스트가 사용되는지 여부를 가져옵니다.<br /><br />스텐실 테스트가 활성화되면, 그려지는 모든 것들의 기하학은 이전에 스텐실 버퍼에 그려진 것과 교차하는지 여부에 따라 클리핑 / 스텐실 아웃됩니다.<br /><br />각 Canvas에는 자체 스텐실 버퍼가 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span>, <span class = "returns">inverted</span> = love.graphics.<wbr>getStencilTest()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>스텐실 테스트 사용 여부.</td></tr><tr><td class = "returns ra_name">inverted</td><td class = "ra_type">boolean</td><td>스텐실 테스트가 반전되었는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getSupported" name = "love.graphics.getSupported"><span>love.graphics.</span><wbr>getSupported</a></p><p class = "function_description">선택적 그래픽 기능과 해당 기능이 시스템에서 지원되는지 여부를 가져옵니다.<br /><br />구형 또는 저가형 시스템 중 일부는 항상 모든 그래픽 기능을 지원하지는 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">features</span> = love.graphics.<wbr>getSupported()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">features</td><td class = "ra_type">table</td><td>GraphicsFeature 키가 들어있는 테이블과 각 기능이 지원되는지 여부를 나타내는 부울 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getSystemLimits" name = "love.graphics.getSystemLimits"><span>love.graphics.</span><wbr>getSystemLimits</a></p><p class = "function_description">love.graphics 기능의 시스템 종속 최대 값을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">limits</span> = love.graphics.<wbr>getSystemLimits()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">limits</td><td class = "ra_type">table</td><td>GraphicsLimit 키와 숫자 값을 포함하는 테이블.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getPointSize" name = "love.graphics.getPointSize"><span>love.graphics.</span><wbr>getPointSize</a></p><p class = "function_description">포인트 크기를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">size</span> = love.graphics.<wbr>getPointSize()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>현재 포인트 크기입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getRendererInfo" name = "love.graphics.getRendererInfo"><span>love.graphics.</span><wbr>getRendererInfo</a></p><p class = "function_description">시스템의 비디오 카드 및 드라이버에 대한 정보를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">name</span>, <span class = "returns">version</span>, <span class = "returns">vendor</span>, <span class = "returns">device</span> = love.graphics.<wbr>getRendererInfo()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">name</td><td class = "ra_type">string</td><td>렌더러의 이름입니다 (예 : "OpenGL"또는 "OpenGL ES".</td></tr><tr><td class = "returns ra_name">version</td><td class = "ra_type">string</td><td>일부 추가 드라이버 종속 버전 정보가있는 렌더러 버전입니다 (예 : "2.1 INTEL-8.10.44".</td></tr><tr><td class = "returns ra_name">vendor</td><td class = "ra_type">string</td><td>그래픽 카드 공급 업체의 이름 (예 : "Intel Inc".</td></tr><tr><td class = "returns ra_name">device</td><td class = "ra_type">string</td><td>그래픽 카드의 이름입니다 (예 : "인텔 HD 그래픽 3000 OpenGL 엔진".</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getScissor" name = "love.graphics.getScissor"><span>love.graphics.</span><wbr>getScissor</a></p><p class = "function_description">현재 가위 상자를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">width</span>, <span class = "returns">height</span> = love.graphics.<wbr>getScissor()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>상자의 왼쪽 상단의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>상자의 상단 왼쪽 포인트의 y 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>상자 너비</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>상자의 높이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.getWidth" name = "love.graphics.getWidth"><span>love.graphics.</span><wbr>getWidth</a></p><p class = "function_description">윈도우의 폭을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = love.graphics.<wbr>getWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>창 너비입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.intersectScissor" name = "love.graphics.intersectScissor"><span>love.graphics.</span><wbr>intersectScissor</a></p><p class = "function_description">가위를 지정된 사각형과 기존 가위의 교차에 의해 생성 된 사각형으로 설정합니다. 아직 활성화 된 가위가 없으면 <a href="#love.graphics.setScissor">love.graphics.setScissor</a>처럼 작동합니다.<br /><br />가위는 그림 영역을 지정된 사각형으로 제한합니다. 이것은 <a href="#love.graphics.clear">love.graphics.clear</a>를 포함한 모든 그래픽 호출에 영향을줍니다.<br /><br />가위의 크기는 그래픽 변환 (번역, 크기 조절, ...)에 영향을받지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>intersectScissor( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">width</span>, <span class = "arguments">height</span> )</span></span></p><p class = "variant_description">Limits the drawing area to a specified rectangle.</p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>기존의 가위 사각형과 교차하는 사각형의 왼쪽 위 모서리의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>기존의 가위 사각형과 교차하는 사각형의 왼쪽 위 모서리의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>기존의 가위 사각형과 교차하는 사각형의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>기존의 가위 사각형과 교차하는 사각형의 높이입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>intersectScissor()</span></span></p><p class = "variant_description">Disables scissor.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.isGammaCorrect" name = "love.graphics.isGammaCorrect"><span>love.graphics.</span><wbr>isGammaCorrect</a></p><p class = "function_description">감마 보정이 지원되는지 여부를 가져옵니다. 그것은 love.conf에서 t.gammacorrect = true를 설정하여 활성화 할 수 있습니다.<br /><br />모든 장치가 감마 보정을 지원하는 것은 아닙니다.이 경우 자동으로 비활성화되며이 함수는 false를 반환합니다. OpenGL 3 / DirectX 10을 사용할 수있는 그래픽 카드와 OpenGL ES 3을 사용할 수있는 iOS 장치가있는 데스크탑 시스템에서 지원됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">gammacorrect</span> = love.graphics.<wbr>isGammaCorrect()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">gammacorrect</td><td class = "ra_type">boolean</td><td>감마 보정 렌더링이 지원되고 love.conf에서 활성화 된 경우 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.isWireframe" name = "love.graphics.isWireframe"><span>love.graphics.</span><wbr>isWireframe</a></p><p class = "function_description">그리기 할 때 와이어 프레임 모드를 사용하는지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">wireframe</span> = love.graphics.<wbr>isWireframe()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">wireframe</td><td class = "ra_type">boolean</td><td>묘화시에 와이어 프레임 선이 사용되면 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.line" name = "love.graphics.line"><span>love.graphics.</span><wbr>line</a></p><p class = "function_description">점 사이에 선을 그립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>line( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>x 축상의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>y 축의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>x 축상의 두 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>y 축상의 두 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>점 위치를 계속 통과하여 폴리선을 그릴 수 있습니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>line( <span class = "arguments">points</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">points</td><td class = "ra_type">table</td><td>포인트 포지션 테이블.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newCanvas" name = "love.graphics.newCanvas"><span>love.graphics.</span><wbr>newCanvas</a></p><p class = "function_description">오프 스크린 렌더링을위한 새로운 Canvas 객체를 만듭니다.<br /><br />안티 앨리어싱을 적용한 캔버스는 일반적인 캔버스보다 시스템 요구 사항이 약간 높습니다. 또한 지원되는 MSAA 샘플의 최대 수는 시스템에 따라 다릅니다. 확인하려면 love.graphics.getSystemLimit을 사용하십시오.<br /><br />지정된 MSAA 샘플 수가 시스템에서 지원하는 최대 값보다 큰 경우 Canvas는 계속 지원되지만 최대 지원 금액 (이 값에는 0 포함) 만 사용됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">canvas</span> = love.graphics.<wbr>newCanvas( <span class = "arguments">width</span>, <span class = "arguments">height</span>, <span class = "arguments">format</span>, <span class = "arguments">msaa</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">canvas</td><td class = "ra_type"><a href="#Canvas">Canvas</a></td><td>새 Canvas 객체입니다.</td></tr><tr><td class = "arguments ra_name">width <span class = "default">(window width)</span></td><td class = "ra_type">number</td><td>Canvas의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height <span class = "default">(window height)</span></td><td class = "ra_type">number</td><td>Canvas의 높이입니다.</td></tr><tr><td class = "arguments ra_name">format <span class = "default">("normal")</span></td><td class = "ra_type"><a href="#CanvasFormat">CanvasFormat</a></td><td>Canvas의 원하는 텍스처 모드.</td></tr><tr><td class = "arguments ra_name">msaa <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>캔버스에 그리는 데 사용되는 앤티 엘리 어싱 샘플의 원하는 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newFont" name = "love.graphics.newFont"><span>love.graphics.</span><wbr>newFont</a></p><p class = "function_description">트루 타입 글꼴 또는 BMFont 파일에서 새 글꼴을 만듭니다. 작성된 폰트는 캐쉬되지 않습니다. 같은 인수를 가지는이 함수를 호출하면 (자) 항상 새로운 Font 오브젝트가 작성됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">font</span> = love.graphics.<wbr>newFont( <span class = "arguments">file</span>, <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>화면에 텍스트를 그리는 데 사용할 수있는 Font 객체입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>트루 타입 글꼴 파일의 / File / FileData 파일</td></tr><tr><td class = "arguments ra_name">size <span class = "default">(12)</span></td><td class = "ra_type">number</td><td>글꼴 크기 (픽셀)입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">font</span> = love.graphics.<wbr>newFont( <span class = "arguments">file</span>, <span class = "arguments">imagefilename</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>화면에 텍스트를 그리는 데 사용할 수있는 Font 객체입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>BMFont 파일의 / File / FileData 경로입니다.</td></tr><tr><td class = "arguments ra_name">imagefilename <span class = "default">(path inside BMFont file)</span></td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>BMFont의 이미지 파일 경로 / File / FileData.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">font</span> = love.graphics.<wbr>newFont( <span class = "arguments">size</span> )</span></span></p><p class = "variant_description">사용자 정의 크기와 기본 글꼴 (베라 산세)의 새로운 인스턴스를 생성 .</p><table class = "ra_table"><tr><td class = "returns ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>화면에 텍스트를 그리는 데 사용할 수있는 Font 객체입니다.</td></tr><tr><td class = "arguments ra_name">size</td><td class = "ra_type">number</td><td>글꼴 크기 (픽셀)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newMesh" name = "love.graphics.newMesh"><span>love.graphics.</span><wbr>newMesh</a></p><p class = "function_description">새 메쉬를 만듭니다.<br /><br />메쉬 사용 : 메쉬가 그릴 때 이미지 또는 캔버스로 텍스처 처리되어야한다면 setTexture를 사용하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mesh</span> = love.graphics.<wbr>newMesh( <span class = "arguments">vertexformat</span>, <span class = "arguments">vertices</span>, <span class = "arguments">mode</span>, <span class = "arguments">usage</span> )</span></span></p><p class = "variant_description">Creates a <a href="#Mesh">Mesh</a> with custom vertex attributes and the specified vertex data.</p><table class = "ra_table"><tr><td class = "returns ra_name">mesh</td><td class = "ra_type"><a href="#Mesh">Mesh</a></td><td>새로운 메쉬.</td></tr><tr><td class = "arguments ra_name">vertexformat <span class = "default">(none)</span></td><td class = "ra_type">table</td><td>{attribute, ...} 형식의 테이블. 각 속성은 각 정점에 사용되는 사용자 정의 정점 속성을 지정하는 테이블입니다.</td></tr><tr><td class = "arguments ra_name">vertexformat.attribute</td><td class = "ra_type">table</td><td>속성의 이름, 데이터 유형 및 속성의 구성 요소 수를 {name, datatype, components} 형식으로 포함하는 테이블입니다.</td></tr><tr><td class = "arguments ra_name">vertexformat....</td><td class = "ra_type">table</td><td>추가적인 정점 속성 형식 테이블.</td></tr><tr><td class = "arguments ra_name">vertices</td><td class = "ra_type">table</td><td>테이블은 {vertex, ...}의 형태로 각 꼭지점에 대한 꼭지점 정보 테이블로 채워져 있습니다. 각 꼭지점은 {attributecomponent, ...} 형태의 테이블입니다.</td></tr><tr><td class = "arguments ra_name">vertices.attributecomponent</td><td class = "ra_type">number</td><td>정점의 최초의 정점 속성의 최초의 컴퍼넌트입니다.</td></tr><tr><td class = "arguments ra_name">vertices....</td><td class = "ra_type">number</td><td>정점의 모든 정점 속성의 추가 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">mode <span class = "default">("fan")</span></td><td class = "ra_type"><a href="#MeshDrawMode">MeshDrawMode</a></td><td>묘화시에 정점이 사용되는 방법. 기본 모드 "팬"은 단순 볼록 다각형에 충분합니다.</td></tr><tr><td class = "arguments ra_name">usage <span class = "default">("dynamic")</span></td><td class = "ra_type"><a href="#SpriteBatchUsage">SpriteBatchUsage</a></td><td>메쉬의 예상 사용법. 지정된 사용 모드는 메쉬의 메모리 사용 및 성능에 영향을줍니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mesh</span> = love.graphics.<wbr>newMesh( <span class = "arguments">vertexformat</span>, <span class = "arguments">vertexcount</span>, <span class = "arguments">mode</span>, <span class = "arguments">usage</span> )</span></span></p><p class = "variant_description">Creates a <a href="#Mesh">Mesh</a> with custom vertex attributes and the specified number of vertices.</p><table class = "ra_table"><tr><td class = "returns ra_name">mesh</td><td class = "ra_type"><a href="#Mesh">Mesh</a></td><td>새로운 메쉬.</td></tr><tr><td class = "arguments ra_name">vertexformat <span class = "default">(none)</span></td><td class = "ra_type">table</td><td>{attribute, ...} 형식의 테이블. 각 속성은 각 정점에 사용되는 사용자 정의 정점 속성을 지정하는 테이블입니다.</td></tr><tr><td class = "arguments ra_name">vertexformat.attribute</td><td class = "ra_type">table</td><td>속성의 이름, 데이터 유형 및 속성의 구성 요소 수를 {name, datatype, components} 형식으로 포함하는 테이블입니다.</td></tr><tr><td class = "arguments ra_name">vertexformat....</td><td class = "ra_type">table</td><td>추가적인 정점 속성 형식 테이블.</td></tr><tr><td class = "arguments ra_name">vertexcount</td><td class = "ra_type">number</td><td>메쉬가 사용할 정점의 총 수입니다.</td></tr><tr><td class = "arguments ra_name">mode <span class = "default">("fan")</span></td><td class = "ra_type"><a href="#MeshDrawMode">MeshDrawMode</a></td><td>묘화시에 정점이 사용되는 방법. 기본 모드 "팬"은 단순 볼록 다각형에 충분합니다.</td></tr><tr><td class = "arguments ra_name">usage <span class = "default">("dynamic")</span></td><td class = "ra_type"><a href="#SpriteBatchUsage">SpriteBatchUsage</a></td><td>메쉬의 예상 사용법. 지정된 사용 모드는 메쉬의 메모리 사용 및 성능에 영향을줍니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newImage" name = "love.graphics.newImage"><span>love.graphics.</span><wbr>newImage</a></p><p class = "function_description">파일 패스, <a href="#FileData">FileData</a>, <a href="#ImageData">ImageData</a>, 또는 <a href="#CompressedImageData">CompressedImageData</a>로부터 새로운 <a href="#Image">Image</a>를 작성해, 옵션으로 이미지의 밉맵을 생성 또는 지정합니다.<br /><br /><a href="#CompressedImageData">CompressedImageData</a>를 사용하는 이미지는 <a href="#love.window.setMode">love.window.setMode</a>가 호출 될 때 이미지를 다시로드하는 데 사용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">image</span> = love.graphics.<wbr>newImage( <span class = "arguments">file</span>, <span class = "arguments">flags</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">image</td><td class = "ra_type"><a href="#Image">Image</a></td><td>화면 상에 드로잉 (Drawing) 할 수있는 Image 오브젝트입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">path / <a href="#File">File</a> / <a href="#FileData">FileData</a> / <a href="#ImageData">ImageData</a> / <a href="#CompressedImageData">CompressedImageData</a></td><td>이미지의 파일 경로 / File / FileData / ImageData / CompressedImageData.</td></tr><tr><td class = "arguments ra_name">flags</td><td class = "ra_type">table</td><td>다음 필드가 포함 된 테이블 :</td></tr><tr><td class = "arguments ra_name">flags.linear <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>감마 보정이 유효한 경우 이미지의 픽셀을 sRGB로 인코딩하지 않고 선형 RGB로 해석해야하는 경우 true입니다. 그렇지 않으면 효과가 없습니다.</td></tr><tr><td class = "arguments ra_name">flags.mipmaps <span class = "default">(false)</span></td><td class = "ra_type">boolean or table</td><td>true의 경우, 이미지의 밉맵이 자동적으로 생성됩니다 (또는 가능하면 이미지가 CompressedImageData의 이미지 인 경우 이미지의 파일에서 가져옵니다). 이 값이 테이블 인 경우 점진적으로 절반 크기 인 동일한 형식의 이미지의 다른 파일 이름 목록을 포함해야하며 1x1까지 줄이십시오. 이러한 이미지는이 이미지의 밉맵 수준으로 사용됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newImageFont" name = "love.graphics.newImageFont"><span>love.graphics.</span><wbr>newImageFont</a></p><p class = "function_description">포맷 된 이미지를로드 해 새로운 Font를 작성합니다.<br /><br />0.9.0 이전 버전에서 L? VE는 글리프 문자열에 대해 ISO 8859-1 인코딩을 기대합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">font</span> = love.graphics.<wbr>newImageFont( <span class = "arguments">file</span>, <span class = "arguments">glyphs</span>, <span class = "arguments">extraspacing</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>화면에 텍스트를 그리는 데 사용할 수있는 Font 객체입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">path / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>이미지 파일의 파일 경로 / File / FileData.</td></tr><tr><td class = "arguments ra_name">glyphs</td><td class = "ra_type">string</td><td>왼쪽에서 오른쪽 순으로 이미지의 문자 스트링.</td></tr><tr><td class = "arguments ra_name">extraspacing <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>글꼴의 각 문자에 적용 할 추가 간격 (양수 또는 음수).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newParticleSystem" name = "love.graphics.newParticleSystem"><span>love.graphics.</span><wbr>newParticleSystem</a></p><p class = "function_description">새 ParticleSystem을 만듭니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">system</span> = love.graphics.<wbr>newParticleSystem( <span class = "arguments">texture</span>, <span class = "arguments">buffer</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">system</td><td class = "ra_type"><a href="#ParticleSystem">ParticleSystem</a></td><td>새로운 ParticleSystem.</td></tr><tr><td class = "arguments ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>사용할 이미지 또는 캔버스.</td></tr><tr><td class = "arguments ra_name">buffer <span class = "default">(1000)</span></td><td class = "ra_type">number</td><td>동시에 최대 입자 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newShader" name = "love.graphics.newShader"><span>love.graphics.</span><wbr>newShader</a></p><p class = "function_description">하드웨어 가속화 된 버텍스 및 픽셀 효과를위한 새로운 Shader 객체를 만듭니다. 셰이더는 정점 셰이더 코드, 픽셀 셰이더 코드 또는 둘 모두를 포함합니다.<br /><br />버텍스 쉐이더 코드는 스크린 공간에서 그려진 객체의 변형 된 버텍스 위치를 생성하는 함수 인 position이라는 하나 이상의 함수를 포함해야합니다.<br /><br />픽셀 쉐이더 코드는 그려진 객체가 닿는 각 픽셀에 대해 화면에 블렌딩되는 색상을 생성하는 함수 인 effect라는 하나 이상의 함수를 포함해야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shader</span> = love.graphics.<wbr>newShader( <span class = "arguments">code</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shader</td><td class = "ra_type"><a href="#Shader">Shader</a></td><td>그리기 작업에 사용되는 Shader 객체입니다.</td></tr><tr><td class = "arguments ra_name">code</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>픽셀 쉐이더 또는 버텍스 쉐이더 코드 또는 코드가있는 파일.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shader</span> = love.graphics.<wbr>newShader( <span class = "arguments">pixelcode</span>, <span class = "arguments">vertexcode</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shader</td><td class = "ra_type"><a href="#Shader">Shader</a></td><td>그리기 작업에 사용되는 Shader 객체입니다.</td></tr><tr><td class = "arguments ra_name">pixelcode</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>픽셀 쉐이더 코드 또는 코드가있는 파일.</td></tr><tr><td class = "arguments ra_name">vertexcode</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>버텍스 쉐이더 코드 또는 코드가있는 파일.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newText" name = "love.graphics.newText"><span>love.graphics.</span><wbr>newText</a></p><p class = "function_description">새로운 Font를 작성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">text</span> = love.graphics.<wbr>newText( <span class = "arguments">font</span>, <span class = "arguments">textstring</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">text</td><td class = "ra_type"><a href="#Text">Text</a></td><td>새로운 drawable <a href="#Text">Text</a> 객체입니다.</td></tr><tr><td class = "arguments ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>텍스트에 사용할 글꼴입니다.</td></tr><tr><td class = "arguments ra_name">textstring <span class = "default">(nil)</span></td><td class = "ra_type">string</td><td>새 Text 객체에 포함될 초기 텍스트 문자열입니다. 5 월이 될 수 있습니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newQuad" name = "love.graphics.newQuad"><span>love.graphics.</span><wbr>newQuad</a></p><p class = "function_description">새 쿼드를 만듭니다.<br /><br />쿼드의 목적은 드로어 블 오브젝트에서 다음 변환의 결과를 설명하는 것입니다. 객체는 먼저 크기가 sw * sh로 조정됩니다. Quad는 크기가 width * height 인 직사각형 영역을 설명합니다.이 영역의 왼쪽 위 모서리는 크기가 조절 된 객체 내부의 위치 (x, y)에 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">quad</span> = love.graphics.<wbr>newQuad( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">width</span>, <span class = "arguments">height</span>, <span class = "arguments">sw</span>, <span class = "arguments">sh</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">quad</td><td class = "ra_type"><a href="#Quad">Quad</a></td><td>새로운 쿼드.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 기준으로 한 좌상단 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 기준으로 한 좌상단 위치입니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>쿼드 너비.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>쿼드의 높이.</td></tr><tr><td class = "arguments ra_name">sw</td><td class = "ra_type">number</td><td>참조 폭, <a href="#Image">Image</a>의 폭.</td></tr><tr><td class = "arguments ra_name">sh</td><td class = "ra_type">number</td><td>참조 높이, 이미지 높이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newScreenshot" name = "love.graphics.newScreenshot"><span>love.graphics.</span><wbr>newScreenshot</a></p><p class = "function_description">스크린 샷을 만들고 이미지 데이터를 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">screenshot</span> = love.graphics.<wbr>newScreenshot( <span class = "arguments">copyAlpha</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">screenshot</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>스크린 샷의 이미지 데이터입니다.</td></tr><tr><td class = "arguments ra_name">copyAlpha <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>화면의 알파 채널을 ImageData에 포함할지 여부. false이면 스크린 샷이 완전히 불투명 해집니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newSpriteBatch" name = "love.graphics.newSpriteBatch"><span>love.graphics.</span><wbr>newSpriteBatch</a></p><p class = "function_description">새 SpriteBatch 객체를 만듭니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">spriteBatch</span> = love.graphics.<wbr>newSpriteBatch( <span class = "arguments">texture</span>, <span class = "arguments">maxsprites</span>, <span class = "arguments">usage</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">spriteBatch</td><td class = "ra_type"><a href="#SpriteBatch">SpriteBatch</a></td><td>새로운 SpriteBatch입니다.</td></tr><tr><td class = "arguments ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>스프라이트에 사용할 이미지 또는 캔버스입니다.</td></tr><tr><td class = "arguments ra_name">maxsprites <span class = "default">(1000)</span></td><td class = "ra_type">number</td><td>최대 스프라이트 수.</td></tr><tr><td class = "arguments ra_name">usage <span class = "default">("dynamic")</span></td><td class = "ra_type"><a href="#SpriteBatchUsage">SpriteBatchUsage</a></td><td>SpriteBatch의 예상 사용법. 지정된 사용 모드는 SpriteBatch의 메모리 사용 및 성능에 영향을줍니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.newVideo" name = "love.graphics.newVideo"><span>love.graphics.</span><wbr>newVideo</a></p><p class = "function_description">새로운 드로어 블 비디오를 만듭니다. 현재는 Ogg Theora 비디오 파일 만 지원됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">video</span> = love.graphics.<wbr>newVideo( <span class = "arguments">file</span>, <span class = "arguments">loadaudio</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">video</td><td class = "ra_type"><a href="#Video">Video</a></td><td>새로운 비디오.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a></td><td>Ogg Theora 비디오 파일의 파일 경로 / 파일.</td></tr><tr><td class = "arguments ra_name">loadaudio <span class = "default">(nil)</span></td><td class = "ra_type">boolean</td><td>비디오의 오디오를 오디오 소스에로드할지 여부. 명시 적으로 true 또는 false로 설정하지 않으면 비디오에 오디오가없는 경우 오류를 일으키지 않고 시도합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.origin" name = "love.graphics.origin"><span>love.graphics.</span><wbr>origin</a></p><p class = "function_description">현재 좌표 변환을 다시 설정합니다.<br /><br />이 함수는 항상 <a href="#love.graphics.rotate">love.graphics.rotate</a>, <a href="#love.graphics.scale">love.graphics.scale</a>, <a href="#love.graphics.shear">love.graphics.shear</a> 또는 <a href="#love.graphics.translate">love.graphics.translate</a>에 대한 이전 호출을 취소하는 데 사용됩니다. 현재 변환 상태를 기본값으로 되돌립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>origin()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.points" name = "love.graphics.points"><span>love.graphics.</span><wbr>points</a></p><p class = "function_description">하나 이상의 점을 그립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>points( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축상의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 점의 x 및 y 좌표입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>points( <span class = "arguments">points</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">points</td><td class = "ra_type">table</td><td>{x, y, ...} 형식으로 여러 개의 점 위치가 포함 된 표.</td></tr><tr><td class = "arguments ra_name">points.x</td><td class = "ra_type">number</td><td>x 축상의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">points.y</td><td class = "ra_type">number</td><td>y 축의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">points....</td><td class = "ra_type">number</td><td>추가 점의 x 및 y 좌표입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>points( <span class = "arguments">points</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">points</td><td class = "ra_type">table</td><td>{point, ...} 형태로 개별적으로 색상이 지정된 여러 점이 포함 된 표입니다. 각 표에는 점의 위치와 색상이 {x, y, r, g, b, a} 형식으로 포함됩니다. 색상 구성 요소는 선택 사항입니다.</td></tr><tr><td class = "arguments ra_name">points.point</td><td class = "ra_type">table</td><td>{x, y, r, g, b, a} 형태로 첫 번째 점의 위치와 색상을 포함하는 표. 색상 구성 요소는 선택 사항입니다.</td></tr><tr><td class = "arguments ra_name">points....</td><td class = "ra_type">table</td><td>{x, y, r, g, b, a} 형태로 더 많은 점의 위치와 색상을 포함하는 추가 표. 색상 구성 요소는 선택 사항입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.polygon" name = "love.graphics.polygon"><span>love.graphics.</span><wbr>polygon</a></p><p class = "function_description">다각형을 그립니다.<br /><br />mode 인수 다음에이 함수는 여러 개의 숫자 인수 또는 숫자 인수의 단일 테이블을 사용할 수 있습니다. 두 경우 모두 인수는 다각형의 정점의 x 좌표와 y 좌표로 교대로 해석됩니다.<br /><br />채우기 모드에서 다각형은 볼록하고 단순해야하며 렌더링 아티팩트가 발생할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>polygon( <span class = "arguments">mode</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#DrawMode">DrawMode</a></td><td>다각형 그리는 법.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>다각형의 꼭지점.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>polygon( <span class = "arguments">mode</span>, <span class = "arguments">vertices</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#DrawMode">DrawMode</a></td><td>다각형 그리는 법.</td></tr><tr><td class = "arguments ra_name">vertices</td><td class = "ra_type">table</td><td>다각형의 꼭지점을 표로 사용합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.pop" name = "love.graphics.pop"><span>love.graphics.</span><wbr>pop</a></p><p class = "function_description">변환 스택에서 현재 좌표 변환을 팝합니다.<br /><br />이 함수는 항상 이전 푸시 조작을 되돌리기 위해 사용됩니다. 현재 변환 상태를 마지막 선행 푸시 이전의 상태로 되돌립니다. 예를 들어, <a href="#love.graphics.push">love.graphics.push</a>에 대한 설명을 참조하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>pop()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.present" name = "love.graphics.present"><span>love.graphics.</span><wbr>present</a></p><p class = "function_description">화면에 그리기 작업의 결과를 표시합니다.<br /><br />이 함수는 자신의 love.run 함수를 작성할 때 사용됩니다. 그리기 작업의 모든 결과를 화면에 표시합니다. 이 함수의 일반적인 사용법은 love.run의 예제를 참조하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>present()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.print" name = "love.graphics.print"><span>love.graphics.</span><wbr>print</a></p><p class = "function_description">화면에 텍스트를 그립니다. Font가 설정되어 있지 않은 경우, 필요에 따라서 1 개 (살) 작성되어 설정됩니다.<br /><br />LOVE 0.7.1에서 텍스트를 그리는 동안 변환 및 배율 함수를 사용할 때이 함수는 배율이 먼저 발생한다고 가정합니다. 이를 염두에두고 스크립트를 작성하지 않으면 텍스트가 올바른 위치에 없거나 화면에 표시되지 않습니다.<br /><br />love.graphics.print와 <a href="#love.graphics.printf">love.graphics.printf</a>는 모두 UTF-8 인코딩을 지원합니다. 또한 특수 문자에 적합한 글꼴이 필요합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>print( <span class = "arguments">text</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">text</td><td class = "ra_type">string</td><td>그릴 텍스트입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>물체를 그리는 위치 (x 축)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>오브젝트를 그리는 위치입니다 (y 축).</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축).</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축).</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축).</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축).</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>print( <span class = "arguments">coloredtext</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">angle</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">coloredtext</td><td class = "ra_type">table</td><td>{color1, string1, color2, string2, ...} 형식으로 개체에 추가 할 색과 문자열을 포함하는 테이블입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color1</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string1</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color2</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string2</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext....</td><td class = "ra_type">tables and strings</td><td>추가 색상 및 문자열.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>새로운 텍스트의 x 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>새로운 텍스트의 y 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">angle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>라디안 단위의 객체 방향입니다.</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>x 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>y 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>y 축의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 전단 / 비뚤어 짐 계수입니다.</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>Y 축상의 전단 / 비뚤어 짐 계수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.printf" name = "love.graphics.printf"><span>love.graphics.</span><wbr>printf</a></p><p class = "function_description">단어 줄 바꿈 및 맞춤을 사용하여 서식이 지정된 텍스트를 그립니다.<br /><br /><a href="#love.graphics.print">love.graphics.print</a>의 추가 참고 사항을 참조하십시오.<br /><br />0.9.2 및 0.9.2 이전 버전에서는 공백으로 단어를 분리하고 다시 묶어서 제공된 내용 내에서 적절하게 맞출 수 있도록 포장을 구현했습니다. 그러나 이것이 수행되는 방식으로 인해 단어 사이에 여분의 공백이 화면에 인쇄 될 때 누락되어 일부 줄이 제공된 줄 바꿈 한계를 초과하여 넘칠 수 있습니다. 버전 0.10.0 이상에서는 더 이상 그렇지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>printf( <span class = "arguments">text</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">limit</span>, <span class = "arguments">align</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">text</td><td class = "ra_type">string</td><td>텍스트 문자열.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축상의 위치.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축의 위치입니다.</td></tr><tr><td class = "arguments ra_name">limit</td><td class = "ra_type">number</td><td>이 많은 수평 픽셀 다음에 줄을 감싸십시오.</td></tr><tr><td class = "arguments ra_name">align <span class = "default">("left")</span></td><td class = "ra_type"><a href="#AlignMode">AlignMode</a></td><td>정렬.</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축).</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축).</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축).</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축).</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>printf( <span class = "arguments">coloredtext</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">wraplimit</span>, <span class = "arguments">align</span>, <span class = "arguments">angle</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">coloredtext</td><td class = "ra_type">table</td><td>{color1, string1, color2, string2, ...} 형식으로 개체에 추가 할 색과 문자열을 포함하는 테이블입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color1</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string1</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color2</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string2</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext....</td><td class = "ra_type">tables and strings</td><td>추가 색상 및 문자열.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>새로운 텍스트의 x 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>새로운 텍스트의 y 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">wraplimit</td><td class = "ra_type">number</td><td>텍스트가 자동으로 새 줄로 감싸기 전에 텍스트의 최대 너비 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">align</td><td class = "ra_type"><a href="#AlignMode">AlignMode</a></td><td>텍스트의 정렬입니다.</td></tr><tr><td class = "arguments ra_name">angle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>라디안 단위의 객체 방향입니다.</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>x 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>y 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>y 축의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 전단 / 비뚤어 짐 계수입니다.</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>Y 축상의 전단 / 비뚤어 짐 계수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.push" name = "love.graphics.push"><span>love.graphics.</span><wbr>push</a></p><p class = "function_description">현재 좌표 변환을 복사하여 변환 스택에 푸시합니다.<br /><br />이 기능은 나중에 해당 팝 조작을 준비하는 데 항상 사용됩니다. 현재 좌표 변환 상태를 변환 스택에 저장하고 활성화 상태로 유지합니다. 나중에 변환을 변경하면 pop 연산을 사용하여 취소 할 수 있습니다.이 연산은 좌표 변환을 push를 호출하기 전의 상태로 되돌립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>push( <span class = "arguments">stack</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">stack <span class = "default">("transform")</span></td><td class = "ra_type"><a href="#StackType">StackType</a></td><td>푸시 할 스택의 유형입니다 (예 : 변형 상태 또는 모든 love.graphics 상태).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.rectangle" name = "love.graphics.rectangle"><span>love.graphics.</span><wbr>rectangle</a></p><p class = "function_description">직사각형을 그립니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>rectangle( <span class = "arguments">mode</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">width</span>, <span class = "arguments">height</span>, <span class = "arguments">rx</span>, <span class = "arguments">ry</span>, <span class = "arguments">segments</span> )</span></span></p><p class = "variant_description">모서리가 둥근 직사각형을 그린다.</p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#DrawMode">DrawMode</a></td><td>사각형 그리는 법.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따라 왼쪽 상단 모서리의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따라 왼쪽 상단 모서리의 위치입니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>사각형의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>사각형의 높이.</td></tr><tr><td class = "arguments ra_name">rx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>각 둥근 모서리의 x 축 반경입니다. 사각형의 너비의 절반보다 클 수 없습니다.</td></tr><tr><td class = "arguments ra_name">ry <span class = "default">(rx)</span></td><td class = "ra_type">number</td><td>각 둥근 모서리의 y 축 반지름입니다. 사각형의 높이의 절반보다 클 수 없습니다.</td></tr><tr><td class = "arguments ra_name">segments <span class = "default">(based on size)</span></td><td class = "ra_type">number</td><td>둥근 모서리를 그리는 데 사용되는 세그먼트 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.reset" name = "love.graphics.reset"><span>love.graphics.</span><wbr>reset</a></p><p class = "function_description">현재 그래픽 설정을 재설정합니다.<br /><br />재설정을 호출하면 현재 드로잉 색이 흰색으로되고 현재 배경색이 검정색으로 표시되고 활성 캔버스 또는 셰이더가 다시 설정되고 모든 가위 설정이 제거됩니다. BlendMode를 alpha로 설정합니다. 또한 점 및 선 그리기 모드를 모두 부드럽게 설정하고 크기를 1.0으로 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>reset()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.rotate" name = "love.graphics.rotate"><span>love.graphics.</span><wbr>rotate</a></p><p class = "function_description">좌표계를 2 차원으로 회전합니다.<br /><br />이 함수를 호출하면 지정된 라디안 양만큼 원점을 중심으로 좌표계를 회전하여 이후의 모든 그리기 작업에 영향을줍니다. 이 변경 사항은 love.draw가 종료 될 때까지 지속됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>rotate( <span class = "arguments">angle</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">angle</td><td class = "ra_type">number</td><td>좌표계를 라디안 단위로 회전하는 크기입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.scale" name = "love.graphics.scale"><span>love.graphics.</span><wbr>scale</a></p><p class = "function_description">좌표계의 크기를 2 차원으로 조정합니다.<br /><br />기본적으로 L-VE의 좌표계는 가로 및 세로 방향의 디스플레이 픽셀에 일대일로 해당하며 x- 축은 오른쪽으로 증가하는 반면 y- 축은 아래쪽으로 증가합니다. 좌표계의 크기를 조정하면이 관계가 변경됩니다.<br /><br />sx와 sy로 스케일링 한 후 모든 좌표는 sx와 sy로 곱한 것처럼 처리됩니다. 그리기 작업의 모든 결과도 그에 따라 크기가 조정되므로 예를 들어 (2, 2)로 배율 조정하면 모든 방향을 x 및 y 방향으로 두 배 크게 만들 수 있습니다. 음수 값으로 배율을 조정하면 좌표계가 해당 방향으로 반전되며, 이는 모든 것이 뒤집혀 지거나 뒤집히거나 그 두 가지 모두로 그려지는 것을 의미합니다. 0으로 스케일링하는 것은 유용한 연산이 아닙니다.<br /><br />규모와 변환은 교환 적 조작이 아니므로 다른 순서로 호출하면 결과가 변경됩니다.<br /><br />확장은 love.draw가 종료 될 때까지 지속됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>scale( <span class = "arguments">sx</span>, <span class = "arguments">sy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">sx</td><td class = "ra_type">number</td><td>x 축 방향의 크기 조절입니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>y 축의 방향으로의 슬캘링입니다. 생략하면 기본값은 매개 변수 sx와 동일합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setBackgroundColor" name = "love.graphics.setBackgroundColor"><span>love.graphics.</span><wbr>setBackgroundColor</a></p><p class = "function_description">배경색을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setBackgroundColor( <span class = "arguments">r</span>, <span class = "arguments">g</span>, <span class = "arguments">b</span>, <span class = "arguments">a</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">r</td><td class = "ra_type">number</td><td>빨간색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">g</td><td class = "ra_type">number</td><td>녹색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">b</td><td class = "ra_type">number</td><td>파란색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">a <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>알파 성분 (0-255).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setBackgroundColor( <span class = "arguments">rgba</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">rgba</td><td class = "ra_type">table</td><td>빨간색, 초록색 및 파란색 값이 숫자 인 색인화 된 숫자 표입니다. 알파가 테이블에 없으면 255입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setBlendMode" name = "love.graphics.setBlendMode"><span>love.graphics.</span><wbr>setBlendMode</a></p><p class = "function_description">혼합 모드를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setBlendMode( <span class = "arguments">mode</span>, <span class = "arguments">alphamode</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#BlendMode">BlendMode</a></td><td>사용할 블렌드 모드입니다.</td></tr><tr><td class = "arguments ra_name">alphamode <span class = "default">("alphamultiply")</span></td><td class = "ra_type"><a href="#BlendAlphaMode">BlendAlphaMode</a></td><td>혼합 할 때 그려지는 객체의 알파를 어떻게 처리해야합니까?</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setCanvas" name = "love.graphics.setCanvas"><span>love.graphics.</span><wbr>setCanvas</a></p><p class = "function_description">캔버스에 드로잉 작업을 캡처합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setCanvas( <span class = "arguments">canvas</span> )</span></span></p><p class = "variant_description">지정된 Canvas로 렌더링 타겟을 설정한다. 다음 <a href="#love.graphics.setCanvas">love.graphics.setCanvas</a> 호출 할 때까지 모든 그리기 작업은 Canvas로 리디렉션하고 화면에 표시되지 않습니다.</p><table class = "ra_table"><tr><td class = "arguments ra_name">canvas</td><td class = "ra_type"><a href="#Canvas">Canvas</a></td><td>렌더링 타겟.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setCanvas()</span></span></p><p class = "variant_description">(가) 화면, 즉 공략을 렌더링 재설정 다시 활성화 화면으로 그리기 .</p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setCanvas( <span class = "arguments">canvas1</span>, <span class = "arguments">canvas2</span>, <span class = "arguments">...</span> )</span></span></p><p class = "variant_description">다중 동시 Canvases에 렌더링 타겟을 설정한다. 다음 <a href="#love.graphics.setCanvas">love.graphics.setCanvas</a> 호출 할 때까지 모든 그리기 작업은 지정된 캔버스로 재 화면에 표시되지 않습니다.</p><table class = "ra_table"><tr><td class = "arguments ra_name">canvas1</td><td class = "ra_type"><a href="#Canvas">Canvas</a></td><td>최초의 렌더링 타겟.</td></tr><tr><td class = "arguments ra_name">canvas2</td><td class = "ra_type"><a href="#Canvas">Canvas</a></td><td>두 번째 렌더링 대상입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type"><a href="#Canvas">Canvas</a></td><td>더 많은 캔버스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setColor" name = "love.graphics.setColor"><span>love.graphics.</span><wbr>setColor</a></p><p class = "function_description">묘화에 사용하는 색을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setColor( <span class = "arguments">red</span>, <span class = "arguments">green</span>, <span class = "arguments">blue</span>, <span class = "arguments">alpha</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">red</td><td class = "ra_type">number</td><td>빨간색의 양.</td></tr><tr><td class = "arguments ra_name">green</td><td class = "ra_type">number</td><td>초록색의 양.</td></tr><tr><td class = "arguments ra_name">blue</td><td class = "ra_type">number</td><td>파란색 양.</td></tr><tr><td class = "arguments ra_name">alpha</td><td class = "ra_type">number</td><td>알파의 양. 알파 값은 이후의 모든 그리기 작업, 심지어 이미지 그리기에도 적용됩니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setColor( <span class = "arguments">rgba</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">rgba</td><td class = "ra_type">table</td><td>빨강, 초록, 파랑 ​​및 알파 값이 숫자 인 숫자로 색인화 된 테이블입니다. 알파는 선택 사항이며, 생략되면 기본값은 255입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setColorMask" name = "love.graphics.setColorMask"><span>love.graphics.</span><wbr>setColorMask</a></p><p class = "function_description">색상 마스크를 설정합니다. 화면을 렌더링하고 지울 때 특정 색상 구성 요소를 활성화하거나 비활성화합니다. 예를 들어 red가 false로 설정된 경우 픽셀의 빨간색 구성 요소는 더 이상 변경되지 않습니다.<br /><br />인수없이 호출하면 모든 색상 구성 요소를 활성화합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setColorMask( <span class = "arguments">red</span>, <span class = "arguments">green</span>, <span class = "arguments">blue</span>, <span class = "arguments">alpha</span> )</span></span></p><p class = "variant_description">지정된 색성분 컬러 마스킹 가능.</p><table class = "ra_table"><tr><td class = "arguments ra_name">red</td><td class = "ra_type">boolean</td><td>빨강 컴포넌트를 렌더링합니다.</td></tr><tr><td class = "arguments ra_name">green</td><td class = "ra_type">boolean</td><td>녹색 구성 요소를 렌더링합니다.</td></tr><tr><td class = "arguments ra_name">blue</td><td class = "ra_type">boolean</td><td>파란색 구성 요소를 렌더링합니다.</td></tr><tr><td class = "arguments ra_name">alpha</td><td class = "ra_type">boolean</td><td>알파 성분을 렌더링합니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setColorMask()</span></span></p><p class = "variant_description">색 마스킹을 사용하지 않습니다.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setDefaultFilter" name = "love.graphics.setDefaultFilter"><span>love.graphics.</span><wbr>setDefaultFilter</a></p><p class = "function_description">이미지, 캔버스 및 글꼴에 사용되는 기본 배율 필터를 설정합니다.<br /><br />이 기능은로드 된 이미지에 소급 적용되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setDefaultFilter( <span class = "arguments">min</span>, <span class = "arguments">mag</span>, <span class = "arguments">anisotropy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지 크기를 줄일 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "arguments ra_name">mag <span class = "default">(min)</span></td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지를 확대 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "arguments ra_name">anisotropy <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대 양.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setFont" name = "love.graphics.setFont"><span>love.graphics.</span><wbr>setFont</a></p><p class = "function_description">이미로드 된 Font를 현재 글꼴로 설정하거나 파일과 크기에서 새 글꼴을 만들고로드하십시오.<br /><br />로딩 단계에서 <a href="#love.graphics.newFont">love.graphics.newFont</a>를 사용하여 Font 객체를 만든 다음 드로잉 단계에서이 함수로 전달하는 것이 좋습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setFont( <span class = "arguments">font</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>사용할 Font 객체입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setLineJoin" name = "love.graphics.setLineJoin"><span>love.graphics.</span><wbr>setLineJoin</a></p><p class = "function_description">라인 결합 스타일을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setLineJoin( <span class = "arguments">join</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">join</td><td class = "ra_type"><a href="#LineJoin">LineJoin</a></td><td>사용할 LineJoin입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setLineStyle" name = "love.graphics.setLineStyle"><span>love.graphics.</span><wbr>setLineStyle</a></p><p class = "function_description">선 스타일을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setLineStyle( <span class = "arguments">style</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">style</td><td class = "ra_type"><a href="#LineStyle">LineStyle</a></td><td>사용할 LineStyle입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setLineWidth" name = "love.graphics.setLineWidth"><span>love.graphics.</span><wbr>setLineWidth</a></p><p class = "function_description">선의 폭을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setLineWidth( <span class = "arguments">width</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>선의 폭입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setNewFont" name = "love.graphics.setNewFont"><span>love.graphics.</span><wbr>setNewFont</a></p><p class = "function_description">새 글꼴을 만들고 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">font</span> = love.graphics.<wbr>setNewFont( <span class = "arguments">filename</span>, <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>새로운 글꼴.</td></tr><tr><td class = "arguments ra_name">filename</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>글꼴의 파일 경로 / File / FileData.</td></tr><tr><td class = "arguments ra_name">size <span class = "default">(12)</span></td><td class = "ra_type">number</td><td>폰트의 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setShader" name = "love.graphics.setShader"><span>love.graphics.</span><wbr>setShader</a></p><p class = "function_description">셰이더를 현재 픽셀 효과 또는 버텍스 셰이더로 설정하거나 재설정합니다. 다음의 love.graphics.setShader가 지정된 Shader 객체를 사용하여 그릴 때까지 모든 그리기 작업.<br /><br />인수없이 호출 될 때 셰이더를 비활성화합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setShader()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setShader( <span class = "arguments">shader</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">shader</td><td class = "ra_type"><a href="#Shader">Shader</a></td><td>새로운 쉐이더.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setPointSize" name = "love.graphics.setPointSize"><span>love.graphics.</span><wbr>setPointSize</a></p><p class = "function_description">포인트 크기를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setPointSize( <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">size</td><td class = "ra_type">number</td><td>새로운 포인트 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setScissor" name = "love.graphics.setScissor"><span>love.graphics.</span><wbr>setScissor</a></p><p class = "function_description">가위를 설정 또는 해제합니다.<br /><br />가위는 그림 영역을 지정된 사각형으로 제한합니다. 이것은 <a href="#love.graphics.clear">love.graphics.clear</a>를 포함한 모든 그래픽 호출에 영향을줍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setScissor( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">width</span>, <span class = "arguments">height</span> )</span></span></p><p class = "variant_description">지정된 직사각형 그리기 영역을 제한한다.</p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>좌상 구석의 X 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>좌상 구석의 Y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>클리핑 사각형의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>클리핑 직사각형의 높이입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setScissor()</span></span></p><p class = "variant_description">가위를 사용하지 않습니다.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setStencilTest" name = "love.graphics.setStencilTest"><span>love.graphics.</span><wbr>setStencilTest</a></p><p class = "function_description">스텐실 테스트를 구성하거나 비활성화합니다.<br /><br />스텐실 테스트가 활성화되면이 함수의 인수와 기하학적 요소가 접촉하는 각 픽셀의 스텐실 값을 비교하여 이후에 그려지는 모든 요소의 모양이 잘리고 / 스텐실로 표시됩니다. 픽셀의 스텐실 값은 <a href="#love.graphics.stencil">love.graphics.stencil</a>을 통해 영향을받습니다.<br /><br />각 Canvas에는 픽셀 별 스텐실 값이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setStencilTest( <span class = "arguments">comparemode</span>, <span class = "arguments">comparevalue</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">comparemode</td><td class = "ra_type"><a href="#CompareMode">CompareMode</a></td><td>각 픽셀에 대해 비교할 비교 유형입니다.</td></tr><tr><td class = "arguments ra_name">comparevalue</td><td class = "ra_type">number</td><td>각 픽셀의 스텐실 값과 비교할 때 사용할 값입니다. 0에서 255 사이 여야합니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setStencilTest()</span></span></p><p class = "variant_description">스텐실 테스트를 사용하지 않습니다.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.setWireframe" name = "love.graphics.setWireframe"><span>love.graphics.</span><wbr>setWireframe</a></p><p class = "function_description">와이어 프레임 선을 그릴 때 사용할지 여부를 설정합니다.<br /><br />와이어 프레임 모드는 디버깅에만 사용해야합니다. 그것으로 그려진 선은 일반 love.graphics 라인처럼 행동하지 활성화 : 그 폭은 좌표 변환 또는 <a href="#love.graphics.setLineWidth">love.graphics.setLineWidth</a>에 따라 확장하지 않으며, 그들은 부드러운 선 스타일을 사용하지 마십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>setWireframe( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>드로잉 할 때 와이어 프레임 모드를 사용하려면 True, 사용하지 않으려면 false.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.shear" name = "love.graphics.shear"><span>love.graphics.</span><wbr>shear</a></p><p class = "function_description">좌표계를 변경합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>shear( <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">kx</td><td class = "ra_type">number</td><td>x 축상의 전단 인자.</td></tr><tr><td class = "arguments ra_name">ky</td><td class = "ra_type">number</td><td>y 축상의 전단 인자.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.stencil" name = "love.graphics.stencil"><span>love.graphics.</span><wbr>stencil</a></p><p class = "function_description">지오메트리를 스텐실로 그립니다.<br /><br />제공된 함수에 의해 그려진 형상은 픽셀 색상을 설정하는 대신 픽셀의 보이지 않는 스텐실 값을 설정합니다. 픽셀의 스텐실 값은 마스크 / 스텐실처럼 작동 할 수 있습니다. <a href="#love.graphics.setStencilTest">love.graphics.setStencilTest</a>는 나중에 렌더링이 각 픽셀의 스텐실 값의 영향을받는 방식을 결정하는 데 사용될 수 있습니다.<br /><br />각 Canvas에는 픽셀 별 스텐실 값이 있습니다. 스텐실 값은 {0, 255} 범위 내에 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>stencil( <span class = "arguments">stencilfunction</span>, <span class = "arguments">action</span>, <span class = "arguments">value</span>, <span class = "arguments">keepvalues</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">stencilfunction</td><td class = "ra_type">function</td><td>기하학을 그리는 함수. 각 픽셀의 색이 아닌 픽셀의 스텐실 값은 형상의 영향을받습니다.</td></tr><tr><td class = "arguments ra_name">action <span class = "default">("replace")</span></td><td class = "ra_type"><a href="#StencilAction">StencilAction</a></td><td>스텐실 함수에서 그려지는 픽셀의 스텐실 값을 수정하는 방법</td></tr><tr><td class = "arguments ra_name">value <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>스텐실 동작을 "바꾼"경우 픽셀에 사용할 새 스텐실 값입니다. 다른 스텐실 작업에는 영향을 미치지 않습니다. 0에서 255 사이 여야합니다.</td></tr><tr><td class = "arguments ra_name">keepvalues <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>픽셀의 오래된 스텐실 값을 유지하려면 true이고, 스텐실 함수를 실행하기 전에 모든 픽셀의 스텐실 값을 0으로 다시 설정하려면 false입니다. <a href="#love.graphics.clear">love.graphics.clear</a>는 모든 스텐실 값을 다시 설정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.graphics.translate" name = "love.graphics.translate"><span>love.graphics.</span><wbr>translate</a></p><p class = "function_description">좌표계를 2 차원으로 변환합니다.<br /><br />이 함수가 두 개의 숫자, dx, dy로 호출되면, 다음의 모든 작업은 x와 y 좌표가 x + dx와 y + dy 인 것처럼 적용됩니다.<br /><br />규모와 변환은 교환 적 조작이 아니므로 다른 순서로 호출하면 결과가 변경됩니다.<br /><br />이 변경 사항은 <a href="#love.graphics.clear">love.graphics.clear</a>가 호출 될 때까지 지속됩니다 (기본 love.run 함수에서 love.draw 전에 자동으로 호출 됨). 또는 <a href="#love.graphics.pop">love.graphics.pop</a>이 이전 좌표계 상태로 돌아갑니다.<br /><br />정수를 사용하여 번역하면 번역 후 이미지가 끊어 지거나 흐리게 표시되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.graphics.<wbr>translate( <span class = "arguments">dx</span>, <span class = "arguments">dy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>x 축에 대한 상대적인 변환입니다.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>y 축에 대한 상대적인 변환입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#AlignMode" name = "AlignMode">AlignMode</a></p><p class = "constant_name">center</p><p class = "constant_description">가운데 정렬.</p><p class = "constant_name">left</p><p class = "constant_description">왼쪽 정렬.</p><p class = "constant_name">right</p><p class = "constant_description">오른쪽 정렬.</p><p class = "constant_name">justify</p><p class = "constant_description">양쪽 정렬.</p></div><div class = "section"><p class = "section_heading"><a href = "#ArcType" name = "ArcType">ArcType</a></p><p class = "constant_name">pie</p><p class = "constant_description">호는 파이의 조각처럼 그려지며 원호 원은 끝점에서 중심에 연결됩니다.</p><p class = "constant_name">open</p><p class = "constant_description">원호의 두 끝점은 원호가 선으로 그려 질 때 연결되지 않습니다. 호가 채워진 모드에서 그려 질 때 "닫힌"호 유형과 같이 작동합니다.</p><p class = "constant_name">closed</p><p class = "constant_description">원호의 두 끝점은 서로 연결되어 있습니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#AreaSpreadDistribution" name = "AreaSpreadDistribution">AreaSpreadDistribution</a></p><p class = "constant_name">uniform</p><p class = "constant_description">균일 분포.</p><p class = "constant_name">normal</p><p class = "constant_description">정상 (가우스) 분포.</p><p class = "constant_name">ellipse</p><p class = "constant_description">타원의 균일 분포.</p><p class = "constant_name">none</p><p class = "constant_description">배포 금지 - 영역 확산이 비활성화됩니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#BlendAlphaMode" name = "BlendAlphaMode">BlendAlphaMode</a></p><p class = "constant_name">alphamultiply</p><p class = "constant_description">그려지는 RGB 값에는 블렌딩 중에 해당 색상의 알파 값이 곱해집니다. 이것은 기본 알파 모드입니다.</p><p class = "constant_name">premultiplied</p><p class = "constant_description">그려지는 것의 RGB 값은 블렌딩 중에 해당 색상의 알파 값으로 곱해지지 않습니다. 대부분의 블렌드 모드가이 알파 모드에서 올바르게 작동하려면 그려지는 객체의 색상이 이전에 어떤 점에서 알파 값으로 곱해진 RGB 값 ( "미리 곱셈 된 알파")을 가져야합니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#BlendMode" name = "BlendMode">BlendMode</a></p><p class = "constant_name">alpha</p><p class = "constant_description">표준.</p><p class = "constant_name">replace</p><p class = "constant_description">대체.</p><p class = "constant_name">screen</p><p class = "constant_description">스크린.</p><p class = "constant_name">add</p><p class = "constant_description">그려지는 픽셀의 색상이 이미 화면의 픽셀 색상에 추가됩니다. 화면의 알파는 수정되지 않습니다.</p><p class = "constant_name">subtract</p><p class = "constant_description">그려지는 픽셀의 색은 이미 화면에있는 픽셀 색에서 뺍니다. 화면의 알파는 수정되지 않습니다.</p><p class = "constant_name">multiply</p><p class = "constant_description">그려지는 픽셀의 픽셀 색상은 이미 화면에있는 픽셀 색상과 곱 해져서 어두워집니다. "alphamultiply"BlendAlphaMode가 사용되는 경우에도 화면의 색상이 영향을 받는지 여부를 결정하기보다는 그려진 객체의 알파에 화면의 알파를 곱합니다.</p><p class = "constant_name">lighten</p><p class = "constant_description">그려지는 픽셀의 픽셀 색은 기존의 픽셀 색과 비교되며 각 색 구성 요소의 두 값 중 큰 값이 사용됩니다. <a href="#love.graphics.setBlendMode">love.graphics.setBlendMode</a>에서 "미리 곱셈 된"BlendAlphaMode가 사용되는 경우에만 작동합니다.</p><p class = "constant_name">darken</p><p class = "constant_description">그린 픽셀 색은 기존 픽셀 색과 비교되며 각 색 구성 요소의 두 값 중 작은 값이 사용됩니다. <a href="#love.graphics.setBlendMode">love.graphics.setBlendMode</a>에서 "미리 곱셈 된"BlendAlphaMode가 사용되는 경우에만 작동합니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#CanvasFormat" name = "CanvasFormat">CanvasFormat</a></p><p class = "constant_name">normal</p><p class = "constant_description">기본 Canvas 형식 - 일반적으로 rgba8 형식의 별칭이거나 L? VE 0.10.0 이상에서 감마 보정이 사용되는 경우 srgb 형식입니다.</p><p class = "constant_name">hdr</p><p class = "constant_description">높은 동적 범위 콘텐츠에 적합한 형식 - 일반적으로 rgba16f 형식의 별칭입니다.</p><p class = "constant_name">rgba8</p><p class = "constant_description">채널당 8 비트 (32 bpp) RGBA. 색상 채널 값의 범위는 0-255 (쉐이더에서 0-1)입니다.</p><p class = "constant_name">rgba4</p><p class = "constant_description">채널 당 4 비트 (16 bpp) RGBA.</p><p class = "constant_name">rgb5a1</p><p class = "constant_description">RGB 각각 5 비트 및 1 비트 알파 채널 (16bpp).</p><p class = "constant_name">rgb565</p><p class = "constant_description">RGB 각각 5, 6, 5 비트 (16bpp). 이 형식에는 알파 채널이 없습니다.</p><p class = "constant_name">rgb10a2</p><p class = "constant_description">채널당 10 비트의 RGB 및 2 비트 알파 채널 (32bpp).</p><p class = "constant_name">rgba16f</p><p class = "constant_description">채널 당 16 비트 (64 bpp)의 부동 소수점 RGBA. 색상 값의 범위는 {-65504, +65504}입니다.</p><p class = "constant_name">rgba32f</p><p class = "constant_description">채널당 32 비트 (128bpp)의 부동 소수점 RGBA.</p><p class = "constant_name">rg11b10f</p><p class = "constant_description">빨강 및 녹색 채널에서 11 비트, 파란색 채널에서 32 비트 (32bpp)의 부동 소수점 RGB 알파 채널이 없습니다. 색상 값의 범위는 {0, +65024}입니다.</p><p class = "constant_name">srgb</p><p class = "constant_description">rgba8과 같지만 Canvas는 sRGB 색상 공간에있는 것으로 해석됩니다. 캔버스에 그려지는 모든 것은 선형 RGB에서 sRGB로 변환됩니다. 캔버스를 그릴 때 (또는 셰이더에서 사용하는 경우) sRGB에서 선형 RGB로 디코딩됩니다. sRGB 인코딩은 어두운 색상의 경우 선형 RGB보다 정밀도가 높기 때문에 감마 보정 렌더링을 수행 할 때 색상 밴딩이 줄어 듭니다.</p><p class = "constant_name">r8</p><p class = "constant_description">단일 채널 (빨간색 구성 요소) 형식 (8bpp).</p><p class = "constant_name">rg8</p><p class = "constant_description">채널당 8 비트 (16bpp)의 두 채널 (적색 및 녹색 구성 요소).</p><p class = "constant_name">r16f</p><p class = "constant_description">부동 소수점 단일 채널 형식 (16 bpp). 색상 값의 범위는 {-65504, +65504}입니다.</p><p class = "constant_name">rg16f</p><p class = "constant_description">채널 당 16 비트 (32bpp)의 부동 소수점 2 채널 형식. 색상 값의 범위는 {-65504, +65504}입니다.</p><p class = "constant_name">r32f</p><p class = "constant_description">부동 소수점 단일 채널 형식 (32 bpp).</p><p class = "constant_name">rg32f</p><p class = "constant_description">채널 당 32 비트 (64 bpp)의 부동 소수점 2 채널 형식.</p></div><div class = "section"><p class = "section_heading"><a href = "#CompareMode" name = "CompareMode">CompareMode</a></p><p class = "constant_name">equal</p><p class = "constant_description">픽셀의 스텐실 값은 제공된 값과 동일해야합니다.</p><p class = "constant_name">notequal</p><p class = "constant_description">픽셀의 스텐실 값은 제공된 값과 같아서는 안됩니다.</p><p class = "constant_name">less</p><p class = "constant_description">픽셀의 스텐실 값은 제공된 값보다 작아야합니다.</p><p class = "constant_name">lequal</p><p class = "constant_description">픽셀의 스텐실 값은 제공된 값보다 작거나 같아야합니다.</p><p class = "constant_name">gequal</p><p class = "constant_description">픽셀의 스텐실 값은 제공된 값보다 크거나 같아야합니다.</p><p class = "constant_name">greater</p><p class = "constant_description">픽셀의 스텐실 값은 제공된 값보다 커야합니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#DrawMode" name = "DrawMode">DrawMode</a></p><p class = "constant_name">fill</p><p class = "constant_description">채우기.</p><p class = "constant_name">line</p><p class = "constant_description">외곽선.</p></div><div class = "section"><p class = "section_heading"><a href = "#FilterMode" name = "FilterMode">FilterMode</a></p><p class = "constant_name">linear</p><p class = "constant_description">부드럽게 보임.</p><p class = "constant_name">nearest</p><p class = "constant_description">픽셀이 딱딱 보임.</p></div><div class = "section"><p class = "section_heading"><a href = "#GraphicsFeature" name = "GraphicsFeature">GraphicsFeature</a></p><p class = "constant_name">clampzero</p><p class = "constant_description">"clampzero"WrapMode가 지원되는지 여부.</p><p class = "constant_name">lighten</p><p class = "constant_description">"밝게"및 "어둡게"BlendMode가 지원되는지 여부.</p><p class = "constant_name">multicanvasformats</p><p class = "constant_description">동일한 형식의 여러 캔버스를 동일한 <a href="#love.graphics.setCanvas">love.graphics.setCanvas</a> 호출에서 사용할 수 있는지 여부입니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#GraphicsLimit" name = "GraphicsLimit">GraphicsLimit</a></p><p class = "constant_name">pointsize</p><p class = "constant_description">포인트의 최대 크기.</p><p class = "constant_name">texturesize</p><p class = "constant_description">이미지와 캔버스의 최대 너비 또는 높이.</p><p class = "constant_name">multicanvas</p><p class = "constant_description">동시에 활성화 된 캔버스의 최대 개수입니다 (<a href="#love.graphics.setCanvas">love.graphics.setCanvas</a>를 통해).</p><p class = "constant_name">canvasmsaa</p><p class = "constant_description">Canvas에 대한 앤티 앨리어싱 샘플의 최대 수입니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#LineJoin" name = "LineJoin">LineJoin</a></p><p class = "constant_name">miter</p><p class = "constant_description">선 세그먼트의 끝은 각도가 경사지므로 원활하게 결합됩니다.</p><p class = "constant_name">bevel</p><p class = "constant_description">선분 끝에 캡이 적용되지 않았습니다.</p><p class = "constant_name">none</p><p class = "constant_description">선분이 함께 결합되는 점을 평평하게 만듭니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#LineStyle" name = "LineStyle">LineStyle</a></p><p class = "constant_name">rough</p><p class = "constant_description">거칠게.</p><p class = "constant_name">smooth</p><p class = "constant_description">부드럽게.</p></div><div class = "section"><p class = "section_heading"><a href = "#MeshDrawMode" name = "MeshDrawMode">MeshDrawMode</a></p><p class = "constant_name">fan</p><p class = "constant_description">버텍스는 첫 번째 버텍스가 허브 포인트 역할을하는 "팬"모양을 만듭니다. 간단한 볼록 다각형을 그릴 때 쉽게 사용할 수 있습니다.</p><p class = "constant_name">strip</p><p class = "constant_description">정점은 정점 1, 2, 3, 3, 2, 4 (순서를 기록), 3, 4, 5 등을 사용하여 일련의 연결된 삼각형을 만듭니다.</p><p class = "constant_name">triangles</p><p class = "constant_description">꼭지점은 연결되지 않은 삼각형을 만듭니다.</p><p class = "constant_name">points</p><p class = "constant_description">꼭지점은 연결되지 않은 점으로 그려집니다 (<a href="#love.graphics.setPointSize">love.graphics.setPointSize</a> 참조).</p></div><div class = "section"><p class = "section_heading"><a href = "#ParticleInsertMode" name = "ParticleInsertMode">ParticleInsertMode</a></p><p class = "constant_name">top</p><p class = "constant_description">파티클은 파티클 시스템의 파티클 목록 상단에 삽입됩니다.</p><p class = "constant_name">bottom</p><p class = "constant_description">파티클은 파티클 시스템의 파티클 목록 하단에 삽입됩니다.</p><p class = "constant_name">random</p><p class = "constant_description">파티클은 파티클 시스템의 파티클 목록에서 임의의 위치에 삽입됩니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#SpriteBatchUsage" name = "SpriteBatchUsage">SpriteBatchUsage</a></p><p class = "constant_name">dynamic</p><p class = "constant_description">개체의 데이터는 수명주기 동안 때때로 변경됩니다.</p><p class = "constant_name">static</p><p class = "constant_description">오브젝트는 초기 스프라이트 나 정점이 추가 된 후에 수정되지 않습니다.</p><p class = "constant_name">stream</p><p class = "constant_description">오브젝트 데이터는 항상 그릴 때마다 변경됩니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#StackType" name = "StackType">StackType</a></p><p class = "constant_name">transform</p><p class = "constant_description">변형 스택 (<a href="#love.graphics.translate">love.graphics.translate</a>, <a href="#love.graphics.rotate">love.graphics.rotate</a> 등)</p><p class = "constant_name">all</p><p class = "constant_description">모든 love.graphics 상태 (변형 상태 포함).</p></div><div class = "section"><p class = "section_heading"><a href = "#StencilAction" name = "StencilAction">StencilAction</a></p><p class = "constant_name">replace</p><p class = "constant_description">픽셀의 스텐실 값은 객체가 픽셀에 닿으면 <a href="#love.graphics.stencil">love.graphics.stencil</a>에 지정된 값으로 대체됩니다.</p><p class = "constant_name">increment</p><p class = "constant_description">픽셀의 스텐실 값은 픽셀에 닿는 각 객체에 대해 1 씩 증가합니다. 스텐실 값이 255에 도달하면 255로 유지됩니다.</p><p class = "constant_name">decrement</p><p class = "constant_description">픽셀의 스텐실 값은 픽셀에 닿는 각 객체에 대해 1 씩 감소합니다. 스텐실 값이 0에 도달하면 0으로 유지됩니다.</p><p class = "constant_name">incrementwrap</p><p class = "constant_description">픽셀의 스텐실 값은 픽셀에 닿는 각 객체에 대해 1 씩 증가합니다. 255의 스텐실 값이 증가되면 0으로 설정됩니다.</p><p class = "constant_name">decrementwrap</p><p class = "constant_description">픽셀의 스텐실 값은 픽셀에 닿는 각 객체에 대해 1 씩 감소합니다. 스텐실 값 0이 감소되면 255로 설정됩니다.</p><p class = "constant_name">invert</p><p class = "constant_description">픽셀의 스텐실 값은 픽셀에 닿는 각 객체에 대해 비트 반전됩니다. 스텐실 값 0이 반전되면 255가됩니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#WrapMode" name = "WrapMode">WrapMode</a></p><p class = "constant_name">clamp</p><p class = "constant_description">이미지가 이미지 크기보다 큰 4 배 크기의 쿼드 내에서 어떻게 랩핑됩니까? 이것은 {0, 1}의 범위 밖에있는 텍스처 좌표로 메쉬를 그린 방법과 {0, 1} 범위를 벗어난 텍스쳐 좌표로 샘플링 할 때 텍셀 셰이더 함수에 의해 반환되는 색에 영향을 미칩니다.</p><p class = "constant_name">repeat</p><p class = "constant_description">이미지를 반복하십시오. 사용 가능한 전체 범위를 채 웁니다.</p><p class = "constant_name">mirroredrepeat</p><p class = "constant_description">반복 할 때마다 텍스처를 뒤집어 반복합니다. 텍스처가 완벽하게 타일링되지 않을 때 반복 모드보다 시각적 인 결과가 더 좋을 수 있습니다.</p><p class = "constant_name">clampzero</p><p class = "constant_description">텍스처를 클램핑하십시오. 텍스처의 표준 범위를 벗어난 영역을 투명한 검정색으로 채 웁니다 (또는 알파 채널이없는 텍스처의 경우 불투명 한 검정색).</p></div><div class = "section"><p class = "section_heading"><a href = "#Canvas" name = "Canvas">Canvas</a></p><p class = "section_description">캔버스는 스크린 외부 렌더링에 사용됩니다. 그릴 수있는 보이지 않는 화면으로 생각할 수 있지만 실제로 보이는 화면에 그릴 때까지 표시되지 않습니다. 또한 "텍스처에 렌더링"이라고도합니다.<br /><br />캔버스에 위치를 자주 변경하지 않는 항목 (예 : 배경 항목)을 그려서 각 항목 대신 전체 캔버스를 그리면 각 프레임에서 수행되는 그리기 작업 수를 줄일 수 있습니다.<br /><br />0.10.0 이전 버전에서는 L-VE가 지원하는 모든 그래픽 카드가 캔버스를 사용할 수있는 것은 아닙니다. love.graphics.isSupported ( "canvas")는 런타임에 지원 여부를 확인하는 데 사용할 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newCanvas">newCanvas</a>&emsp;오프 스크린 렌더링을위한 새로운 Canvas 객체를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:getFormat">getFormat</a>&emsp;Canvas의 텍스처 포맷을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:getMSAA">getMSAA</a>&emsp;캔버스에 그리는 데 사용되는 MSAA (multisample antialiasing) 샘플의 수를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:getFilter">get</a><span class = "slash">/</span><a href="#Canvas:setFilter">setFilter</a>&emsp;Canvas의 필터를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:getWrap">get</a><span class = "slash">/</span><a href="#Canvas:setWrap">setWrap</a>&emsp;Canvas의 래핑 속성을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:newImageData">newImageData</a>&emsp;Canvas의 내용에서 ImageData를 생성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:renderTo">renderTo</a>&emsp;함수를 사용하여 Canvas로 렌더링합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:getDimensions">getDimensions</a>&emsp;Canvas의 폭과 높이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:getWidth">getWidth</a>&emsp;Canvas의 너비를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Canvas:<a href="#Canvas:getHeight">getHeight</a>&emsp;Canvas의 높이를 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Texture">Texture</a>&emsp;텍스처를 나타내는 드로어 블 오브젝트의 슈퍼 클래스입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:getDimensions" name = "Canvas:getDimensions"><span>Canvas:</span><wbr>getDimensions</a></p><p class = "function_description">Canvas의 폭과 높이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = Canvas:<wbr>getDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>Canvas의 폭 (픽셀 단위)입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>Canvas의 높이 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:getFilter" name = "Canvas:getFilter"><span>Canvas:</span><wbr>getFilter</a></p><p class = "function_description">Canvas의 필터 모드를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">mag</span>, <span class = "returns">anisotropy</span> = Canvas:<wbr>getFilter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>캔버스를 축소 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">mag</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>캔버스를 확대 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">anisotropy</td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대량입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:getFormat" name = "Canvas:getFormat"><span>Canvas:</span><wbr>getFormat</a></p><p class = "function_description">Canvas의 텍스처 포맷을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">format</span> = Canvas:<wbr>getFormat()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">format</td><td class = "ra_type"><a href="#CanvasFormat">CanvasFormat</a></td><td>Canvas의 형식.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:getHeight" name = "Canvas:getHeight"><span>Canvas:</span><wbr>getHeight</a></p><p class = "function_description">Canvas의 높이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = Canvas:<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>Canvas의 높이 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:getMSAA" name = "Canvas:getMSAA"><span>Canvas:</span><wbr>getMSAA</a></p><p class = "function_description">캔버스에 그리는 데 사용되는 MSAA (multisample antialiasing) 샘플의 수를 가져옵니다.<br /><br />L-VE를 실행하는 시스템이 해당 번호를 지원하지 않으면 <a href="#love.graphics.newCanvas">love.graphics.newCanvas</a>에 대한 인수로 사용 된 번호와 다를 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">samples</span> = Canvas:<wbr>getMSAA()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">samples</td><td class = "ra_type">number</td><td>캔버스가 드로잉 할 때 사용되는 멀티 샘플 앤티 앨리어싱 샘플의 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:getWidth" name = "Canvas:getWidth"><span>Canvas:</span><wbr>getWidth</a></p><p class = "function_description">Canvas의 너비를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = Canvas:<wbr>getWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>Canvas의 폭 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:getWrap" name = "Canvas:getWrap"><span>Canvas:</span><wbr>getWrap</a></p><p class = "function_description">Canvas의 래핑 속성을 가져옵니다.<br /><br />이 함수는 Canvas에 대해 현재 설정된 가로 및 세로 래핑 모드를 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">horizontal</span>, <span class = "returns">vertical</span> = Canvas:<wbr>getWrap()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">horizontal</td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>Canvas의 가로 포장 모드입니다.</td></tr><tr><td class = "returns ra_name">vertical</td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>Canvas의 세로 배치 모드입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:newImageData" name = "Canvas:newImageData"><span>Canvas:</span><wbr>newImageData</a></p><p class = "function_description">Canvas의 내용에서 ImageData를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">data</span> = Canvas:<wbr>newImageData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">data</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>Canvas에 저장된 이미지 데이터.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">data</span> = Canvas:<wbr>newImageData( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">width</span>, <span class = "arguments">height</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">data</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>Canvas의 내용으로 작성된 새로운 ImageData입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>캡처 할 Canvas 내의 영역 왼쪽 위 모퉁이의 x 축입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>캡처 할 Canvas 내의 영역 왼쪽 위 모서리의 y 축입니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>캡처 할 Canvas 영역의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>캡처 할 Canvas 내의 영역의 높이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:renderTo" name = "Canvas:renderTo"><span>Canvas:</span><wbr>renderTo</a></p><p class = "function_description">함수를 사용하여 Canvas로 렌더링합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Canvas:<wbr>renderTo( <span class = "arguments">func</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">func</td><td class = "ra_type">function</td><td>그리기 작업을 수행하는 함수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:setFilter" name = "Canvas:setFilter"><span>Canvas:</span><wbr>setFilter</a></p><p class = "function_description">Canvas의 필터를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Canvas:<wbr>setFilter( <span class = "arguments">min</span>, <span class = "arguments">mag</span>, <span class = "arguments">anisotropy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>캔버스 크기를 조정하는 법.</td></tr><tr><td class = "arguments ra_name">mag <span class = "default">(min)</span></td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>캔버스의 크기를 조정하는 법.</td></tr><tr><td class = "arguments ra_name">anisotropy <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대량입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Canvas:setWrap" name = "Canvas:setWrap"><span>Canvas:</span><wbr>setWrap</a></p><p class = "function_description">Canvas의 래핑 속성을 설정합니다.<br /><br />이 함수는 크기가 조정되거나 회전 된 경우 Canvas 가장자리를 처리하는 방법을 설정합니다. WrapMode가 "clamp"로 설정된 경우 가장자리가 보간되지 않습니다. "반복"으로 설정하면 가장자리가 프레임 버퍼의 반대쪽에있는 픽셀로 보간됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Canvas:<wbr>setWrap( <span class = "arguments">horizontal</span>, <span class = "arguments">vertical</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">horizontal</td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>Canvas의 가로 포장 모드입니다.</td></tr><tr><td class = "arguments ra_name">vertical <span class = "default">(horizontal)</span></td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>Canvas의 세로 배치 모드입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Font" name = "Font">Font</a></p><p class = "section_description">화면에 그릴 수있는 문자의 모양을 정의합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newFont">newFont</a>&emsp;트루 타입 글꼴 또는 BMFont 파일에서 새 글꼴을 만듭니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newImageFont">newImageFont</a>&emsp;포맷 된 이미지를로드 해 새로운 Font를 작성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.setNewFont">setNewFont</a>&emsp;새 글꼴을 만들고 설정합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getFilter">get</a><span class = "slash">/</span><a href="#Font:setFilter">setFilter</a>&emsp;글꼴의 필터 모드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:hasGlyphs">hasGlyphs</a>&emsp;글꼴이 특정 문자를 렌더링 할 수 있는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:setFallbacks">setFallbacks</a>&emsp;대체 글꼴을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getWrap">getWrap</a>&emsp;랩 제한이있는 텍스트의 서식 지정 정보를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getLineHeight">get</a><span class = "slash">/</span><a href="#Font:setLineHeight">setLineHeight</a>&emsp;선의 높이를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getWidth">getWidth</a>&emsp;텍스트 행에 필요한 가로 크기를 결정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getHeight">getHeight</a>&emsp;Font의 높이를 돌려줍니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getBaseline">getBaseline</a>&emsp;Font의 baseline를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getAscent">getAscent</a>&emsp;Font의 아 센트를 취득합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Font:<a href="#Font:getDescent">getDescent</a>&emsp;Font의 디 센트를 취득합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Font:getAscent" name = "Font:getAscent"><span>Font:</span><wbr>getAscent</a></p><p class = "function_description">Font의 아 센트를 취득합니다. 등고선은 기준선과 기준선에서 가장 멀리 떨어져있는 글리프의 상단 사이의 거리를 나타냅니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ascent</span> = Font:<wbr>getAscent()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ascent</td><td class = "ra_type">number</td><td>Font의 아 센트 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:getBaseline" name = "Font:getBaseline"><span>Font:</span><wbr>getBaseline</a></p><p class = "function_description">Font의 baseline를 가져옵니다. 대부분의 스크립트는 기준선이라는 개념을 공유합니다. 문자가 놓이는 가상의 수평선입니다. 일부 스크립트에서는 글리프의 일부가 기준선 아래에 놓입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">baseline</span> = Font:<wbr>getBaseline()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">baseline</td><td class = "ra_type">number</td><td>글꼴의 기준선 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:getDescent" name = "Font:getDescent"><span>Font:</span><wbr>getDescent</a></p><p class = "function_description">Font의 디 센트를 취득합니다. 하강은 기준선과 서체에서 가장 낮은 내림차순 글리프 사이의 거리에 걸쳐 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">descent</span> = Font:<wbr>getDescent()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">descent</td><td class = "ra_type">number</td><td>Font의 디 센트 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:getFilter" name = "Font:getFilter"><span>Font:</span><wbr>getFilter</a></p><p class = "function_description">글꼴의 필터 모드를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">mag</span>, <span class = "returns">anisotropy</span> = Font:<wbr>getFilter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>글꼴을 축소 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">mag</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>글꼴을 확대 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">anisotropy</td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대량입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:getHeight" name = "Font:getHeight"><span>Font:</span><wbr>getHeight</a></p><p class = "function_description">Font의 높이를 돌려줍니다. 글꼴의 높이는 간격을 포함하는 크기입니다. 필요한 높이.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = Font:<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>글꼴의 높이 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:getLineHeight" name = "Font:getLineHeight"><span>Font:</span><wbr>getLineHeight</a></p><p class = "function_description">선의 높이를 가져옵니다. 이것은 Font : setLineHeight에 의해 이전에 설정된 값이거나 기본값은 1.0입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = Font:<wbr>getLineHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>현재 행의 높이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:getWidth" name = "Font:getWidth"><span>Font:</span><wbr>getWidth</a></p><p class = "function_description">텍스트 행에 필요한 가로 크기를 결정합니다. 줄 바꿈을 지원하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = Font:<wbr>getWidth( <span class = "arguments">line</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>선의 폭입니다.</td></tr><tr><td class = "arguments ra_name">line</td><td class = "ra_type">string</td><td>한 줄의 텍스트.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:getWrap" name = "Font:getWrap"><span>Font:</span><wbr>getWrap</a></p><p class = "function_description">랩 제한이있는 텍스트의 서식 지정 정보를 가져옵니다.<br /><br />이 함수는 개행을 올바르게 계산합니다 (예 : '\ n').</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">wrappedtext</span> = Font:<wbr>getWrap( <span class = "arguments">text</span>, <span class = "arguments">wraplimit</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>줄 바꿈 된 텍스트의 최대 너비입니다.</td></tr><tr><td class = "returns ra_name">wrappedtext</td><td class = "ra_type">table</td><td>줄 바꿈 된 각 텍스트 줄을 포함하는 시퀀스입니다.</td></tr><tr><td class = "arguments ra_name">text</td><td class = "ra_type">string</td><td>줄 바꿈 될 텍스트입니다.</td></tr><tr><td class = "arguments ra_name">wraplimit</td><td class = "ra_type">number</td><td>줄 바꿈 전에 텍스트가 허용되는 각 줄의 최대 너비 (픽셀)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:hasGlyphs" name = "Font:hasGlyphs"><span>Font:</span><wbr>hasGlyphs</a></p><p class = "function_description">글꼴이 특정 문자를 렌더링 할 수 있는지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">hasglyph</span> = Font:<wbr>hasGlyphs( <span class = "arguments">character</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">hasglyph</td><td class = "ra_type">boolean</td><td>폰트가 문자로 나타내지는 그래프를 렌더링 할 수 있을지 어떨지를 나타냅니다.</td></tr><tr><td class = "arguments ra_name">character</td><td class = "ra_type">string</td><td>유니 코드 문자.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">hasglyph</span> = Font:<wbr>hasGlyphs( <span class = "arguments">codepoint</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">hasglyph</td><td class = "ra_type">boolean</td><td>글꼴이 코드 포인트 번호로 표시되는 글리프를 렌더링 할 수 있는지 여부입니다.</td></tr><tr><td class = "arguments ra_name">codepoint</td><td class = "ra_type">number</td><td>유니 코드 코드 포인트 번호입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:setFallbacks" name = "Font:setFallbacks"><span>Font:</span><wbr>setFallbacks</a></p><p class = "function_description">대체 글꼴을 설정합니다. 글꼴에 글리프가 포함되어 있지 않으면 다음 후속 대체 글꼴의 글리프가 대체됩니다. 이는 캐스 케이 딩 스타일 시트 (CSS)에서 "글꼴 스택"을 설정하는 것과 유사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Font:<wbr>setFallbacks( <span class = "arguments">fallbackfont1</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">fallbackfont1</td><td class = "ra_type"><a href="#Font">Font</a></td><td>사용할 첫 번째 폴백 글꼴입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type"><a href="#Font">Font</a></td><td>추가 대체 글꼴.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:setFilter" name = "Font:setFilter"><span>Font:</span><wbr>setFilter</a></p><p class = "function_description">글꼴의 필터 모드를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Font:<wbr>setFilter( <span class = "arguments">min</span>, <span class = "arguments">mag</span>, <span class = "arguments">anisotropy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>글꼴 크기를 조정하는 방법.</td></tr><tr><td class = "arguments ra_name">mag <span class = "default">(min)</span></td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>글꼴 크기를 조정하는 법.</td></tr><tr><td class = "arguments ra_name">anisotropy <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대량입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Font:setLineHeight" name = "Font:setLineHeight"><span>Font:</span><wbr>setLineHeight</a></p><p class = "function_description">선의 높이를 설정합니다. 선에서 글꼴을 렌더링 할 때 실제 높이는 선 높이와 글꼴 높이를 곱하여 결정됩니다. 기본값은 1.0입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Font:<wbr>setLineHeight( <span class = "arguments">height</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>새로운 선 높이.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Mesh" name = "Mesh">Mesh</a></p><p class = "section_description">임의의 텍스처 모양을 ​​그리는 데 사용되는 2D 폴리곤 메쉬입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newMesh">newMesh</a>&emsp;새 메쉬를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:attachAttribute">attachAttribute</a>&emsp;묘화시에 사용하기 위해서, 다른 Mesh의 정점 속성을이 Mesh에 Attach합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getVertexCount">getVertexCount</a>&emsp;메쉬의 총 정점 수를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getVertexFormat">getVertexFormat</a>&emsp;메쉬가 작성된 정점 포맷을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:isAttributeEnabled">is</a><span class = "slash">/</span><a href="#Mesh:setAttributeEnabled">setAttributeEnabled</a>&emsp;메쉬에서 특정 정점 속성을 활성화하거나 비활성화합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getDrawMode">get</a><span class = "slash">/</span><a href="#Mesh:setDrawMode">setDrawMode</a>&emsp;메쉬를 그릴 때 사용되는 모드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getDrawRange">get</a><span class = "slash">/</span><a href="#Mesh:setDrawRange">setDrawRange</a>&emsp;그려진 메쉬의 정점을 전체의 부분 집합으로 제한합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getTexture">get</a><span class = "slash">/</span><a href="#Mesh:setTexture">setTexture</a>&emsp;메쉬를 그릴 때 사용되는 텍스처 (이미지 또는 캔버스)를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getVertex">get</a><span class = "slash">/</span><a href="#Mesh:setVertex">setVertex</a>&emsp;메쉬의 정점 속성을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getVertexAttribute">get</a><span class = "slash">/</span><a href="#Mesh:setVertexAttribute">setVertexAttribute</a>&emsp;Mesh의 정점 내의 특정 속성의 속성을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:getVertexMap">get</a><span class = "slash">/</span><a href="#Mesh:setVertexMap">setVertexMap</a>&emsp;Mesh의 정점지도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Mesh:<a href="#Mesh:setVertices">setVertices</a>&emsp;메쉬에있는 정점의 범위를 새로운 것으로 대체합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:attachAttribute" name = "Mesh:attachAttribute"><span>Mesh:</span><wbr>attachAttribute</a></p><p class = "function_description">묘화시에 사용하기 위해서, 다른 Mesh의 정점 속성을이 Mesh에 Attach합니다. 이것은 여러 메쉬간에 정점 속성 데이터를 공유하는 데 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>attachAttribute( <span class = "arguments">name</span>, <span class = "arguments">mesh</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>첨부 할 정점 속성의 이름입니다.</td></tr><tr><td class = "arguments ra_name">mesh</td><td class = "ra_type"><a href="#Mesh">Mesh</a></td><td>정점 속성을 가져 오는 메쉬입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getDrawMode" name = "Mesh:getDrawMode"><span>Mesh:</span><wbr>getDrawMode</a></p><p class = "function_description">메쉬를 그릴 때 사용하는 모드를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mode</span> = Mesh:<wbr>getDrawMode()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mode</td><td class = "ra_type"><a href="#MeshDrawMode">MeshDrawMode</a></td><td>Mesh를 그릴 때 사용되는 모드.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getDrawRange" name = "Mesh:getDrawRange"><span>Mesh:</span><wbr>getDrawRange</a></p><p class = "function_description">메쉬를 그릴 때 사용 된 정점의 범위를 가져옵니다.<br /><br />메쉬의 그리기 범위가 Mesh : setDrawRange로 이전에 설정되지 않은 경우이 함수는 nil을 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = Mesh:<wbr>getDrawRange()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>묘화시에 사용되는 최초의 정점의 인덱스, 또는이 Mesh에 1 개가 설정된 경우에 사용되는 정점 맵의 최초의 값의 인덱스.</td></tr><tr><td class = "returns ra_name">max</td><td class = "ra_type">number</td><td>묘화시에 사용 된 마지막 정점의 인덱스, 또는이 메쉬에 설정되어있는 경우에 사용되는 정점 맵의 마지막 값의 인덱스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getTexture" name = "Mesh:getTexture"><span>Mesh:</span><wbr>getTexture</a></p><p class = "function_description">메쉬를 그릴 때 사용되는 텍스처 (이미지 또는 캔버스)를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">texture</span> = Mesh:<wbr>getTexture()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>그리기 할 때 이미지 또는 캔버스에 질감을 지정하거나 설정된 것이 없으면 nil을 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getVertex" name = "Mesh:getVertex"><span>Mesh:</span><wbr>getVertex</a></p><p class = "function_description">메쉬의 정점 속성을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">attributecomponent</span>, <span class = "returns">...</span> = Mesh:<wbr>getVertex( <span class = "arguments">index</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">attributecomponent</td><td class = "ra_type">number</td><td>지정된 정점에있는 첫 번째 정점 속성의 첫 번째 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>지정된 정점에있는 모든 정점 속성의 추가 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>정보를 검색 할 정점의 인덱스입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">u</span>, <span class = "returns">v</span>, <span class = "returns">r</span>, <span class = "returns">g</span>, <span class = "returns">b</span>, <span class = "returns">a</span> = Mesh:<wbr>getVertex( <span class = "arguments">index</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>x 축상의 정점의 위치.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>y 축상의 정점의 위치입니다.</td></tr><tr><td class = "returns ra_name">u</td><td class = "ra_type">number</td><td>텍스처 좌표의 수평 성분.</td></tr><tr><td class = "returns ra_name">v</td><td class = "ra_type">number</td><td>텍스처 좌표의 수직 성분.</td></tr><tr><td class = "returns ra_name">r</td><td class = "ra_type">number</td><td>정점의 색의 빨강 성분.</td></tr><tr><td class = "returns ra_name">g</td><td class = "ra_type">number</td><td>정점의 색의 녹색 성분입니다.</td></tr><tr><td class = "returns ra_name">b</td><td class = "ra_type">number</td><td>정점의 색의 청색 성분입니다.</td></tr><tr><td class = "returns ra_name">a</td><td class = "ra_type">number</td><td>정점의 색의 알파 성분입니다.</td></tr><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>정보를 검색 할 정점의 인덱스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getVertexAttribute" name = "Mesh:getVertexAttribute"><span>Mesh:</span><wbr>getVertexAttribute</a></p><p class = "function_description">Mesh의 정점 내의 특정 속성의 속성을 가져옵니다.<br /><br /><a href="#love.graphics.newMesh">love.graphics.newMesh</a>에 지정된 사용자 정의 정점 형식이없는 메쉬는 첫 번째 속성으로 위치를, 두 번째 속성으로 텍스처 좌표를, 세 번째 속성으로 색상을 갖습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value1</span>, <span class = "returns">value2</span>, <span class = "returns">...</span> = Mesh:<wbr>getVertexAttribute( <span class = "arguments">vertexindex</span>, <span class = "arguments">attributeindex</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value1</td><td class = "ra_type">number</td><td>특성의 첫 번째 구성 요소 값입니다.</td></tr><tr><td class = "returns ra_name">value2</td><td class = "ra_type">number</td><td>속성의 두 번째 구성 요소 값입니다.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>추가 정점 속성 구성 요소.</td></tr><tr><td class = "arguments ra_name">vertexindex</td><td class = "ra_type">number</td><td>수정되는 정점의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">attributeindex</td><td class = "ra_type">number</td><td>수정되는 정점 내의 속성의 인덱스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getVertexCount" name = "Mesh:getVertexCount"><span>Mesh:</span><wbr>getVertexCount</a></p><p class = "function_description">메쉬의 총 정점 수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">num</span> = Mesh:<wbr>getVertexCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">num</td><td class = "ra_type">number</td><td>이 메쉬의 총 정점 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getVertexFormat" name = "Mesh:getVertexFormat"><span>Mesh:</span><wbr>getVertexFormat</a></p><p class = "function_description">메쉬가 작성된 정점 포맷을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">format</span> = Mesh:<wbr>getVertexFormat()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">format</td><td class = "ra_type">table</td><td>메쉬의 정점 포맷으로, 메쉬가 생성 된 각 정점 속성에 대한 테이블을 포함하는 테이블이며, {attribute, ...} 형식으로되어 있습니다.</td></tr><tr><td class = "returns ra_name">format.attribute</td><td class = "ra_type">table</td><td>속성의 이름, 데이터 유형 및 속성의 구성 요소 수를 {name, datatype, components} 형식으로 포함하는 테이블입니다.</td></tr><tr><td class = "returns ra_name">format....</td><td class = "ra_type">table</td><td>메쉬의 추가 정점 속성.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:getVertexMap" name = "Mesh:getVertexMap"><span>Mesh:</span><wbr>getVertexMap</a></p><p class = "function_description">Mesh의 정점지도를 가져옵니다. 정점 맵은 메쉬를 그릴 때 정점이 사용되는 순서를 설명합니다. 꼭짓점, 정점지도 및 메쉬 그리기 모드가 함께 작동하여 화면에 정확히 무엇이 표시되는지 결정합니다.<br /><br />이전에 메쉬 : setVertexMap을 통해 정점지도가 설정되지 않은 경우이 함수는 L-VE 0.10.0+에서 nil을 반환하거나 0.9.2 이전의 빈 테이블을 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">map</span> = Mesh:<wbr>getVertexMap()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">map</td><td class = "ra_type">table</td><td>묘화시에 사용 된 정점 인덱스의리스트를 포함한 테이블입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:isAttributeEnabled" name = "Mesh:isAttributeEnabled"><span>Mesh:</span><wbr>isAttributeEnabled</a></p><p class = "function_description">메쉬의 특정 정점 속성이 활성화되었는지 여부를 가져옵니다. 비활성화 된 속성의 정점 데이터는 메쉬를 그릴 때 사용되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = Mesh:<wbr>isAttributeEnabled( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>이 Mesh를 묘화 할 때에 정점 속성을 사용할지 어떨지를 나타냅니다.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>활성화 또는 비활성화 할 정점 속성의 이름입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setAttributeEnabled" name = "Mesh:setAttributeEnabled"><span>Mesh:</span><wbr>setAttributeEnabled</a></p><p class = "function_description">메쉬에서 특정 정점 속성을 활성화하거나 비활성화합니다. 비활성화 된 속성의 정점 데이터는 메쉬를 그릴 때 사용되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setAttributeEnabled( <span class = "arguments">name</span>, <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>활성화 또는 비활성화 할 정점 속성의 이름입니다.</td></tr><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>이 Mesh를 묘화 할 때에 정점 속성을 사용할지 어떨지를 나타냅니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setDrawMode" name = "Mesh:setDrawMode"><span>Mesh:</span><wbr>setDrawMode</a></p><p class = "function_description">메쉬를 그릴 때 사용되는 모드를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setDrawMode( <span class = "arguments">mode</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#MeshDrawMode">MeshDrawMode</a></td><td>Mesh를 그릴 때 사용할 모드.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setDrawRange" name = "Mesh:setDrawRange"><span>Mesh:</span><wbr>setDrawRange</a></p><p class = "function_description">그려진 메쉬의 정점을 전체의 부분 집합으로 제한합니다.<br /><br />메쉬와 함께 정점 맵을 사용하는 경우,이 메소드는 메쉬의 전체 정점의 서브 세트 대신에 사용할 정점 맵 배열에있는 값의 서브 세트를 설정합니다.<br /><br />예를 들어, <a href="#Mesh">Mesh</a> : setVertexMap (1, 2, 3, 1, 3, 4) 및 <a href="#Mesh">Mesh</a> : setDrawRange (4, 6)가 호출되면 꼭짓점 1, 3 및 4가 그려집니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setDrawRange( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>묘화시에 사용하는 최초의 정점의 인덱스, 또는이 메쉬에 정점이 설정되어있는 경우에 사용하는 정점 맵의 최초의 값의 인덱스.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>묘화시에 사용하는 마지막 정점의 인덱스, 또는이 메쉬에 설정되어있는 경우에 사용하는 정점 맵의 최후의 값의 인덱스.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setDrawRange()</span></span></p><p class = "variant_description">Allows all vertices in the <a href="#Mesh">Mesh</a> to be drawn.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setTexture" name = "Mesh:setTexture"><span>Mesh:</span><wbr>setTexture</a></p><p class = "function_description">메쉬를 그릴 때 사용되는 텍스처 (이미지 또는 캔버스)를 설정합니다.<br /><br />인수없이 호출하면 텍스처가 비활성화됩니다. 채워지지 않은 메쉬는 기본적으로 흰색을가집니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setTexture()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setTexture( <span class = "arguments">texture</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>묘화시 메쉬를 질감 짓기위한 이미지 또는 캔버스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setVertex" name = "Mesh:setVertex"><span>Mesh:</span><wbr>setVertex</a></p><p class = "function_description">메쉬의 정점 속성을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertex( <span class = "arguments">index</span>, <span class = "arguments">attributecomponent</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>수정할 정점의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">attributecomponent</td><td class = "ra_type">number</td><td>지정된 정점에있는 첫 번째 정점 속성의 첫 번째 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>지정된 정점에있는 모든 정점 속성의 추가 구성 요소입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertex( <span class = "arguments">index</span>, <span class = "arguments">vertex</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>수정할 정점의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">vertex</td><td class = "ra_type">table</td><td>{attributecomponent, ...}의 형식으로 정점 정보가있는 테이블.</td></tr><tr><td class = "arguments ra_name">vertex.attributecomponent</td><td class = "ra_type">number</td><td>지정된 정점에있는 첫 번째 정점 속성의 첫 번째 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">vertex....</td><td class = "ra_type">number</td><td>지정된 정점에있는 모든 정점 속성의 추가 구성 요소입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertex( <span class = "arguments">index</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">u</span>, <span class = "arguments">v</span>, <span class = "arguments">r</span>, <span class = "arguments">g</span>, <span class = "arguments">b</span>, <span class = "arguments">a</span> )</span></span></p><p class = "variant_description">의 정점 요소 설정하는 Mesh을 사용하여 만든 아니라고 사용자 정의 정점 포맷.</p><table class = "ra_table"><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>수정할 정점의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축상의 정점의 위치.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축상의 정점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">u</td><td class = "ra_type">number</td><td>텍스처 좌표의 수평 성분.</td></tr><tr><td class = "arguments ra_name">v</td><td class = "ra_type">number</td><td>텍스처 좌표의 수직 성분.</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 빨강 성분.</td></tr><tr><td class = "arguments ra_name">g <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 녹색 성분입니다.</td></tr><tr><td class = "arguments ra_name">b <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 청색 성분입니다.</td></tr><tr><td class = "arguments ra_name">a <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 알파 성분입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertex( <span class = "arguments">index</span>, <span class = "arguments">vertex</span> )</span></span></p><p class = "variant_description">Sets the vertex components of a <a href="#Mesh">Mesh</a> that wasn't created with a custom vertex format.</p><table class = "ra_table"><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>수정할 정점의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">vertex</td><td class = "ra_type">table</td><td>버텍스 정보가있는 테이블.</td></tr><tr><td class = "arguments ra_name">vertex.[1]</td><td class = "ra_type">number</td><td>x 축상의 정점의 위치.</td></tr><tr><td class = "arguments ra_name">vertex.[2]</td><td class = "ra_type">number</td><td>y 축상의 정점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">vertex.[3]</td><td class = "ra_type">number</td><td>텍스처 좌표의 수평 성분.</td></tr><tr><td class = "arguments ra_name">vertex.[4]</td><td class = "ra_type">number</td><td>텍스처 좌표의 수직 성분.</td></tr><tr><td class = "arguments ra_name">vertex.[5] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 빨강 성분.</td></tr><tr><td class = "arguments ra_name">vertex.[6] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 녹색 성분입니다.</td></tr><tr><td class = "arguments ra_name">vertex.[7] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 청색 성분입니다.</td></tr><tr><td class = "arguments ra_name">vertex.[8] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>정점의 색의 알파 성분입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setVertexAttribute" name = "Mesh:setVertexAttribute"><span>Mesh:</span><wbr>setVertexAttribute</a></p><p class = "function_description">Mesh의 정점 내의 특정 속성의 속성을 설정합니다.<br /><br /><a href="#love.graphics.newMesh">love.graphics.newMesh</a>에 지정된 사용자 정의 정점 형식이없는 메쉬는 첫 번째 속성으로 위치를, 두 번째 속성으로 텍스처 좌표를, 세 번째 속성으로 색상을 갖습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertexAttribute( <span class = "arguments">vertexindex</span>, <span class = "arguments">attributeindex</span>, <span class = "arguments">value1</span>, <span class = "arguments">value2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">vertexindex</td><td class = "ra_type">number</td><td>수정되는 정점의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">attributeindex</td><td class = "ra_type">number</td><td>수정되는 정점 내의 속성의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">value1</td><td class = "ra_type">number</td><td>특성의 첫 번째 구성 요소 값입니다.</td></tr><tr><td class = "arguments ra_name">value2</td><td class = "ra_type">number</td><td>속성의 두 번째 구성 요소 값입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 정점 속성 구성 요소.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setVertexMap" name = "Mesh:setVertexMap"><span>Mesh:</span><wbr>setVertexMap</a></p><p class = "function_description">Mesh의 정점지도를 설정합니다. 정점 맵은 메쉬를 그릴 때 정점이 사용되는 순서를 설명합니다. 꼭짓점, 정점지도 및 메쉬 그리기 모드가 함께 작동하여 화면에 정확히 무엇이 표시되는지 결정합니다.<br /><br />버텍스 맵을 사용하면 실제 버텍스 매개 변수를 변경하거나 버텍스를 복제하지 않고 드로잉 할 때 버텍스를 재정렬하거나 재사용 할 수 있습니다. 다른 메쉬 그리기 모드와 결합 할 때 특히 유용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertexMap( <span class = "arguments">map</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">map</td><td class = "ra_type">table</td><td>묘화시에 사용하는 정점 인덱스의리스트를 포함한 테이블입니다. 값은 {1, <a href="#Mesh">Mesh</a> : getVertexCount ()} 범위 내에 있어야합니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertexMap( <span class = "arguments">vi1</span>, <span class = "arguments">vi2</span>, <span class = "arguments">vi3</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">vi1</td><td class = "ra_type">number</td><td>묘화시에 사용하는 최초의 정점의 인덱스입니다. {1, <a href="#Mesh">Mesh</a> : getVertexCount ()}의 범위 내에 있어야합니다.</td></tr><tr><td class = "arguments ra_name">vi2</td><td class = "ra_type">number</td><td>그리기 할 때 사용할 두 번째 꼭지점의 인덱스입니다.</td></tr><tr><td class = "arguments ra_name">vi3</td><td class = "ra_type">number</td><td>그리기 할 때 사용할 세 번째 꼭지점의 인덱스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Mesh:setVertices" name = "Mesh:setVertices"><span>Mesh:</span><wbr>setVertices</a></p><p class = "function_description">메쉬에있는 정점의 범위를 새로운 것으로 대체합니다. 메쉬의 총 정점 개수는 생성 된 후에 변경할 수 없습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertices( <span class = "arguments">vertices</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">vertices</td><td class = "ra_type">table</td><td>테이블은 {vertex, ...}의 형태로 각 꼭지점에 대한 꼭지점 정보 테이블로 채워져 있습니다. 각 꼭지점은 {attributecomponent, ...} 형태의 테이블입니다.</td></tr><tr><td class = "arguments ra_name">vertices.attributecomponent</td><td class = "ra_type">number</td><td>정점의 최초의 정점 속성의 최초의 컴퍼넌트입니다.</td></tr><tr><td class = "arguments ra_name">vertices....</td><td class = "ra_type">number</td><td>정점의 모든 정점 속성의 추가 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">vertices.startvertex <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>대체 할 첫 번째 정점의 인덱스입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Mesh:<wbr>setVertices( <span class = "arguments">vertices</span> )</span></span></p><p class = "variant_description">Sets the vertex components of a <a href="#Mesh">Mesh</a> that wasn't created with a custom vertex format.</p><table class = "ra_table"><tr><td class = "arguments ra_name">vertices</td><td class = "ra_type">table</td><td>테이블은 다음과 같이 각 정점에 대한 정점 정보 테이블로 채워집니다.</td></tr><tr><td class = "arguments ra_name">vertices.[1]</td><td class = "ra_type">number</td><td>x 축상의 정점의 위치.</td></tr><tr><td class = "arguments ra_name">vertices.[2]</td><td class = "ra_type">number</td><td>y 축상의 정점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">vertices.[3]</td><td class = "ra_type">number</td><td>텍스처 좌표의 수평 성분. 텍스처 좌표는 일반적으로 {0, 1}의 범위 내에 있지만 더 크거나 작을 수 있습니다 (WrapMode 참조).</td></tr><tr><td class = "arguments ra_name">vertices.[4]</td><td class = "ra_type">number</td><td>텍스처 좌표의 수직 성분. 텍스처 좌표는 일반적으로 {0, 1}의 범위 내에 있지만 더 크거나 작을 수 있습니다 (WrapMode 참조).</td></tr><tr><td class = "arguments ra_name">vertices.[5] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>붉은 색 구성 요소.</td></tr><tr><td class = "arguments ra_name">vertices.[6] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>초록의 색성분</td></tr><tr><td class = "arguments ra_name">vertices.[7] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>청색 성분.</td></tr><tr><td class = "arguments ra_name">vertices.[8] <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>알파 컬러 컴퍼넌트입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Image" name = "Image">Image</a></p><p class = "section_description">드로어 블 이미지 유형.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newImage">newImage</a>&emsp;파일 패스, FileData, ImageData, 또는 CompressedImageData로부터 새로운 Image를 작성해, 옵션으로 이미지의 밉맵을 생성 또는 지정합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getData">getData</a>&emsp;Image의 작성에 사용 된 원의 ImageData 또는 CompressedImageData를 취득합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getDimensions">getDimensions</a>&emsp;Image의 폭과 높이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getFlags">getFlags</a>&emsp;이미지가 생성 될 때 사용 된 플래그를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getHeight">getHeight</a>&emsp;Image의 높이를 돌려줍니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getWidth">getWidth</a>&emsp;Image의 폭을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:refresh">refresh</a>&emsp;이미지를 작성하기 위해서 사용 된 ImageData 또는 CompressedImageData로부터 이미지의 내용을 재로드합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getFilter">get</a><span class = "slash">/</span><a href="#Image:setFilter">setFilter</a>&emsp;이미지의 필터 모드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getMipmapFilter">get</a><span class = "slash">/</span><a href="#Image:setMipmapFilter">setMipmapFilter</a>&emsp;이미지의 밉맵 필터 모드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Image:<a href="#Image:getWrap">get</a><span class = "slash">/</span><a href="#Image:setWrap">setWrap</a>&emsp;이미지의 래핑 속성을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Texture">Texture</a>&emsp;텍스처를 나타내는 드로어 블 오브젝트의 슈퍼 클래스입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Image:getData" name = "Image:getData"><span>Image:</span><wbr>getData</a></p><p class = "function_description">Image의 작성에 사용 된 원의 ImageData 또는 CompressedImageData를 취득합니다.<br /><br />모든 이미지는 이미지를 만드는 데 사용 된 데이터에 대한 참조를 유지합니다. 데이터는 <a href="#love.window.setMode">love.window.setMode</a> 또는 Image : refresh가 호출 될 때 이미지를 새로 고치는 데 사용됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">data</span> = Image:<wbr>getData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">data</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>이미지가 압축되어 있지 않은 경우, <a href="#Image">Image</a>의 작성에 사용 된 원의 ImageData</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">data</span> = Image:<wbr>getData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">data</td><td class = "ra_type"><a href="#CompressedImageData">CompressedImageData</a></td><td>이미지가 압축 된 경우 이미지를 만드는 데 사용 된 원래의 CompressedImageData입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:getDimensions" name = "Image:getDimensions"><span>Image:</span><wbr>getDimensions</a></p><p class = "function_description">Image의 폭과 높이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = Image:<wbr>getDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>Image의 폭 (픽셀 단위)입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>Image의 높이 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:getFilter" name = "Image:getFilter"><span>Image:</span><wbr>getFilter</a></p><p class = "function_description">이미지의 필터 모드를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">mag</span> = Image:<wbr>getFilter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지를 축소 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">mag</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지를 확대 할 때 사용되는 필터 모드입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:getFlags" name = "Image:getFlags"><span>Image:</span><wbr>getFlags</a></p><p class = "function_description">이미지가 생성 될 때 사용 된 플래그를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">flags</span> = Image:<wbr>getFlags()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">flags</td><td class = "ra_type">table</td><td>ImageFlag 키가있는 테이블입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:getHeight" name = "Image:getHeight"><span>Image:</span><wbr>getHeight</a></p><p class = "function_description">Image의 높이를 돌려줍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = Image:<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>Image의 높이 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:getMipmapFilter" name = "Image:getMipmapFilter"><span>Image:</span><wbr>getMipmapFilter</a></p><p class = "function_description">Image의 밉맵 필터 모드를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mode</span>, <span class = "returns">sharpness</span> = Image:<wbr>getMipmapFilter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mode</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>밉맵 레벨간에 사용되는 필터 모드입니다. 밉맵 필터링이 활성화되어 있지 않으면 nil입니다.</td></tr><tr><td class = "returns ra_name">sharpness</td><td class = "ra_type">number</td><td>묘화시에, 이미지가 통상보다 밉맵 레벨을 많이 사용할지, 적게 사용 할지를 결정하기 위해서 사용되는 값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:getWidth" name = "Image:getWidth"><span>Image:</span><wbr>getWidth</a></p><p class = "function_description">Image의 폭을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = Image:<wbr>getWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>Image의 폭 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:getWrap" name = "Image:getWrap"><span>Image:</span><wbr>getWrap</a></p><p class = "function_description">Image의 래핑 속성을 가져옵니다.<br /><br />이 함수는 이미지에 대해 현재 설정된 가로 및 세로 래핑 모드를 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">horizontal</span>, <span class = "returns">vertical</span> = Image:<wbr>getWrap()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">horizontal</td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>이미지의 수평 랩핑 모드.</td></tr><tr><td class = "returns ra_name">vertical</td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>이미지의 수직 랩핑 모드.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:refresh" name = "Image:refresh"><span>Image:</span><wbr>refresh</a></p><p class = "function_description">이미지를 작성하기 위해서 사용 된 ImageData 또는 CompressedImageData로부터 이미지의 내용을 재로드합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Image:<wbr>refresh()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Image:<wbr>refresh( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">width</span>, <span class = "arguments">height</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>다시로드 할 이미지 내의 영역 왼쪽 위 모서리의 x 축입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>다시로드 할 이미지 내의 영역 왼쪽 위 모서리의 y 축입니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>다시로드 할 이미지 내 영역의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>이미지 내에서 다시로드 할 영역의 높이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:setFilter" name = "Image:setFilter"><span>Image:</span><wbr>setFilter</a></p><p class = "function_description">이미지의 필터 모드를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Image:<wbr>setFilter( <span class = "arguments">min</span>, <span class = "arguments">mag</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지 크기를 줄이는 방법.</td></tr><tr><td class = "arguments ra_name">mag <span class = "default">(min)</span></td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>이미지를 확대하는 방법.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:setMipmapFilter" name = "Image:setMipmapFilter"><span>Image:</span><wbr>setMipmapFilter</a></p><p class = "function_description">이미지의 밉맵 필터 모드를 설정합니다.<br /><br />밉 매핑은 축소 된 크기로 이미지를 그릴 때 유용합니다. 성능을 향상시키고 앨리어싱 문제를 줄일 수 있습니다.<br /><br />0.10.0 이후에서는 밉맵 필터가 적용되도록 mipmaps 플래그를 사용하여 이미지를 만들어야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Image:<wbr>setMipmapFilter( <span class = "arguments">filtermode</span>, <span class = "arguments">sharpness</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">filtermode</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>밉맵 레벨 사이에서 사용할 필터 모드입니다. "가장 가까운"은 종종 더 나은 성능을 제공합니다.</td></tr><tr><td class = "arguments ra_name">sharpness <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>양의 선명도 값을 지정하면 성능을 저하시키면서 이미지를보다 세부적인 밉맵 레벨로 사용할 수 있습니다. 음수 값은 그 반대입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Image:<wbr>setMipmapFilter()</span></span></p><p class = "variant_description">밉맵 필터링을 사용하지 않습니다.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Image:setWrap" name = "Image:setWrap"><span>Image:</span><wbr>setWrap</a></p><p class = "function_description">이미지의 래핑 속성을 설정합니다.<br /><br />이 함수는 이미지의 범위보다 큰 쿼드로 그릴 때 이미지가 반복되는 방식을 설정합니다. 이미지는 수평 및 수직 방향으로 클램프되거나 반복되도록 설정 될 수 있습니다. 클램프 된 이미지는 한 번만 나타나지만 반복되는 이미지는 쿼드에 공간이있는만큼 반복됩니다.<br /><br />이미지 범위보다 크고 반복 된 타일링을 사용하지 않는 쿼드를 사용하면 쿼드를 채우려는 이미지가 원하지 않는 시각 효과를 낼 수 있습니다. 이 경우 반복 할 모든 이미지에 대해 Image : getWrap ( "repeat", "repeat")을 설정하고 적절한 크기의 Quad를 사용하면 최상의 시각적 모양이됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Image:<wbr>setWrap( <span class = "arguments">horizontal</span>, <span class = "arguments">vertical</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">horizontal</td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>이미지의 수평 랩핑 모드.</td></tr><tr><td class = "arguments ra_name">vertical <span class = "default">(horizontal)</span></td><td class = "ra_type"><a href="#WrapMode">WrapMode</a></td><td>이미지의 수직 랩핑 모드.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#ParticleSystem" name = "ParticleSystem">ParticleSystem</a></p><p class = "section_description">화재와 같은 시원한 효과를 내기 위해 사용됩니다. 파티클 시스템은 love.graphics의 함수를 사용하여 스크린에 생성되고 그려집니다. 또한 방출 된 입자의 변경 사항을 보려면 업데이트 (dt) 콜백에서 업데이트해야합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newParticleSystem">newParticleSystem</a>&emsp;새 ParticleSystem을 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:clone">clone</a>&emsp;정지 상태의 ParticleSystem과 동일한 복사본을 만듭니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:emit">emit</a>&emsp;파티클 에미 터에서 파열 된 파티클을 방출합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getCount">getCount</a>&emsp;현재 시스템에있는 입자의 양을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:isActive">isActive</a>&emsp;입자 시스템이 입자를 방출하고 있는지 여부를 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:isPaused">isPaused</a>&emsp;파티클 시스템이 일시 중지되었는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:isStopped">isStopped</a>&emsp;파티클 시스템이 중지되었는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:moveTo">moveTo</a>&emsp;이미 터의 위치를 ​​이동합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:pause">pause</a>&emsp;파티클 이미 터를 일시 중지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:reset">reset</a>&emsp;파티클 이미 터를 재설정하고 기존 파티클을 제거하고 수명 카운터를 재설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getAreaSpread">get</a><span class = "slash">/</span><a href="#ParticleSystem:setAreaSpread">setAreaSpread</a>&emsp;파티클의 영역 기반 스폰 매개 변수를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getBufferSize">get</a><span class = "slash">/</span><a href="#ParticleSystem:setBufferSize">setBufferSize</a>&emsp;버퍼의 크기 (시스템에서 허용되는 최대 입자 수)를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getColors">get</a><span class = "slash">/</span><a href="#ParticleSystem:setColors">setColors</a>&emsp;입자 스프라이트에 적용 할 일련의 색상을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getDirection">get</a><span class = "slash">/</span><a href="#ParticleSystem:setDirection">setDirection</a>&emsp;입자가 방출 될 방향을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getEmissionRate">get</a><span class = "slash">/</span><a href="#ParticleSystem:setEmissionRate">setEmissionRate</a>&emsp;초당 방출되는 입자의 양을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getEmitterLifetime">get</a><span class = "slash">/</span><a href="#ParticleSystem:setEmitterLifetime">setEmitterLifetime</a>&emsp;입자 시스템이 입자를 방출하는 시간을 설정합니다 (-1이면 입자를 영원히 방출 함). </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getInsertMode">get</a><span class = "slash">/</span><a href="#ParticleSystem:setInsertMode">setInsertMode</a>&emsp;ParticleSystem이 새 입자를 추가 할 때 사용할 모드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getLinearAcceleration">get</a><span class = "slash">/</span><a href="#ParticleSystem:setLinearAcceleration">setLinearAcceleration</a>&emsp;입자의 선형 가속도 (x 축 및 y 축 가속도)를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getLinearDamping">get</a><span class = "slash">/</span><a href="#ParticleSystem:setLinearDamping">setLinearDamping</a>&emsp;입자의 선형 감쇠 (일정 감속) 양을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getOffset">get</a><span class = "slash">/</span><a href="#ParticleSystem:setOffset">setOffset</a>&emsp;입자 스프라이트가 회전하는 오프셋 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getParticleLifetime">get</a><span class = "slash">/</span><a href="#ParticleSystem:setParticleLifetime">setParticleLifetime</a>&emsp;입자의 수명을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getPosition">get</a><span class = "slash">/</span><a href="#ParticleSystem:setPosition">setPosition</a>&emsp;이미 터의 위치를 ​​설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getQuads">get</a><span class = "slash">/</span><a href="#ParticleSystem:setQuads">setQuads</a>&emsp;입자 스프라이트에 사용할 일련의 Quad를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getRadialAcceleration">get</a><span class = "slash">/</span><a href="#ParticleSystem:setRadialAcceleration">setRadialAcceleration</a>&emsp;반경 방향 가속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:hasRelativeRotation">has</a><span class = "slash">/</span><a href="#ParticleSystem:setRelativeRotation">setRelativeRotation</a>&emsp;입자 각도와 회전이 속도와 관련이 있는지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getRotation">get</a><span class = "slash">/</span><a href="#ParticleSystem:setRotation">setRotation</a>&emsp;파티클 생성시 이미지의 회전을 설정합니다 (라디안). </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getSizes">get</a><span class = "slash">/</span><a href="#ParticleSystem:setSizes">setSizes</a>&emsp;입자 스프라이트의 크기를 조절할 일련의 크기를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getSizeVariation">get</a><span class = "slash">/</span><a href="#ParticleSystem:setSizeVariation">setSizeVariation</a>&emsp;변동 정도를 설정합니다 (0은 변동 없음을 의미하고 1은 시작과 종료 사이의 전체 변동을 의미 함). </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getSpeed">get</a><span class = "slash">/</span><a href="#ParticleSystem:setSpeed">setSpeed</a>&emsp;입자의 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getSpin">get</a><span class = "slash">/</span><a href="#ParticleSystem:setSpin">setSpin</a>&emsp;스프라이트의 스핀을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getSpinVariation">get</a><span class = "slash">/</span><a href="#ParticleSystem:setSpinVariation">setSpinVariation</a>&emsp;변동 정도를 설정합니다 (0은 변동 없음을 의미하고 1은 시작과 종료 사이의 전체 변동을 의미 함). </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getSpread">get</a><span class = "slash">/</span><a href="#ParticleSystem:setSpread">setSpread</a>&emsp;시스템의 확산 정도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getTexture">get</a><span class = "slash">/</span><a href="#ParticleSystem:setTexture">setTexture</a>&emsp;출력 할 Image 또는 Canvas를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:getTangentialAcceleration">get</a><span class = "slash">/</span><a href="#ParticleSystem:setTangentialAcceleration">setTangentialAcceleration</a>&emsp;접선 방향 가속도 (입자의 방향에 수직 인 가속도)를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:start">start</a>&emsp;입자 이미 터를 시작합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:stop">stop</a>&emsp;파티클 이미 터를 중지하고 수명 카운터를 재설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ParticleSystem:<a href="#ParticleSystem:update">update</a>&emsp;파티클 시스템을 업데이트합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:clone" name = "ParticleSystem:clone"><span>ParticleSystem:</span><wbr>clone</a></p><p class = "function_description">정지 상태의 ParticleSystem과 동일한 복사본을 만듭니다.<br /><br />복제 된 ParticleSystem은 원래 ParticleSystem의 모든 설정 가능한 상태를 상속 받지만 초기화 된 상태로 정지됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">particlesystem</span> = ParticleSystem:<wbr>clone()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">particlesystem</td><td class = "ra_type"><a href="#ParticleSystem">ParticleSystem</a></td><td>이 ParticleSystem의 새로운 동일 복사본입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:emit" name = "ParticleSystem:emit"><span>ParticleSystem:</span><wbr>emit</a></p><p class = "function_description">파티클 에미 터에서 파열 된 파티클을 방출합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>emit( <span class = "arguments">numparticles</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">numparticles</td><td class = "ra_type">number</td><td>방출 할 입자의 양. 파티클 시스템의 최대 버퍼 크기에 도달하면 방사 입자 수는 잘립니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getCount" name = "ParticleSystem:getCount"><span>ParticleSystem:</span><wbr>getCount</a></p><p class = "function_description">현재 시스템에있는 입자의 양을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">count</span> = ParticleSystem:<wbr>getCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">count</td><td class = "ra_type">number</td><td>현재 활성 입자 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getAreaSpread" name = "ParticleSystem:getAreaSpread"><span>ParticleSystem:</span><wbr>getAreaSpread</a></p><p class = "function_description">파티클에 대한 영역 기반 스폰 매개 변수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">distribution</span>, <span class = "returns">dx</span>, <span class = "returns">dy</span> = ParticleSystem:<wbr>getAreaSpread()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">distribution</td><td class = "ra_type"><a href="#AreaSpreadDistribution">AreaSpreadDistribution</a></td><td>새로운 입자의 분포 유형.</td></tr><tr><td class = "returns ra_name">dx</td><td class = "ra_type">number</td><td>균일 한 분포를 위해 X 축을 따라 방사체로부터 최대 스폰 거리 또는 정규 분포를 위해 X 축을 따라 표준 편차.</td></tr><tr><td class = "returns ra_name">dy</td><td class = "ra_type">number</td><td>균일 한 분포를 위해 y 축을 따라 방사체로부터 최대 스폰 거리 또는 정규 분포를 위해 y 축을 따라 표준 편차.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getBufferSize" name = "ParticleSystem:getBufferSize"><span>ParticleSystem:</span><wbr>getBufferSize</a></p><p class = "function_description">버퍼의 사이즈 (시스템 내의 파티클의 최대 허용량)를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">buffer</span> = ParticleSystem:<wbr>getBufferSize()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">buffer</td><td class = "ra_type">number</td><td>버퍼 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getColors" name = "ParticleSystem:getColors"><span>ParticleSystem:</span><wbr>getColors</a></p><p class = "function_description">입자 스프라이트에 적용 할 일련의 색상을 가져옵니다. 입자 시스템은 입자의 수명 동안 각 색상 사이를 고르게 보간합니다. 이 기능이 효과를 발휘하려면 색 변조를 활성화해야합니다.<br /><br />인수는 원하는 RGBA 값의 구성 요소를 나타내는 네 개 그룹으로 전달됩니다. 하나 이상의 색상을 지정해야합니다. 최대 8 개를 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">r1</span>, <span class = "returns">g1</span>, <span class = "returns">b1</span>, <span class = "returns">a1</span>, <span class = "returns">r2</span>, <span class = "returns">g2</span>, <span class = "returns">b2</span>, <span class = "returns">a2</span>, <span class = "returns">...</span> = ParticleSystem:<wbr>getColors()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">r1</td><td class = "ra_type">number</td><td>첫 번째 색상, 빨간색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">g1</td><td class = "ra_type">number</td><td>첫 번째 색상, 녹색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">b1</td><td class = "ra_type">number</td><td>첫 번째 색상, 파란색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">a1</td><td class = "ra_type">number</td><td>첫 번째 색상, 알파 성분 (0-255).</td></tr><tr><td class = "returns ra_name">r2</td><td class = "ra_type">number</td><td>두 번째 색상, 빨간색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">g2</td><td class = "ra_type">number</td><td>두 번째 색상, 녹색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">b2</td><td class = "ra_type">number</td><td>두 번째 색상, 파란색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">a2</td><td class = "ra_type">number</td><td>두 번째 색상, 알파 성분 (0-255).</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>기타.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getDirection" name = "ParticleSystem:getDirection"><span>ParticleSystem:</span><wbr>getDirection</a></p><p class = "function_description">입자가 방출 될 방향을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">direction</span> = ParticleSystem:<wbr>getDirection()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">direction</td><td class = "ra_type">number</td><td>입자의 방향 (라디안)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getEmissionRate" name = "ParticleSystem:getEmissionRate"><span>ParticleSystem:</span><wbr>getEmissionRate</a></p><p class = "function_description">초당 방출되는 입자의 양을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rate</span> = ParticleSystem:<wbr>getEmissionRate()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rate</td><td class = "ra_type">number</td><td>초당 입자의 양.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getInsertMode" name = "ParticleSystem:getInsertMode"><span>ParticleSystem:</span><wbr>getInsertMode</a></p><p class = "function_description">ParticleSystem에서 새 입자를 추가 할 때 사용할 모드를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mode</span> = ParticleSystem:<wbr>getInsertMode()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mode</td><td class = "ra_type"><a href="#ParticleInsertMode">ParticleInsertMode</a></td><td>ParticleSystem이 새 입자를 추가 할 때 사용할 모드입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getLinearAcceleration" name = "ParticleSystem:getLinearAcceleration"><span>ParticleSystem:</span><wbr>getLinearAcceleration</a></p><p class = "function_description">입자의 선형 가속도 (x 축 및 y 축 가속도)를 가져옵니다.<br /><br />생성 된 모든 입자는 x, y 축과 xmax, ymax 사이에서 x 축과 y 축을 따라 가속됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">xmin</span>, <span class = "returns">ymin</span>, <span class = "returns">xmax</span>, <span class = "returns">ymax</span> = ParticleSystem:<wbr>getLinearAcceleration()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">xmin</td><td class = "ra_type">number</td><td>x 축을 따른 최소 가속도입니다.</td></tr><tr><td class = "returns ra_name">ymin</td><td class = "ra_type">number</td><td>y 축을 따른 최소 가속도입니다.</td></tr><tr><td class = "returns ra_name">xmax</td><td class = "ra_type">number</td><td>x 축을 따른 최대 가속도.</td></tr><tr><td class = "returns ra_name">ymax</td><td class = "ra_type">number</td><td>y 축을 따른 최대 가속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getLinearDamping" name = "ParticleSystem:getLinearDamping"><span>ParticleSystem:</span><wbr>getLinearDamping</a></p><p class = "function_description">입자의 선형 감쇠 (일정 감속) 양을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = ParticleSystem:<wbr>getLinearDamping()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>입자에 적용되는 최소 선형 감쇠량입니다.</td></tr><tr><td class = "returns ra_name">max</td><td class = "ra_type">number</td><td>입자에 적용되는 최대 선형 댐핑 량.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getEmitterLifetime" name = "ParticleSystem:getEmitterLifetime"><span>ParticleSystem:</span><wbr>getEmitterLifetime</a></p><p class = "function_description">입자 시스템에서 입자를 방출해야하는 시간을 가져옵니다 (-1이면 입자를 영원히 방출 함).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">life</span> = ParticleSystem:<wbr>getEmitterLifetime()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">life</td><td class = "ra_type">number</td><td>이미 터의 수명 (초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getOffset" name = "ParticleSystem:getOffset"><span>ParticleSystem:</span><wbr>getOffset</a></p><p class = "function_description">파티클 스프라이트가 회전하는 오프 위치를 가져옵니다. 이 기능을 사용하지 않으면 입자가 중심을 중심으로 회전합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = ParticleSystem:<wbr>getOffset()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>회전 꺼짐의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>회전 꺼짐의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getParticleLifetime" name = "ParticleSystem:getParticleLifetime"><span>ParticleSystem:</span><wbr>getParticleLifetime</a></p><p class = "function_description">입자의 수명을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = ParticleSystem:<wbr>getParticleLifetime()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>입자의 최소 수명 (초).</td></tr><tr><td class = "returns ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>입자의 최대 수명 (초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getQuads" name = "ParticleSystem:getQuads"><span>ParticleSystem:</span><wbr>getQuads</a></p><p class = "function_description">입자 스프라이트에 사용 된 Quad 시리즈를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">quads</span> = ParticleSystem:<wbr>getQuads()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">quads</td><td class = "ra_type">table</td><td>Quads가 포함 된 표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getPosition" name = "ParticleSystem:getPosition"><span>ParticleSystem:</span><wbr>getPosition</a></p><p class = "function_description">이미 터의 위치를 ​​가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = ParticleSystem:<wbr>getPosition()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따라 배치하십시오.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따라 배치하십시오.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getRadialAcceleration" name = "ParticleSystem:getRadialAcceleration"><span>ParticleSystem:</span><wbr>getRadialAcceleration</a></p><p class = "function_description">반경 방향 가속도를 얻습니다 (에미 터에서 멀어짐).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = ParticleSystem:<wbr>getRadialAcceleration()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>최소 가속도.</td></tr><tr><td class = "returns ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 가속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getRotation" name = "ParticleSystem:getRotation"><span>ParticleSystem:</span><wbr>getRotation</a></p><p class = "function_description">파티클 생성시 이미지 회전을 가져옵니다 (라디안).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = ParticleSystem:<wbr>getRotation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>최소 초기 각도 (라디안)입니다.</td></tr><tr><td class = "returns ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 초기 각도 (라디안)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getSizes" name = "ParticleSystem:getSizes"><span>ParticleSystem:</span><wbr>getSizes</a></p><p class = "function_description">입자 스프라이트의 크기를 조절하는 일련의 크기를 가져옵니다. 1.0은 정상 크기입니다. 입자 시스템은 입자의 수명 동안 각 크기를 균등하게 보간합니다.<br /><br />하나 이상의 크기를 지정해야합니다. 최대 8 개를 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">size1</span>, <span class = "returns">size2</span>, <span class = "returns">...</span> = ParticleSystem:<wbr>getSizes()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">size1</td><td class = "ra_type">number</td><td>첫 번째 크기.</td></tr><tr><td class = "returns ra_name">size2</td><td class = "ra_type">number</td><td>두 번째 크기.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>기타.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getSizeVariation" name = "ParticleSystem:getSizeVariation"><span>ParticleSystem:</span><wbr>getSizeVariation</a></p><p class = "function_description">편차의 정도를 취득합니다 (0은 편차 없음을 의미하고 1은 시작과 끝 사이의 전체 편차를 의미 함).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">variation</span> = ParticleSystem:<wbr>getSizeVariation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">variation</td><td class = "ra_type">number</td><td>변이의 정도 (0은 변이가 없음을 의미하고 1은 시작과 끝 사이에 완전한 변이를 의미 함).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getSpeed" name = "ParticleSystem:getSpeed"><span>ParticleSystem:</span><wbr>getSpeed</a></p><p class = "function_description">입자의 속도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = ParticleSystem:<wbr>getSpeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>입자의 최소 선형 속도입니다.</td></tr><tr><td class = "returns ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>입자의 최대 선 속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getSpin" name = "ParticleSystem:getSpin"><span>ParticleSystem:</span><wbr>getSpin</a></p><p class = "function_description">스프라이트의 스핀을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = ParticleSystem:<wbr>getSpin()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>최소 스핀 (초당 라디안).</td></tr><tr><td class = "returns ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 스핀 (초당 라디안).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getSpinVariation" name = "ParticleSystem:getSpinVariation"><span>ParticleSystem:</span><wbr>getSpinVariation</a></p><p class = "function_description">편차의 정도를 취득합니다 (0은 편차 없음을 의미하고 1은 시작과 끝 사이의 전체 편차를 의미 함).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">variation</span> = ParticleSystem:<wbr>getSpinVariation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">variation</td><td class = "ra_type">number</td><td>변이의 정도 (0은 변이가 없음을 의미하고 1은 시작과 끝 사이에 완전한 변이를 의미 함).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getSpread" name = "ParticleSystem:getSpread"><span>ParticleSystem:</span><wbr>getSpread</a></p><p class = "function_description">시스템의 확산 정도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">spread</span> = ParticleSystem:<wbr>getSpread()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">spread</td><td class = "ra_type">number</td><td>스프레드의 양 (라디안)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getTexture" name = "ParticleSystem:getTexture"><span>ParticleSystem:</span><wbr>getTexture</a></p><p class = "function_description">발행 할 Image 또는 Canvas를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">texture</span> = ParticleSystem:<wbr>getTexture()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>입자에 사용할 이미지 또는 캔버스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:getTangentialAcceleration" name = "ParticleSystem:getTangentialAcceleration"><span>ParticleSystem:</span><wbr>getTangentialAcceleration</a></p><p class = "function_description">접선 방향 가속도 (입자 방향에 수직 인 가속도)를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">max</span> = ParticleSystem:<wbr>getTangentialAcceleration()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type">number</td><td>최소 가속도.</td></tr><tr><td class = "returns ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 가속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:hasRelativeRotation" name = "ParticleSystem:hasRelativeRotation"><span>ParticleSystem:</span><wbr>hasRelativeRotation</a></p><p class = "function_description">입자 각도와 회전이 속도에 비례하는지 여부를 가져옵니다. 활성화 된 경우 입자는 속도의 각도에 정렬되고 해당 각도를 기준으로 회전합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = ParticleSystem:<wbr>hasRelativeRotation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>상대적인 입자 회전이 활성화되어 있으면 true이고, 비활성화되어 있으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:isActive" name = "ParticleSystem:isActive"><span>ParticleSystem:</span><wbr>isActive</a></p><p class = "function_description">입자 시스템이 입자를 방출하고 있는지 여부를 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">active</span> = ParticleSystem:<wbr>isActive()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">active</td><td class = "ra_type">boolean</td><td>시스템이 액티브 한 경우는 true, 그렇지 않은 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:isPaused" name = "ParticleSystem:isPaused"><span>ParticleSystem:</span><wbr>isPaused</a></p><p class = "function_description">파티클 시스템이 일시 중지되었는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">paused</span> = ParticleSystem:<wbr>isPaused()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">paused</td><td class = "ra_type">boolean</td><td>시스템이 일시 정지되어 있으면 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:isStopped" name = "ParticleSystem:isStopped"><span>ParticleSystem:</span><wbr>isStopped</a></p><p class = "function_description">파티클 시스템이 중지되었는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">stopped</span> = ParticleSystem:<wbr>isStopped()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">stopped</td><td class = "ra_type">boolean</td><td>시스템이 정지하고있는 경우는 true, 그렇지 않은 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:moveTo" name = "ParticleSystem:moveTo"><span>ParticleSystem:</span><wbr>moveTo</a></p><p class = "function_description">이미 터의 위치를 ​​이동합니다. 이렇게하면 매 프레임마다 ParticleSystem : setPosition이 사용되는 경우보다 부드러운 파티클 생성 동작이 발생합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>moveTo( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따라 배치하십시오.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따라 배치하십시오.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:pause" name = "ParticleSystem:pause"><span>ParticleSystem:</span><wbr>pause</a></p><p class = "function_description">파티클 이미 터를 일시 중지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>pause()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:reset" name = "ParticleSystem:reset"><span>ParticleSystem:</span><wbr>reset</a></p><p class = "function_description">파티클 이미 터를 재설정하고 기존 파티클을 제거하고 수명 카운터를 재설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>reset()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setAreaSpread" name = "ParticleSystem:setAreaSpread"><span>ParticleSystem:</span><wbr>setAreaSpread</a></p><p class = "function_description">파티클의 영역 기반 스폰 매개 변수를 설정합니다. 새로 생성 된 입자는이 함수의 매개 변수를 기반으로 이미 터 주변 영역에 스폰됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setAreaSpread( <span class = "arguments">distribution</span>, <span class = "arguments">dx</span>, <span class = "arguments">dy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">distribution</td><td class = "ra_type"><a href="#AreaSpreadDistribution">AreaSpreadDistribution</a></td><td>새로운 입자의 분포 유형.</td></tr><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>균일 한 분포를 위해 X 축을 따라 방사체로부터 최대 스폰 거리 또는 정규 분포를 위해 X 축을 따라 표준 편차.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>균일 한 분포를 위해 y 축을 따라 방사체로부터 최대 스폰 거리 또는 정규 분포를 위해 y 축을 따라 표준 편차.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setBufferSize" name = "ParticleSystem:setBufferSize"><span>ParticleSystem:</span><wbr>setBufferSize</a></p><p class = "function_description">버퍼의 크기 (시스템에서 허용되는 최대 입자 수)를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setBufferSize( <span class = "arguments">buffer</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">buffer</td><td class = "ra_type">number</td><td>버퍼 크기.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setColors" name = "ParticleSystem:setColors"><span>ParticleSystem:</span><wbr>setColors</a></p><p class = "function_description">입자 스프라이트에 적용 할 일련의 색상을 설정합니다. 입자 시스템은 입자의 수명 동안 각 색상 사이를 고르게 보간합니다. 이 기능이 효과를 발휘하려면 색 변조를 활성화해야합니다.<br /><br />인수는 원하는 RGBA 값의 구성 요소를 나타내는 네 개 그룹으로 전달됩니다. 하나 이상의 색상을 지정해야합니다. 최대 8 개를 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setColors( <span class = "arguments">r1</span>, <span class = "arguments">g1</span>, <span class = "arguments">b1</span>, <span class = "arguments">a1</span>, <span class = "arguments">r2</span>, <span class = "arguments">g2</span>, <span class = "arguments">b2</span>, <span class = "arguments">a2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">r1</td><td class = "ra_type">number</td><td>첫 번째 색상, 빨간색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">g1</td><td class = "ra_type">number</td><td>첫 번째 색상, 녹색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">b1</td><td class = "ra_type">number</td><td>첫 번째 색상, 파란색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">a1</td><td class = "ra_type">number</td><td>첫 번째 색상, 알파 성분 (0-255).</td></tr><tr><td class = "arguments ra_name">r2</td><td class = "ra_type">number</td><td>두 번째 색상, 빨간색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">g2</td><td class = "ra_type">number</td><td>두 번째 색상, 녹색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">b2</td><td class = "ra_type">number</td><td>두 번째 색상, 파란색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">a2</td><td class = "ra_type">number</td><td>두 번째 색상, 알파 성분 (0-255).</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>기타.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setDirection" name = "ParticleSystem:setDirection"><span>ParticleSystem:</span><wbr>setDirection</a></p><p class = "function_description">입자가 방출 될 방향을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setDirection( <span class = "arguments">direction</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">direction</td><td class = "ra_type">number</td><td>입자의 방향 (라디안)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setEmissionRate" name = "ParticleSystem:setEmissionRate"><span>ParticleSystem:</span><wbr>setEmissionRate</a></p><p class = "function_description">초당 방출되는 입자의 양을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setEmissionRate( <span class = "arguments">rate</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">rate</td><td class = "ra_type">number</td><td>초당 입자의 양.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setEmitterLifetime" name = "ParticleSystem:setEmitterLifetime"><span>ParticleSystem:</span><wbr>setEmitterLifetime</a></p><p class = "function_description">입자 시스템이 입자를 방출하는 시간을 설정합니다 (-1이면 입자를 영원히 방출 함).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setEmitterLifetime( <span class = "arguments">life</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">life</td><td class = "ra_type">number</td><td>이미 터의 수명 (초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setInsertMode" name = "ParticleSystem:setInsertMode"><span>ParticleSystem:</span><wbr>setInsertMode</a></p><p class = "function_description">ParticleSystem이 새 입자를 추가 할 때 사용할 모드를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setInsertMode( <span class = "arguments">mode</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mode</td><td class = "ra_type"><a href="#ParticleInsertMode">ParticleInsertMode</a></td><td>ParticleSystem이 새 입자를 추가 할 때 사용할 모드입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setLinearAcceleration" name = "ParticleSystem:setLinearAcceleration"><span>ParticleSystem:</span><wbr>setLinearAcceleration</a></p><p class = "function_description">입자의 선형 가속도 (x 축 및 y 축 가속도)를 설정합니다.<br /><br />생성 된 모든 입자는 x, y 축과 xmax, ymax 사이에서 x 축과 y 축을 따라 가속됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setLinearAcceleration( <span class = "arguments">xmin</span>, <span class = "arguments">ymin</span>, <span class = "arguments">xmax</span>, <span class = "arguments">ymax</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">xmin</td><td class = "ra_type">number</td><td>x 축을 따른 최소 가속도입니다.</td></tr><tr><td class = "arguments ra_name">ymin <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>y 축을 따른 최소 가속도입니다.</td></tr><tr><td class = "arguments ra_name">xmax <span class = "default">(xmin)</span></td><td class = "ra_type">number</td><td>x 축을 따른 최대 가속도.</td></tr><tr><td class = "arguments ra_name">ymax <span class = "default">(ymin)</span></td><td class = "ra_type">number</td><td>y 축을 따른 최대 가속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setLinearDamping" name = "ParticleSystem:setLinearDamping"><span>ParticleSystem:</span><wbr>setLinearDamping</a></p><p class = "function_description">입자의 선형 감쇠 (일정 감속) 양을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setLinearDamping( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>입자에 적용되는 최소 선형 감쇠량입니다.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>입자에 적용되는 최대 선형 댐핑 량.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setOffset" name = "ParticleSystem:setOffset"><span>ParticleSystem:</span><wbr>setOffset</a></p><p class = "function_description">입자 스프라이트가 회전하는 오프셋 위치를 설정합니다. 이 기능을 사용하지 않으면 입자가 중심을 중심으로 회전합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setOffset( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>회전 오프셋의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>회전 오프셋의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setParticleLifetime" name = "ParticleSystem:setParticleLifetime"><span>ParticleSystem:</span><wbr>setParticleLifetime</a></p><p class = "function_description">입자의 수명을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setParticleLifetime( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>입자의 최소 수명 (초).</td></tr><tr><td class = "arguments ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>입자의 최대 수명 (초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setPosition" name = "ParticleSystem:setPosition"><span>ParticleSystem:</span><wbr>setPosition</a></p><p class = "function_description">이미 터의 위치를 ​​설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setPosition( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따라 배치하십시오.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따라 배치하십시오.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setQuads" name = "ParticleSystem:setQuads"><span>ParticleSystem:</span><wbr>setQuads</a></p><p class = "function_description">입자 스프라이트에 사용할 일련의 Quad를 설정합니다. 파티클은 입자의 현재 수명을 기준으로 목록에서 쿼드를 선택하므로 ParticleSystems에서 애니메이션 스프라이트 시트를 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setQuads( <span class = "arguments">quad1</span>, <span class = "arguments">quad2</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">quad1</td><td class = "ra_type"><a href="#Quad">Quad</a></td><td>첫 번째 쿼드를 사용합니다.</td></tr><tr><td class = "arguments ra_name">quad2</td><td class = "ra_type"><a href="#Quad">Quad</a></td><td>사용할 두 번째 쿼드입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setQuads( <span class = "arguments">quads</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">quads</td><td class = "ra_type">table</td><td>사용할 쿼드가 포함 된 테이블입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setRadialAcceleration" name = "ParticleSystem:setRadialAcceleration"><span>ParticleSystem:</span><wbr>setRadialAcceleration</a></p><p class = "function_description">반경 방향 가속도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setRadialAcceleration( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>최소 가속도.</td></tr><tr><td class = "arguments ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 가속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setRelativeRotation" name = "ParticleSystem:setRelativeRotation"><span>ParticleSystem:</span><wbr>setRelativeRotation</a></p><p class = "function_description">입자 각도와 회전이 속도와 관련이 있는지 여부를 설정합니다. 활성화 된 경우 입자는 속도의 각도에 정렬되고 해당 각도를 기준으로 회전합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setRelativeRotation( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>상대 입자 회전을 활성화하려면 true이고, 비활성화하려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setRotation" name = "ParticleSystem:setRotation"><span>ParticleSystem:</span><wbr>setRotation</a></p><p class = "function_description">파티클 생성시 이미지의 회전을 설정합니다 (라디안).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setRotation( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>최소 초기 각도 (라디안)입니다.</td></tr><tr><td class = "arguments ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 초기 각도 (라디안)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setSizes" name = "ParticleSystem:setSizes"><span>ParticleSystem:</span><wbr>setSizes</a></p><p class = "function_description">입자 스프라이트의 크기를 조절할 일련의 크기를 설정합니다. 1.0은 정상 크기입니다. 입자 시스템은 입자의 수명 동안 각 크기를 균등하게 보간합니다.<br /><br />하나 이상의 크기를 지정해야합니다. 최대 8 개를 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setSizes( <span class = "arguments">size1</span>, <span class = "arguments">size2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">size1</td><td class = "ra_type">number</td><td>첫 번째 크기.</td></tr><tr><td class = "arguments ra_name">size2</td><td class = "ra_type">number</td><td>두 번째 크기.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>기타.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setSizeVariation" name = "ParticleSystem:setSizeVariation"><span>ParticleSystem:</span><wbr>setSizeVariation</a></p><p class = "function_description">변동 정도를 설정합니다 (0은 변동 없음을 의미하고 1은 시작과 종료 사이의 전체 변동을 의미 함).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setSizeVariation( <span class = "arguments">variation</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">variation</td><td class = "ra_type">number</td><td>변이의 정도 (0은 변이가 없음을 의미하고 1은 시작과 끝 사이에 완전한 변이를 의미 함).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setSpeed" name = "ParticleSystem:setSpeed"><span>ParticleSystem:</span><wbr>setSpeed</a></p><p class = "function_description">입자의 속도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setSpeed( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>입자의 최소 선형 속도입니다.</td></tr><tr><td class = "arguments ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>입자의 최대 선 속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setSpin" name = "ParticleSystem:setSpin"><span>ParticleSystem:</span><wbr>setSpin</a></p><p class = "function_description">스프라이트의 스핀을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setSpin( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>최소 스핀 (초당 라디안).</td></tr><tr><td class = "arguments ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 스핀 (초당 라디안).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setSpinVariation" name = "ParticleSystem:setSpinVariation"><span>ParticleSystem:</span><wbr>setSpinVariation</a></p><p class = "function_description">변동 정도를 설정합니다 (0은 변동 없음을 의미하고 1은 시작과 종료 사이의 전체 변동을 의미 함).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setSpinVariation( <span class = "arguments">variation</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">variation</td><td class = "ra_type">number</td><td>변이의 정도 (0은 변이가 없음을 의미하고 1은 시작과 끝 사이에 완전한 변이를 의미 함).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setSpread" name = "ParticleSystem:setSpread"><span>ParticleSystem:</span><wbr>setSpread</a></p><p class = "function_description">시스템의 확산 정도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setSpread( <span class = "arguments">spread</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">spread</td><td class = "ra_type">number</td><td>스프레드의 양 (라디안)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setTexture" name = "ParticleSystem:setTexture"><span>ParticleSystem:</span><wbr>setTexture</a></p><p class = "function_description">출력 할 Image 또는 Canvas를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setTexture( <span class = "arguments">texture</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>입자에 사용할 이미지 또는 캔버스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:setTangentialAcceleration" name = "ParticleSystem:setTangentialAcceleration"><span>ParticleSystem:</span><wbr>setTangentialAcceleration</a></p><p class = "function_description">접선 방향 가속도 (입자의 방향에 수직 인 가속도)를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>setTangentialAcceleration( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>최소 가속도.</td></tr><tr><td class = "arguments ra_name">max <span class = "default">(min)</span></td><td class = "ra_type">number</td><td>최대 가속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:start" name = "ParticleSystem:start"><span>ParticleSystem:</span><wbr>start</a></p><p class = "function_description">입자 이미 터를 시작합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>start()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:stop" name = "ParticleSystem:stop"><span>ParticleSystem:</span><wbr>stop</a></p><p class = "function_description">파티클 이미 터를 중지하고 수명 카운터를 재설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>stop()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#ParticleSystem:update" name = "ParticleSystem:update"><span>ParticleSystem:</span><wbr>update</a></p><p class = "function_description">파티클 시스템을 업데이트합니다. 움직이고, 창조하고 죽이기.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ParticleSystem:<wbr>update( <span class = "arguments">dt</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">dt</td><td class = "ra_type">number</td><td>마지막 프레임 이후의 시간 (초).</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Quad" name = "Quad">Quad</a></p><p class = "section_description">텍스처 좌표 정보가있는 사변형 (4면과 4 개의 모서리가있는 다각형)입니다.<br /><br />사분면은 그릴 텍스처의 일부를 선택하는 데 사용할 수 있습니다. 이 방법으로 하나의 커다란 텍스처 아트라스를로드 한 다음 하위 이미지로 분할 할 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newQuad">newQuad</a>&emsp;새 쿼드를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Quad:<a href="#Quad:getTextureDimensions">getTextureDimensions</a>&emsp;love.graphics.newQuad에 처음 지정된 참조 텍스처 크기를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Quad:<a href="#Quad:getViewport">get</a><span class = "slash">/</span><a href="#Quad:setViewport">setViewport</a>&emsp;뷰포트에 따라 텍스처 좌표를 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Quad:getTextureDimensions" name = "Quad:getTextureDimensions"><span>Quad:</span><wbr>getTextureDimensions</a></p><p class = "function_description"><a href="#love.graphics.newQuad">love.graphics.newQuad</a>에 처음 지정된 참조 텍스처 크기를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">sw</span>, <span class = "returns">sh</span> = Quad:<wbr>getTextureDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">sw</td><td class = "ra_type">number</td><td>쿼드에 사용되는 텍스처 폭입니다.</td></tr><tr><td class = "returns ra_name">sh</td><td class = "ra_type">number</td><td>쿼드에서 사용하는 텍스처 높이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Quad:getViewport" name = "Quad:getViewport"><span>Quad:</span><wbr>getViewport</a></p><p class = "function_description">이 Quad의 현재 뷰포트를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">w</span>, <span class = "returns">h</span> = Quad:<wbr>getViewport()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>x 축을 기준으로 한 좌상단입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따라 오른쪽 상단 모서리입니다.</td></tr><tr><td class = "returns ra_name">w</td><td class = "ra_type">number</td><td>뷰포트의 폭입니다.</td></tr><tr><td class = "returns ra_name">h</td><td class = "ra_type">number</td><td>뷰포트의 높이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Quad:setViewport" name = "Quad:setViewport"><span>Quad:</span><wbr>setViewport</a></p><p class = "function_description">뷰포트에 따라 텍스처 좌표를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Quad:<wbr>setViewport( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">w</span>, <span class = "arguments">h</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 기준으로 한 좌상단입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따라 오른쪽 상단 모서리입니다.</td></tr><tr><td class = "arguments ra_name">w</td><td class = "ra_type">number</td><td>뷰포트의 폭입니다.</td></tr><tr><td class = "arguments ra_name">h</td><td class = "ra_type">number</td><td>뷰포트의 높이입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Shader" name = "Shader">Shader</a></p><p class = "section_description">셰이더는 고급 하드웨어 가속 픽셀 또는 버텍스 조작에 사용됩니다. 이러한 효과는 GLSL (OpenGL Shading Language)을 기반으로 한 언어로 작성되며, 코딩을 쉽게하기 위해 몇 가지 사항이 단순화되었습니다.<br /><br />셰이더의 잠재적 인 용도로는 HDR / 블룸, 모션 블러, 그레이 스케일 / 인버트 / 세피아 / 모든 종류의 컬러 효과, 반사 / 굴절, 왜곡, 범프 매핑 등이 있습니다. 다음은 기본 쉐이더 모음이며 배우기에 좋은 시작점입니다. https://github.com/vrld/shine</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newShader">newShader</a>&emsp;하드웨어 가속화 된 버텍스 및 픽셀 효과를위한 새로운 Shader 객체를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Shader:<a href="#Shader:send">send</a>&emsp;하나 이상의 값을 셰이더 내부의 특수 (유니폼) 변수에 보냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shader:<a href="#Shader:sendColor">sendColor</a>&emsp;셰이더 내부의 특수한 (extern / uniform) vec3 또는 vec4 변수에 하나 이상의 색상을 보냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shader:<a href="#Shader:getExternVariable">getExternVariable</a>&emsp;셰이더에서 'extern'( 'uniform') 변수에 대한 정보를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shader:<a href="#Shader:getWarnings">getWarnings</a>&emsp;셰이더 코드 컴파일시 경고 및 오류 메시지를 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Shader:getExternVariable" name = "Shader:getExternVariable"><span>Shader:</span><wbr>getExternVariable</a></p><p class = "function_description">셰이더에서 'extern'( 'uniform') 변수에 대한 정보를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">type</span>, <span class = "returns">components</span>, <span class = "returns">arrayelements</span> = Shader:<wbr>getExternVariable( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">type</td><td class = "ra_type">ShaderVariableType</td><td>변수의 기본 유형입니다.</td></tr><tr><td class = "returns ra_name">components</td><td class = "ra_type">number</td><td>변수의 구성 요소 수 (예 : vec2 또는 mat2의 경우 2)</td></tr><tr><td class = "returns ra_name">arrayelements</td><td class = "ra_type">number</td><td>변수가 배열이면 배열의 요소 수, 그렇지 않으면 1입니다.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>extern 변수의 이름입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shader:getWarnings" name = "Shader:getWarnings"><span>Shader:</span><wbr>getWarnings</a></p><p class = "function_description">셰이더 코드 컴파일시 경고 및 오류 메시지를 가져옵니다. 이것은 그래픽 하드웨어가 좋아하지 않는 것이 있다면 쉐이더를 디버깅하는 데 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">warnings</span> = Shader:<wbr>getWarnings()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">warnings</td><td class = "ra_type">string</td><td>경고 메시지 (있는 경우).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shader:send" name = "Shader:send"><span>Shader:</span><wbr>send</a></p><p class = "function_description">하나 이상의 값을 셰이더 내부의 특수 (유니폼) 변수에 보냅니다. 균일 변수는 uniform 또는 extern 키워드를 사용하여 표시해야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Shader:<wbr>send( <span class = "arguments">name</span>, <span class = "arguments">number</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>셰이더에 보낼 번호의 이름입니다.</td></tr><tr><td class = "arguments ra_name">number</td><td class = "ra_type">number</td><td>uniform 변수에 저장하기 위해 보낼 번호입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>uniform 변수가 배열 인 경우 보낼 추가 숫자입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Shader:<wbr>send( <span class = "arguments">name</span>, <span class = "arguments">vector</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>셰이더에 보낼 벡터의 이름입니다.</td></tr><tr><td class = "arguments ra_name">vector</td><td class = "ra_type">table</td><td>벡터로 유니폼 변수에 보낼 숫자입니다. 테이블의 요소 수에 따라 벡터의 유형이 결정됩니다 (예 : 두 개의 숫자 -&gt; vec2). 최소 2 개에서 최대 4 개까지 숫자를 사용할 수 있습니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">table</td><td>uniform 변수가 배열 인 경우 보낼 추가 벡터입니다. 모든 벡터는 동일한 크기 (예 : vec3 만)이어야합니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Shader:<wbr>send( <span class = "arguments">name</span>, <span class = "arguments">matrix</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>셰이더에 보낼 행렬의 이름입니다.</td></tr><tr><td class = "arguments ra_name">matrix</td><td class = "ra_type">table</td><td>2x2, 3x3 또는 4x4 행렬을 사용하여 단일 변수에 전송하십시오. 표 양식 사용 : {{a, b, c, d}, {e, f, g, h}, ...}.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">table</td><td>균일 한 배열에 저장하는 행렬과 같은 유형의 추가 행렬입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Shader:<wbr>send( <span class = "arguments">name</span>, <span class = "arguments">texture</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>셰이더에 보낼 텍스처의 이름입니다.</td></tr><tr><td class = "arguments ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>유니폼 변수에 보낼 텍스처 (이미지 또는 캔버스).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Shader:<wbr>send( <span class = "arguments">name</span>, <span class = "arguments">boolean</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>셰이더에 보낼 부울 값입니다.</td></tr><tr><td class = "arguments ra_name">boolean</td><td class = "ra_type">boolean</td><td>uniform 변수에 저장하기 위해 보낼 부울입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">boolean</td><td>uniform 변수가 배열 인 경우 보낼 추가 부울입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shader:sendColor" name = "Shader:sendColor"><span>Shader:</span><wbr>sendColor</a></p><p class = "function_description">셰이더 내부의 특수한 (extern / uniform) vec3 또는 vec4 변수에 하나 이상의 색상을 보냅니다. Shader : send와는 달리 색상 구성 요소는 {0, 255} 범위 내에 있어야합니다. 글로벌 감마 보정을 사용하면 색상이 감마 보정됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Shader:<wbr>sendColor( <span class = "arguments">name</span>, <span class = "arguments">color</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>셰이더에서 보낼 색상 extern 변수의 이름입니다.</td></tr><tr><td class = "arguments ra_name">color</td><td class = "ra_type">table</td><td>빨강, 초록, 파랑 ​​및 선택적 알파 색상 구성 요소가 {0, 255} 범위에있는 테이블로 벡터로 외부로 보냅니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">table</td><td>extern이 배열 인 경우 보낼 추가 색상입니다. 모든 색상은 동일한 크기 여야합니다 (예 : vec3 만 해당).</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#SpriteBatch" name = "SpriteBatch">SpriteBatch</a></p><p class = "section_description">단일 이미지를 사용하여 <a href="#love.graphics.draw">love.graphics.draw</a>를 한 번 호출하면 이미지의 동일한 복사본을 여러 개 그릴 수 있습니다. 예를 들어, 단일 배경 이미지의 반복 복사본을 그리는 데 사용할 수 있습니다.<br /><br />SpriteBatch는 기본 이미지가 <a href="#Texture">Texture</a> Atlas (많은 독립 이미지가 포함 된 단일 이미지 파일) 인 경우 더욱 유용 할 수 있습니다. 일괄 처리에 <a href="#Quad">Quad</a>를 추가함으로써 아틀라스 내의 다른 하위 이미지를 그릴 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newSpriteBatch">newSpriteBatch</a>&emsp;새 SpriteBatch 객체를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:add">add</a>&emsp;배치에 스프라이트를 추가하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:attachAttribute">attachAttribute</a>&emsp;그리기 할 때 사용하기 위해 메쉬의 정점 별 속성을이 SpriteBatch에 연결합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:clear">clear</a>&emsp;버퍼에서 모든 스프라이트를 제거합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:flush">flush</a>&emsp;배치의 모든 새롭고 수정 된 스프라이트 데이터를 즉시 그래픽 카드로 보냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:getCount">getCount</a>&emsp;현재 SpriteBatch에있는 스프라이트의 양을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:set">set</a>&emsp;배치에서 스프라이트를 변경합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:getBufferSize">get</a><span class = "slash">/</span><a href="#SpriteBatch:setBufferSize">setBufferSize</a>&emsp;SpriteBatch가 보유 할 수있는 최대 스프라이트 수를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:getColor">get</a><span class = "slash">/</span><a href="#SpriteBatch:setColor">setColor</a>&emsp;다음 번 추가 및 설정 작업에 사용할 색상을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SpriteBatch:<a href="#SpriteBatch:getTexture">get</a><span class = "slash">/</span><a href="#SpriteBatch:setTexture">setTexture</a>&emsp;스프라이트에 사용 된 이미지 또는 캔버스를 대체합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:add" name = "SpriteBatch:add"><span>SpriteBatch:</span><wbr>add</a></p><p class = "function_description">배치에 스프라이트를 추가하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">id</span> = SpriteBatch:<wbr>add( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">id</td><td class = "ra_type">number</td><td>추가 된 스프라이트에 대한 식별자입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>물체를 그리는 위치 (x 축)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>오브젝트를 그리는 위치입니다 (y 축).</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축).</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축).</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축).</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축).</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">id</span> = SpriteBatch:<wbr>add( <span class = "arguments">quad</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">id</td><td class = "ra_type">number</td><td>추가 된 스프라이트에 대한 식별자입니다.</td></tr><tr><td class = "arguments ra_name">quad</td><td class = "ra_type"><a href="#Quad">Quad</a></td><td>추가 할 쿼드.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>물체를 그리는 위치 (x 축)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>오브젝트를 그리는 위치입니다 (y 축).</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축).</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축).</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축).</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축).</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:attachAttribute" name = "SpriteBatch:attachAttribute"><span>SpriteBatch:</span><wbr>attachAttribute</a></p><p class = "function_description">그리기 할 때 사용하기 위해 메쉬의 정점 별 속성을이 SpriteBatch에 연결합니다. 이것은 쉐이더와 결합하여 SpriteBatch를 스프라이트 당 하나의 색상 대신에 버텍스 별 또는 스프라이트 별 정보로 보강 할 수 있습니다.<br /><br />SpriteBatch의 각 스프라이트는 왼쪽 상단, 왼쪽 하단, 오른쪽 상단, 오른쪽 하단 순으로 4 개의 정점이 있습니다. SpriteBatch : add에 의해 반환 된 인덱스 (SpriteBatch : set에 사용)는 4를 곱하여 특정 스프라이트에서 첫 번째 정점을 결정할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>attachAttribute( <span class = "arguments">name</span>, <span class = "arguments">mesh</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>첨부 할 정점 속성의 이름입니다.</td></tr><tr><td class = "arguments ra_name">mesh</td><td class = "ra_type"><a href="#Mesh">Mesh</a></td><td>정점 속성을 가져 오는 메쉬입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:clear" name = "SpriteBatch:clear"><span>SpriteBatch:</span><wbr>clear</a></p><p class = "function_description">버퍼에서 모든 스프라이트를 제거합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>clear()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:flush" name = "SpriteBatch:flush"><span>SpriteBatch:</span><wbr>flush</a></p><p class = "function_description">배치의 모든 새롭고 수정 된 스프라이트 데이터를 즉시 그래픽 카드로 보냅니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>flush()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:getBufferSize" name = "SpriteBatch:getBufferSize"><span>SpriteBatch:</span><wbr>getBufferSize</a></p><p class = "function_description">SpriteBatch가 보유 할 수있는 최대 스프라이트 수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">size</span> = SpriteBatch:<wbr>getBufferSize()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">size</td><td class = "ra_type">number</td><td>일괄 처리가 유지할 수있는 최대 스프라이트 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:getColor" name = "SpriteBatch:getColor"><span>SpriteBatch:</span><wbr>getColor</a></p><p class = "function_description">다음 번 추가 및 설정 작업에 사용될 색상을 가져옵니다.<br /><br />SpriteBatch : setColor로 색상이 설정되지 않았거나 현재 SpriteBatch 색상이 지워진 경우이 메서드는 nil을 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">r</span>, <span class = "returns">g</span>, <span class = "returns">b</span>, <span class = "returns">a</span> = SpriteBatch:<wbr>getColor()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">r</td><td class = "ra_type">number</td><td>빨간색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">g</td><td class = "ra_type">number</td><td>녹색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">b</td><td class = "ra_type">number</td><td>파란색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">a</td><td class = "ra_type">number</td><td>알파 성분 (0-255).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:getCount" name = "SpriteBatch:getCount"><span>SpriteBatch:</span><wbr>getCount</a></p><p class = "function_description">현재 SpriteBatch에있는 스프라이트의 양을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">count</span> = SpriteBatch:<wbr>getCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">count</td><td class = "ra_type">number</td><td>현재 배치에있는 스프라이트의 양.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:getTexture" name = "SpriteBatch:getTexture"><span>SpriteBatch:</span><wbr>getTexture</a></p><p class = "function_description">SpriteBatch에서 사용하는 이미지 또는 캔버스를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">texture</span> = SpriteBatch:<wbr>getTexture()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>스프라이트의 이미지 또는 캔버스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:set" name = "SpriteBatch:set"><span>SpriteBatch:</span><wbr>set</a></p><p class = "function_description">배치에서 스프라이트를 변경합니다. 이렇게하려면 add 및 addq에 의해 반환 된 식별자가 필요합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>set( <span class = "arguments">id</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">id</td><td class = "ra_type">number</td><td>변경 될 스프라이트의 식별자.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>물체를 그리는 위치 (x 축)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>오브젝트를 그리는 위치입니다 (y 축).</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축).</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축).</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축).</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축).</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>set( <span class = "arguments">id</span>, <span class = "arguments">quad</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">id</td><td class = "ra_type">number</td><td>변경 될 스프라이트의 식별자.</td></tr><tr><td class = "arguments ra_name">quad</td><td class = "ra_type"><a href="#Quad">Quad</a></td><td>배치 이미지에 사용 된 쿼드</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>물체를 그리는 위치 (x 축)입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>오브젝트를 그리는 위치입니다 (y 축).</td></tr><tr><td class = "arguments ra_name">r <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>오리엔테이션 (라디안).</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>배율 인수 (x 축).</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>배율 인수 (y 축).</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (x 축).</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>원점 오프셋 (y 축).</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (x 축).</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>전단 인자 (y 축).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:setBufferSize" name = "SpriteBatch:setBufferSize"><span>SpriteBatch:</span><wbr>setBufferSize</a></p><p class = "function_description">SpriteBatch가 보유 할 수있는 최대 스프라이트 수를 설정합니다. 일괄 처리의 기존 스프라이트 (새로운 최대 값까지)는이 함수가 호출 될 때 지워지지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>setBufferSize( <span class = "arguments">size</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">size</td><td class = "ra_type">number</td><td>배치가 보관할 수있는 새로운 최대 스프라이트 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:setColor" name = "SpriteBatch:setColor"><span>SpriteBatch:</span><wbr>setColor</a></p><p class = "function_description">다음 번 추가 및 설정 작업에 사용할 색상을 설정합니다. 인수없이 함수를 호출하면 색상이 지워집니다.<br /><br />{{0.9.2}} 버전에서 <a href="#love.graphics.setColor">love.graphics.setColor</a>로 설정된 전역 색상은 스프라이트에 고유 색상이있는 경우 SpriteBatch에서 작동하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>setColor( <span class = "arguments">r</span>, <span class = "arguments">g</span>, <span class = "arguments">b</span>, <span class = "arguments">a</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">r</td><td class = "ra_type">number</td><td>빨간색의 양.</td></tr><tr><td class = "arguments ra_name">g</td><td class = "ra_type">number</td><td>초록색의 양.</td></tr><tr><td class = "arguments ra_name">b</td><td class = "ra_type">number</td><td>파란색 양.</td></tr><tr><td class = "arguments ra_name">a <span class = "default">(255)</span></td><td class = "ra_type">number</td><td>알파의 양.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>setColor()</span></span></p><p class = "variant_description">이 SpriteBatch에 대한 모든 당 스프라이트 색상을 사용하지 않습니다.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#SpriteBatch:setTexture" name = "SpriteBatch:setTexture"><span>SpriteBatch:</span><wbr>setTexture</a></p><p class = "function_description">스프라이트에 사용 된 이미지 또는 캔버스를 대체합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SpriteBatch:<wbr>setTexture( <span class = "arguments">texture</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">texture</td><td class = "ra_type"><a href="#Texture">Texture</a></td><td>스프라이트에 사용할 새로운 이미지 또는 캔버스입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Text" name = "Text">Text</a></p><p class = "section_description">텍스트를 그릴 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newText">newText</a>&emsp;새로운 Font를 작성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:add">add</a>&emsp;지정된 위치의 Text 객체에 추가로 색상이 지정된 텍스트를 추가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:addf">addf</a>&emsp;지정된 위치에 Text 객체에 추가로 서식이 지정된 / 채색 된 텍스트를 추가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:set">set</a>&emsp;Text 오브젝트의 내용을 새로운 형식화되지 않은 문자열로 대체합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:setf">setf</a>&emsp;Text 객체의 내용을 새로운 형식의 문자열로 바꿉니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:clear">clear</a>&emsp;Text 객체의 내용을 지 웁니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:getFont">get</a><span class = "slash">/</span><a href="#Text:setFont">setFont</a>&emsp;사용 된 폰트를 텍스트로 대체합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:getDimensions">getDimensions</a>&emsp;텍스트의 폭과 높이를 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:getWidth">getWidth</a>&emsp;텍스트의 폭을 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Text:<a href="#Text:getHeight">getHeight</a>&emsp;텍스트의 높이를 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Text:add" name = "Text:add"><span>Text:</span><wbr>add</a></p><p class = "function_description">지정된 위치의 Text 객체에 추가로 색상이 지정된 텍스트를 추가합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">index</span> = Text:<wbr>add( <span class = "arguments">textstring</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">angle</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">index</td><td class = "ra_type">number</td><td>Text : getWidth 또는 Text : getHeight에서 사용할 수있는 색인 번호입니다.</td></tr><tr><td class = "arguments ra_name">textstring</td><td class = "ra_type">string</td><td>객체에 추가 할 텍스트입니다.</td></tr><tr><td class = "arguments ra_name">x <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>새로운 텍스트의 x 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>새로운 텍스트의 y 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">angle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>새 텍스트의 방향 (라디안)입니다.</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>x 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>y 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>y 축의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 전단 / 비뚤어 짐 계수입니다.</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>Y 축상의 전단 / 비뚤어 짐 계수.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">index</span> = Text:<wbr>add( <span class = "arguments">coloredtext</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">angle</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">index</td><td class = "ra_type">number</td><td>Text : getWidth 또는 Text : getHeight에서 사용할 수있는 색인 번호입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext</td><td class = "ra_type">table</td><td>{color1, string1, color2, string2, ...} 형식으로 새 텍스트로 사용할 색상과 문자열이 포함 된 테이블입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color1</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string1</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color2</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string2</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext....</td><td class = "ra_type">tables and strings</td><td>추가 색상 및 문자열.</td></tr><tr><td class = "arguments ra_name">x <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>새로운 텍스트의 x 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>새로운 텍스트의 y 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">angle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>새 텍스트의 방향 (라디안)입니다.</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>x 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>y 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>y 축의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 전단 / 비뚤어 짐 계수입니다.</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>Y 축상의 전단 / 비뚤어 짐 계수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:addf" name = "Text:addf"><span>Text:</span><wbr>addf</a></p><p class = "function_description">지정된 위치에 Text 객체에 추가로 서식이 지정된 / 채색 된 텍스트를 추가합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">index</span> = Text:<wbr>addf( <span class = "arguments">textstring</span>, <span class = "arguments">wraplimit</span>, <span class = "arguments">align</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">angle</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">index</td><td class = "ra_type">number</td><td>Text : getWidth 또는 Text : getHeight에서 사용할 수있는 색인 번호입니다.</td></tr><tr><td class = "arguments ra_name">textstring</td><td class = "ra_type">string</td><td>객체에 추가 할 텍스트입니다.</td></tr><tr><td class = "arguments ra_name">wraplimit</td><td class = "ra_type">number</td><td>텍스트가 자동으로 새 줄로 감싸기 전에 텍스트의 최대 너비 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">align</td><td class = "ra_type"><a href="#AlignMode">AlignMode</a></td><td>텍스트의 정렬입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>새로운 텍스트의 x 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>새로운 텍스트의 y 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">angle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>라디안 단위의 객체 방향입니다.</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>x 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>y 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>y 축의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 전단 / 비뚤어 짐 계수입니다.</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>Y 축상의 전단 / 비뚤어 짐 계수.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">index</span> = Text:<wbr>addf( <span class = "arguments">coloredtext</span>, <span class = "arguments">wraplimit</span>, <span class = "arguments">align</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">angle</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span>, <span class = "arguments">kx</span>, <span class = "arguments">ky</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">index</td><td class = "ra_type">number</td><td>Text : getWidth 또는 Text : getHeight에서 사용할 수있는 색인 번호입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext</td><td class = "ra_type">table</td><td>{color1, string1, color2, string2, ...} 형식으로 새 텍스트로 사용할 색상과 문자열이 포함 된 테이블입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color1</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string1</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color2</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string2</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext....</td><td class = "ra_type">tables and strings</td><td>추가 색상 및 문자열.</td></tr><tr><td class = "arguments ra_name">wraplimit</td><td class = "ra_type">number</td><td>텍스트가 자동으로 새 줄로 감싸기 전에 텍스트의 최대 너비 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">align</td><td class = "ra_type"><a href="#AlignMode">AlignMode</a></td><td>텍스트의 정렬입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>새로운 텍스트의 x 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>새로운 텍스트의 y 축상의 위치입니다.</td></tr><tr><td class = "arguments ra_name">angle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>라디안 단위의 객체 방향입니다.</td></tr><tr><td class = "arguments ra_name">sx <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>x 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">sy <span class = "default">(sx)</span></td><td class = "ra_type">number</td><td>y 축의 비율 인수입니다.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>y 축의 원점 오프셋.</td></tr><tr><td class = "arguments ra_name">kx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>x 축상의 전단 / 비뚤어 짐 계수입니다.</td></tr><tr><td class = "arguments ra_name">ky <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>Y 축상의 전단 / 비뚤어 짐 계수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:clear" name = "Text:clear"><span>Text:</span><wbr>clear</a></p><p class = "function_description">Text 객체의 내용을 지 웁니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>clear()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:getDimensions" name = "Text:getDimensions"><span>Text:</span><wbr>getDimensions</a></p><p class = "function_description">텍스트의 폭과 높이를 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = Text:<wbr>getDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>텍스트의 폭입니다. Text : add에 여러 하위 문자열이 추가 된 경우 마지막 하위 문자열의 너비가 반환됩니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>텍스트의 높이입니다. Text : add에 여러 하위 문자열이 추가 된 경우 마지막 하위 문자열의 높이가 반환됩니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = Text:<wbr>getDimensions( <span class = "arguments">index</span> )</span></span></p><p class = "variant_description">이전에 첨가하고 특정의 서브 캐릭터의 폭과 높이를 취득 에서 Text 개체.</p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>하위 문자열의 너비 (배율 및 기타 변형 전)입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>하위 문자열의 높이 (크기 조절 및 기타 변형 전)입니다.</td></tr><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>Text : add 또는 Text : addf에 의해 리턴 된 색인 번호.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:getFont" name = "Text:getFont"><span>Text:</span><wbr>getFont</a></p><p class = "function_description">Text 개체와 함께 사용되는 Font를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">font</span> = Text:<wbr>getFont()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>이 Text 객체에 사용 된 글꼴입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:getHeight" name = "Text:getHeight"><span>Text:</span><wbr>getHeight</a></p><p class = "function_description">텍스트의 높이를 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = Text:<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>텍스트의 높이입니다. Text : add에 여러 하위 문자열이 추가 된 경우 마지막 하위 문자열의 높이가 반환됩니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = Text:<wbr>getHeight( <span class = "arguments">index</span> )</span></span></p><p class = "variant_description">이전에 첨가하고 특정의 서브 캐릭터의 높이를 가져에서 Text 개체.</p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>하위 문자열의 높이 (크기 조절 및 기타 변형 전)입니다.</td></tr><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>Text : add 또는 Text : addf에 의해 리턴 된 색인 번호.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:getWidth" name = "Text:getWidth"><span>Text:</span><wbr>getWidth</a></p><p class = "function_description">텍스트의 폭을 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = Text:<wbr>getWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>텍스트의 폭입니다. Text : add에 여러 하위 문자열이 추가 된 경우 마지막 하위 문자열의 너비가 반환됩니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = Text:<wbr>getWidth( <span class = "arguments">index</span> )</span></span></p><p class = "variant_description">이전에 첨가하고 특정의 서브 캐릭터의 폭을 가져에서 Text 개체.</p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>하위 문자열의 너비 (배율 및 기타 변형 전)입니다.</td></tr><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>Text : add 또는 Text : addf에 의해 리턴 된 색인 번호.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:set" name = "Text:set"><span>Text:</span><wbr>set</a></p><p class = "function_description">Text 오브젝트의 내용을 새로운 형식화되지 않은 문자열로 대체합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>set( <span class = "arguments">textstring</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">textstring</td><td class = "ra_type">string</td><td>사용할 새로운 텍스트 문자열입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>set( <span class = "arguments">coloredtext</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">coloredtext</td><td class = "ra_type">table</td><td>{color1, string1, color2, string2, ...} 형식으로 새 텍스트로 사용할 색상과 문자열이 포함 된 테이블입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color1</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string1</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color2</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string2</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext....</td><td class = "ra_type">tables and strings</td><td>추가 색상 및 문자열.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>set()</span></span></p><p class = "variant_description">Clears the contents of the <a href="#Text">Text</a> object.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:setf" name = "Text:setf"><span>Text:</span><wbr>setf</a></p><p class = "function_description">Text 객체의 내용을 새로운 형식의 문자열로 바꿉니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>setf( <span class = "arguments">textstring</span>, <span class = "arguments">wraplimit</span>, <span class = "arguments">align</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">textstring</td><td class = "ra_type">string</td><td>사용할 새로운 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">wraplimit</td><td class = "ra_type">number</td><td>텍스트가 자동으로 새 줄로 감싸기 전에 텍스트의 최대 너비 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">align <span class = "default">("left")</span></td><td class = "ra_type"><a href="#AlignMode">AlignMode</a></td><td>텍스트의 정렬입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>setf( <span class = "arguments">coloredtext</span>, <span class = "arguments">wraplimit</span>, <span class = "arguments">align</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">coloredtext</td><td class = "ra_type">table</td><td>{color1, string1, color2, string2, ...} 형식으로 새 텍스트로 사용할 색상과 문자열이 포함 된 테이블입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color1</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string1</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.color2</td><td class = "ra_type">table</td><td>{red, green, blue, alpha}의 형식으로 테이블의 다음 문자열에 대한 색상으로 사용할 빨강, 녹색, 파랑 및 선택적 알파 구성 요소가 포함 된 표입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext.string2</td><td class = "ra_type">string</td><td>이전 색상으로 지정된 색상을 가진 텍스트 문자열입니다.</td></tr><tr><td class = "arguments ra_name">coloredtext....</td><td class = "ra_type">tables and strings</td><td>추가 색상 및 문자열.</td></tr><tr><td class = "arguments ra_name">wraplimit</td><td class = "ra_type">number</td><td>텍스트가 자동으로 새 줄로 감싸기 전에 텍스트의 최대 너비 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">align <span class = "default">("left")</span></td><td class = "ra_type"><a href="#AlignMode">AlignMode</a></td><td>텍스트의 정렬입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>setf()</span></span></p><p class = "variant_description">Clears the contents of the <a href="#Text">Text</a> object.</p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Text:setFont" name = "Text:setFont"><span>Text:</span><wbr>setFont</a></p><p class = "function_description">사용 된 폰트를 텍스트로 대체합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Text:<wbr>setFont( <span class = "arguments">font</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">font</td><td class = "ra_type"><a href="#Font">Font</a></td><td>이 Text 객체에 사용할 새 글꼴입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Texture" name = "Texture">Texture</a></p><p class = "section_description">텍스처를 나타내는 드로어 블 오브젝트의 슈퍼 클래스입니다. Quad를 사용하여 모든 텍스처를 그릴 수 있습니다. 이것은 직접 생성 할 수없는 추상 유형입니다.</p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_subheading">Subtypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Canvas">Canvas</a>&emsp;캔버스는 스크린 외부 렌더링에 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Image">Image</a>&emsp;드로어 블 이미지 유형. </p></div><div class = "section"><p class = "section_heading"><a href = "#Video" name = "Video">Video</a></p><p class = "section_description">드로어 블 비디오.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.graphics.<a href="#love.graphics.newVideo">newVideo</a>&emsp;새로운 드로어 블 비디오를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:play">play</a>&emsp;비디오 재생을 시작합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:isPlaying">isPlaying</a>&emsp;비디오가 현재 재생 중인지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:pause">pause</a>&emsp;비디오를 일시 정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:tell">tell</a><span class = "slash">/</span><a href="#Video:seek">seek</a>&emsp;비디오의 현재 재생 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:rewind">rewind</a>&emsp;비디오를 처음으로 되감습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:getSource">get</a><span class = "slash">/</span><a href="#Video:setSource">setSource</a>&emsp;비디오의 오디오 재생에 사용되는 오디오 소스를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:getFilter">get</a><span class = "slash">/</span><a href="#Video:setFilter">setFilter</a>&emsp;비디오를 그릴 때 사용되는 스케일링 필터를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:getDimensions">getDimensions</a>&emsp;비디오의 폭과 높이를 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:getWidth">getWidth</a>&emsp;비디오 폭을 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Video:<a href="#Video:getHeight">getHeight</a>&emsp;비디오의 높이를 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Drawable">Drawable</a>&emsp;화면에 그릴 수있는 모든 것에 대한 수퍼 클래스. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Video:getDimensions" name = "Video:getDimensions"><span>Video:</span><wbr>getDimensions</a></p><p class = "function_description">비디오의 폭과 높이를 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = Video:<wbr>getDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>비디오 너비입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>비디오의 높이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:getFilter" name = "Video:getFilter"><span>Video:</span><wbr>getFilter</a></p><p class = "function_description">비디오를 그릴 때 사용되는 스케일링 필터를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">min</span>, <span class = "returns">mag</span>, <span class = "returns">anisotropy</span> = Video:<wbr>getFilter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>비디오를 축소 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">mag</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>비디오를 확대 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "returns ra_name">anisotropy <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대량입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:getHeight" name = "Video:getHeight"><span>Video:</span><wbr>getHeight</a></p><p class = "function_description">비디오의 높이를 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = Video:<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>비디오의 높이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:getSource" name = "Video:getSource"><span>Video:</span><wbr>getSource</a></p><p class = "function_description">비디오의 오디오 재생에 사용되는 오디오 소스를 가져옵니다. 비디오에 오디오가없는 경우 또는 비디오 : setSource가 nil 인수로 호출 된 경우 nil을 반환 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">source</span> = Video:<wbr>getSource()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">source</td><td class = "ra_type"><a href="#Source">Source</a></td><td>오디오 재생에 사용되는 오디오 소스. 비디오에 오디오가없는 경우에는 nil입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:getWidth" name = "Video:getWidth"><span>Video:</span><wbr>getWidth</a></p><p class = "function_description">비디오 폭을 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = Video:<wbr>getWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>비디오 너비입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:isPlaying" name = "Video:isPlaying"><span>Video:</span><wbr>isPlaying</a></p><p class = "function_description">비디오가 현재 재생 중인지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">playing</span> = Video:<wbr>isPlaying()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">playing</td><td class = "ra_type">boolean</td><td>동영상 재생 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:pause" name = "Video:pause"><span>Video:</span><wbr>pause</a></p><p class = "function_description">비디오를 일시 정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Video:<wbr>pause()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:play" name = "Video:play"><span>Video:</span><wbr>play</a></p><p class = "function_description">비디오 재생을 시작합니다. 비디오가 화면에 나타나게하려면 <a href="#love.graphics.draw">love.graphics.draw</a>를 사용하여 그려야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Video:<wbr>play()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:rewind" name = "Video:rewind"><span>Video:</span><wbr>rewind</a></p><p class = "function_description">비디오를 처음으로 되감습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Video:<wbr>rewind()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:seek" name = "Video:seek"><span>Video:</span><wbr>seek</a></p><p class = "function_description">비디오의 현재 재생 위치를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Video:<wbr>seek( <span class = "arguments">offset</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">offset</td><td class = "ra_type">number</td><td>비디오가 시작된 이후의 시간 (초)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:setFilter" name = "Video:setFilter"><span>Video:</span><wbr>setFilter</a></p><p class = "function_description">비디오를 그릴 때 사용되는 스케일링 필터를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Video:<wbr>setFilter( <span class = "arguments">min</span>, <span class = "arguments">mag</span>, <span class = "arguments">anisotropy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">min</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>비디오를 축소 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "arguments ra_name">mag</td><td class = "ra_type"><a href="#FilterMode">FilterMode</a></td><td>비디오를 확대 할 때 사용되는 필터 모드입니다.</td></tr><tr><td class = "arguments ra_name">anisotropy <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>사용 된 이방성 필터링의 최대량입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:setSource" name = "Video:setSource"><span>Video:</span><wbr>setSource</a></p><p class = "function_description">비디오의 오디오 재생에 사용되는 오디오 소스를 설정합니다. 또한 오디오 소스는 재생 속도와 동기화를 제어합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Video:<wbr>setSource( <span class = "arguments">source</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">source <span class = "default">(nil)</span></td><td class = "ra_type"><a href="#Source">Source</a></td><td>오디오 재생에 사용되는 오디오 소스 또는 오디오 동기화를 사용하지 않으려면 nil입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Video:tell" name = "Video:tell"><span>Video:</span><wbr>tell</a></p><p class = "function_description">비디오의 현재 재생 위치를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Video:<wbr>tell( <span class = "arguments">seconds</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">seconds</td><td class = "ra_type">number</td><td>비디오가 시작된 이후의 시간 (초)입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.image" name = "love.image">love.image</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedImageData">CompressedImageData</a>&emsp;RAM에 압축 된 상태로 유지되도록 설계된 압축 된 이미지 데이터를 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ImageData">ImageData</a>&emsp;원시 (디코딩 된) 이미지 데이터. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.image.<a href="#love.image.isCompressed">isCompressed</a>&emsp;파일을 CompressedImageData로로드 할 수 있는지 여부를 결정합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedImageFormat">CompressedImageFormat</a>&emsp;압축 된 이미지 데이터 형식. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ImageFormat">ImageFormat</a>&emsp;인코딩 된 이미지 형식. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.image.isCompressed" name = "love.image.isCompressed"><span>love.image.</span><wbr>isCompressed</a></p><p class = "function_description">파일을 CompressedImageData로로드 할 수 있는지 여부를 결정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">compressed</span> = love.image.<wbr>isCompressed( <span class = "arguments">filename</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">compressed</td><td class = "ra_type">boolean</td><td>파일을 CompressedImageData로로드 할 수 있는지 여부.</td></tr><tr><td class = "arguments ra_name">filename</td><td class = "ra_type">string</td><td>잠재적으로 압축 된 이미지 파일의 파일 이름입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">compressed</span> = love.image.<wbr>isCompressed( <span class = "arguments">fileData</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">compressed</td><td class = "ra_type">boolean</td><td>FileData를 CompressedImageData로로드 할 수 있는지 여부입니다.</td></tr><tr><td class = "arguments ra_name">fileData</td><td class = "ra_type"><a href="#FileData">FileData</a></td><td>잠재적으로 압축 된 이미지를 포함하는 FileData입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.image.newCompressedData" name = "love.image.newCompressedData"><span>love.image.</span><wbr>newCompressedData</a></p><p class = "function_description">압축 된 이미지 파일에서 새 CompressedImageData 객체를 만듭니다. L-VE는 CompressedImageFormat 페이지에 열거 된 여러 가지 압축 된 텍스처 형식을 지원합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">compressedImageData</span> = love.image.<wbr>newCompressedData( <span class = "arguments">file</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">compressedImageData</td><td class = "ra_type"><a href="#CompressedImageData">CompressedImageData</a></td><td>새로운 CompressedImageData 객체입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>압축 된 이미지 파일의 파일 경로 / File / FileData.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.image.newImageData" name = "love.image.newImageData"><span>love.image.</span><wbr>newImageData</a></p><p class = "function_description">새로운 ImageData 객체를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">imageData</span> = love.image.<wbr>newImageData( <span class = "arguments">width</span>, <span class = "arguments">height</span>, <span class = "arguments">data</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">imageData</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>새로운 빈 상태 (empty)의 ImageData object입니다. 각 픽셀의 색상 값 (알파 값 포함)은 0으로 설정됩니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>ImageData의 폭입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>ImageData의 높이입니다.</td></tr><tr><td class = "arguments ra_name">data <span class = "default">(none)</span></td><td class = "ra_type">string</td><td>ImageData에로드 할 데이터 (RGBA 바이트, 왼쪽에서 오른쪽, 위에서 아래).</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">imageData</span> = love.image.<wbr>newImageData( <span class = "arguments">file</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">imageData</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>새로운 ImageData object입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>이미지 파일의 파일 경로 / File / FileData.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#CompressedImageFormat" name = "CompressedImageFormat">CompressedImageFormat</a></p><p class = "constant_name">DXT1</p><p class = "constant_description">DXT1 형식입니다. 픽셀 당 4 비트의 RGB 데이터 (ImageData 및 일반 이미지의 경우 32 비트와 비교). 완전히 불투명 한 이미지에 적합합니다. 데스크탑 시스템에서 완전히 불투명 한 이미지에 적합합니다.</p><p class = "constant_name">DXT3</p><p class = "constant_description">DXT3 형식입니다. 픽셀 당 8 비트의 RGBA 데이터. 불투명도의 매끄러운 변화는이 형식과 잘 어울리지 않습니다.</p><p class = "constant_name">DXT5</p><p class = "constant_description">DXT5 형식입니다. 픽셀 당 8 비트의 RGBA 데이터. 데스크탑 시스템에서 불투명도가 다른 이미지에 권장됩니다.</p><p class = "constant_name">BC4</p><p class = "constant_description">BC4 형식 (3Dc + 또는 ATI1이라고도 함) 픽셀 당 4 비트의 빨간색 채널 만 저장합니다.</p><p class = "constant_name">BC4s</p><p class = "constant_description">BC4 형식의 서명 된 변형입니다. 위와 같지만 텍스처의 픽셀 값은 셰이더의 {0, 1} 대신 {-1, 1} 범위입니다.</p><p class = "constant_name">BC5</p><p class = "constant_description">BC5 형식 (3Dc 또는 ATI2라고도 함). 빨강 및 녹색 채널을 픽셀 당 8 비트로 저장합니다.</p><p class = "constant_name">BC5s</p><p class = "constant_description">BC5 형식의 서명 된 변형입니다.</p><p class = "constant_name">BC6h</p><p class = "constant_description">BC6H 형식. 픽셀 당 8 비트에서 {0, 65504}의 범위에있는 반 정밀도 부동 소수점 RGB 데이터를 저장합니다. 데스크탑 시스템의 HDR 이미지에 적합합니다.</p><p class = "constant_name">BC6hs</p><p class = "constant_description">BC6H 형식의 서명 된 변형입니다. {-65504, +65504} 범위의 RGB 데이터를 저장합니다.</p><p class = "constant_name">BC7</p><p class = "constant_description">BC7 형식 (BPTC라고도 함) RGB 또는 RGBA 데이터를 픽셀 당 8 비트로 저장합니다.</p><p class = "constant_name">ETC1</p><p class = "constant_description">ETC1 형식입니다. 픽셀 당 4 비트의 RGB 데이터. 오래된 Android 기기에서 완전히 불투명 한 이미지에 적합합니다.</p><p class = "constant_name">ETC2rgb</p><p class = "constant_description">ETC2 형식의 RGB 변형입니다. 픽셀 당 4 비트의 RGB 데이터. 새로운 모바일 장치에서 완전히 불투명 한 이미지에 적합합니다.</p><p class = "constant_name">ETC2rgba</p><p class = "constant_description">ETC2 형식의 RGBA 변형입니다. 픽셀 당 8 비트의 RGBA 데이터. 새로운 휴대 기기에서 불투명도가 다른 이미지에 권장됩니다.</p><p class = "constant_name">ETC2rgba1</p><p class = "constant_description">픽셀이 완전히 투명하거나 완전히 불투명 한 ETC2 형식의 RGBA 변형입니다. 픽셀 당 4 비트의 RGBA 데이터.</p><p class = "constant_name">EACr</p><p class = "constant_description">EAC 형식의 단일 채널 변형입니다. 빨강 채널 만 저장합니다 (픽셀 당 4 비트).</p><p class = "constant_name">EACrs</p><p class = "constant_description">EAC 형식의 서명 된 단일 채널 변형입니다. 위와 같지만 텍스처의 픽셀 값은 셰이더의 {0, 1} 대신 {-1, 1}의 범위 내에 있습니다.</p><p class = "constant_name">EACrg</p><p class = "constant_description">EAC 형식의 2 채널 변형입니다. 픽셀 당 8 비트의 빨강 및 녹색 채널을 저장합니다.</p><p class = "constant_name">EACrgs</p><p class = "constant_description">EAC 형식의 서명 된 2 채널 변형입니다.</p><p class = "constant_name">PVR1rgb2</p><p class = "constant_description">PVRTC1 형식의 픽셀 당 2 비트 RGB 변형입니다. RGB 데이터를 픽셀 당 2 비트로 저장합니다. PVRTC1 형식으로 압축 된 텍스처는 정사각형이어야하며 크기는 2입니다.</p><p class = "constant_name">PVR1rgb4</p><p class = "constant_description">PVRTC1 형식의 픽셀 당 RGB 4 비트 변형입니다. RGB 데이터를 픽셀 당 4 비트로 저장합니다.</p><p class = "constant_name">PVR1rgba2</p><p class = "constant_description">PVRTC1 형식의 픽셀 당 2 비트 RGBA 변형입니다.</p><p class = "constant_name">PVR1rgba4</p><p class = "constant_description">PVRTC1 형식의 픽셀 당 4 비트 RGBA 변형입니다.</p><p class = "constant_name">ASTC4x4</p><p class = "constant_description">ASTC 형식의 블록 변형 당 4x4 픽셀 픽셀 당 8 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC5x4</p><p class = "constant_description">ASTC 형식의 블록 변형 당 5x4 픽셀. 픽셀 당 6.4 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC5x5</p><p class = "constant_description">ASTC 형식의 블록 변형 당 5x5 픽셀. 픽셀 당 5.12 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC6x5</p><p class = "constant_description">ASTC 형식의 블록 변형 당 6x5 픽셀 픽셀 당 4.27 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC6x6</p><p class = "constant_description">ASTC 형식의 블록 변형 당 6x6 픽셀입니다. 픽셀 당 3.56 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC8x5</p><p class = "constant_description">ASTC 형식의 블록 변형 당 8x5 픽셀 픽셀 당 3.2 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC8x6</p><p class = "constant_description">ASTC 형식의 블록 변형 당 8x6 픽셀 픽셀 당 2.67 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC8x8</p><p class = "constant_description">ASTC 형식의 블록 변형 당 8x8 픽셀 픽셀 당 2 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC10x5</p><p class = "constant_description">ASTC 형식의 블록 변형 당 10x5 픽셀. 픽셀 당 2.56 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC10x6</p><p class = "constant_description">ASTC 형식의 블록 변형 당 10x6 픽셀입니다. 픽셀 당 2.13 비트의 RGBA 데이터</p><p class = "constant_name">ASTC10x8</p><p class = "constant_description">ASTC 형식의 블록 변형 당 10x8 픽셀 RGBA 데이터는 픽셀 당 1.6 비트입니다.</p><p class = "constant_name">ASTC10x10</p><p class = "constant_description">ASTC 형식의 블록 변형 당 10x10 픽셀. 픽셀 당 1.28 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC12x10</p><p class = "constant_description">ASTC 형식의 블록 변형 당 12x10 픽셀입니다. 픽셀 당 1.07 비트의 RGBA 데이터.</p><p class = "constant_name">ASTC12x12</p><p class = "constant_description">ASTC 형식의 블록 변형 당 12x12 픽셀 픽셀 당 0.89 비트의 RGBA 데이터.</p></div><div class = "section"><p class = "section_heading"><a href = "#ImageFormat" name = "ImageFormat">ImageFormat</a></p><p class = "constant_name">tga</p><p class = "constant_description">Targa 이미지 형식.</p><p class = "constant_name">png</p><p class = "constant_description">PNG 이미지 형식.</p></div><div class = "section"><p class = "section_heading"><a href = "#CompressedImageData" name = "CompressedImageData">CompressedImageData</a></p><p class = "section_description">RAM에 압축 된 상태로 유지되도록 설계된 압축 된 이미지 데이터를 나타냅니다.<br /><br />CompressedImageData는 DXT1, DXT5 및 BC5 / 3Dc와 같은 표준 압축 텍스처 형식을 포함합니다.<br /><br />CompressedImageData를 화면에 직접 그릴 수는 없습니다. 이미지를 참조하십시오.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.image.<a href="#love.image.newCompressedData">newCompressedData</a>&emsp;압축 된 이미지 파일에서 새 CompressedImageData 객체를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">CompressedImageData:<a href="#CompressedImageData:getDimensions">getDimensions</a>&emsp;CompressedImageData의 폭과 높이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">CompressedImageData:<a href="#CompressedImageData:getFormat">getFormat</a>&emsp;CompressedImageData의 형식을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">CompressedImageData:<a href="#CompressedImageData:getHeight">getHeight</a>&emsp;CompressedImageData의 높이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">CompressedImageData:<a href="#CompressedImageData:getMipmapCount">getMipmapCount</a>&emsp;CompressedImageData에서 밉맵 수준 수를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">CompressedImageData:<a href="#CompressedImageData:getWidth">getWidth</a>&emsp;CompressedImageData의 폭을 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Data">Data</a>&emsp;모든 데이터 타입의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#CompressedImageData:getDimensions" name = "CompressedImageData:getDimensions"><span>CompressedImageData:</span><wbr>getDimensions</a></p><p class = "function_description">CompressedImageData의 폭과 높이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = CompressedImageData:<wbr>getDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>CompressedImageData의 폭입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>CompressedImageData의 높이입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = CompressedImageData:<wbr>getDimensions( <span class = "arguments">level</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>CompressedImageData의 폭입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>CompressedImageData의 높이입니다.</td></tr><tr><td class = "arguments ra_name">level</td><td class = "ra_type">number</td><td>밉맵 레벨. {1, <a href="#CompressedImageData">CompressedImageData</a> : getMipmapCount ()}의 범위 내에 있어야합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#CompressedImageData:getFormat" name = "CompressedImageData:getFormat"><span>CompressedImageData:</span><wbr>getFormat</a></p><p class = "function_description">CompressedImageData의 형식을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">format</span> = CompressedImageData:<wbr>getFormat()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">format</td><td class = "ra_type"><a href="#CompressedImageFormat">CompressedImageFormat</a></td><td>CompressedImageData의 형식입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#CompressedImageData:getHeight" name = "CompressedImageData:getHeight"><span>CompressedImageData:</span><wbr>getHeight</a></p><p class = "function_description">CompressedImageData의 높이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = CompressedImageData:<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>CompressedImageData의 높이입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = CompressedImageData:<wbr>getHeight( <span class = "arguments">level</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>CompressedImageData의 높이입니다.</td></tr><tr><td class = "arguments ra_name">level</td><td class = "ra_type">number</td><td>밉맵 레벨. {1, <a href="#CompressedImageData">CompressedImageData</a> : getMipmapCount ()}의 범위 내에 있어야합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#CompressedImageData:getMipmapCount" name = "CompressedImageData:getMipmapCount"><span>CompressedImageData:</span><wbr>getMipmapCount</a></p><p class = "function_description">CompressedImageData에서 밉맵 수준 수를 가져옵니다. 기본 밉맵 레벨 (원본 이미지)은 카운트에 포함됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mipmaps</span> = CompressedImageData:<wbr>getMipmapCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mipmaps</td><td class = "ra_type">number</td><td>CompressedImageData에 저장된 밉맵 레벨 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#CompressedImageData:getWidth" name = "CompressedImageData:getWidth"><span>CompressedImageData:</span><wbr>getWidth</a></p><p class = "function_description">CompressedImageData의 폭을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = CompressedImageData:<wbr>getWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>CompressedImageData의 폭입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = CompressedImageData:<wbr>getWidth( <span class = "arguments">level</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>CompressedImageData의 폭입니다.</td></tr><tr><td class = "arguments ra_name">level</td><td class = "ra_type">number</td><td>밉맵 레벨. {1, <a href="#CompressedImageData">CompressedImageData</a> : getMipmapCount ()}의 범위 내에 있어야합니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#ImageData" name = "ImageData">ImageData</a></p><p class = "section_description">원시 (디코딩 된) 이미지 데이터.<br /><br />ImageData를 직접 화면에 그릴 수는 없습니다. 이미지를 참조하십시오.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.image.<a href="#love.image.newImageData">newImageData</a>&emsp;새로운 ImageData 객체를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">ImageData:<a href="#ImageData:getPixel">get</a><span class = "slash">/</span><a href="#ImageData:setPixel">setPixel</a>&emsp;이미지의 특정 위치에있는 픽셀의 색상을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ImageData:<a href="#ImageData:mapPixel">mapPixel</a>&emsp;모든 픽셀에 함수를 적용하여 이미지를 변형합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ImageData:<a href="#ImageData:paste">paste</a>&emsp;다른 소스 ImageData의 ImageData에 붙여 넣습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ImageData:<a href="#ImageData:encode">encode</a>&emsp;ImageData를 인코딩하고 선택적으로 저장 디렉토리에 씁니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ImageData:<a href="#ImageData:getDimensions">getDimensions</a>&emsp;ImageData의 폭과 높이를 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ImageData:<a href="#ImageData:getWidth">getWidth</a>&emsp;ImageData의 폭 (픽셀 단위)을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ImageData:<a href="#ImageData:getHeight">getHeight</a>&emsp;ImageData의 높이 (픽셀 단위)를 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Data">Data</a>&emsp;모든 데이터 타입의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:encode" name = "ImageData:encode"><span>ImageData:</span><wbr>encode</a></p><p class = "function_description">ImageData를 인코딩하고 선택적으로 저장 디렉토리에 씁니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">filedata</span> = ImageData:<wbr>encode( <span class = "arguments">format</span>, <span class = "arguments">filename</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">filedata</td><td class = "ra_type"><a href="#FileData">FileData</a></td><td>encode 된 이미지를 새로운 FileData 객체로서 돌려줍니다.</td></tr><tr><td class = "arguments ra_name">format</td><td class = "ra_type"><a href="#ImageFormat">ImageFormat</a></td><td>이미지를 인코딩 할 형식입니다.</td></tr><tr><td class = "arguments ra_name">filename <span class = "default">(nil)</span></td><td class = "ra_type">string</td><td>파일을 쓸 파일 이름입니다. nil 인 경우 파일은 쓰이지 않지만 FileData는 계속 리턴됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:getDimensions" name = "ImageData:getDimensions"><span>ImageData:</span><wbr>getDimensions</a></p><p class = "function_description">ImageData의 폭과 높이를 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span> = ImageData:<wbr>getDimensions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>ImageData의 폭 (픽셀 단위)입니다.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>ImageData의 높이 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:getHeight" name = "ImageData:getHeight"><span>ImageData:</span><wbr>getHeight</a></p><p class = "function_description">ImageData의 높이 (픽셀 단위)를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">height</span> = ImageData:<wbr>getHeight()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>ImageData의 높이 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:getPixel" name = "ImageData:getPixel"><span>ImageData:</span><wbr>getPixel</a></p><p class = "function_description">이미지의 특정 위치에있는 픽셀의 색상을 가져옵니다.<br /><br />유효한 x 및 y 값은 0에서 시작하여 이미지 너비와 높이에서 1을 뺀 값이됩니다. 정수가 아닌 값은 채워집니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">r</span>, <span class = "returns">g</span>, <span class = "returns">b</span>, <span class = "returns">a</span> = ImageData:<wbr>getPixel( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">r</td><td class = "ra_type">number</td><td>빨간색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">g</td><td class = "ra_type">number</td><td>녹색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">b</td><td class = "ra_type">number</td><td>파란색 구성 요소 (0-255).</td></tr><tr><td class = "returns ra_name">a</td><td class = "ra_type">number</td><td>알파 성분 (0-255).</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축상의 픽셀의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축의 픽셀 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:getWidth" name = "ImageData:getWidth"><span>ImageData:</span><wbr>getWidth</a></p><p class = "function_description">ImageData의 폭 (픽셀 단위)을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span> = ImageData:<wbr>getWidth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>ImageData의 폭 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:mapPixel" name = "ImageData:mapPixel"><span>ImageData:</span><wbr>mapPixel</a></p><p class = "function_description">모든 픽셀에 함수를 적용하여 이미지를 변형합니다.<br /><br />이 함수는 고차 함수입니다. 다른 함수를 매개 변수로 사용하여 ImageData의 각 픽셀에 대해 한 번 호출합니다.<br /><br />함수 매개 변수는 각 픽셀에 대해 차례로 6 개의 매개 변수로 호출됩니다. 매개 변수는 픽셀의 x 및 y 좌표와 빨강, 녹색, 파랑 및 알파 값을 나타내는 숫자입니다. 함수 매개 변수는 픽셀의 새로운 r, g, b 및 값이되는 최대 네 개의 숫자 값을 반환 할 수 있습니다. 함수가 반환하는 값이 더 적 으면 나머지 구성 요소는 0으로 설정됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ImageData:<wbr>mapPixel( <span class = "arguments">pixelFunction</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">pixelFunction</td><td class = "ra_type">function</td><td>모든 픽셀에 적용 할 함수 매개 변수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:paste" name = "ImageData:paste"><span>ImageData:</span><wbr>paste</a></p><p class = "function_description">다른 소스 ImageData의 ImageData에 붙여 넣습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ImageData:<wbr>paste( <span class = "arguments">source</span>, <span class = "arguments">dx</span>, <span class = "arguments">dy</span>, <span class = "arguments">sx</span>, <span class = "arguments">sy</span>, <span class = "arguments">sw</span>, <span class = "arguments">sh</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">source</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>복사 할 <a href="#Source">Source</a> <a href="#ImageData">ImageData</a>입니다.</td></tr><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>X 축상의 목적지 왼쪽 위 위치.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>y 축상의 상단 왼쪽 위치입니다.</td></tr><tr><td class = "arguments ra_name">sx</td><td class = "ra_type">number</td><td>x 축상의 좌상 구석의 위치에 있습니다.</td></tr><tr><td class = "arguments ra_name">sy</td><td class = "ra_type">number</td><td>y 축상의 좌상 구석을 나타냅니다.</td></tr><tr><td class = "arguments ra_name">sw</td><td class = "ra_type">number</td><td>소스 폭.</td></tr><tr><td class = "arguments ra_name">sh</td><td class = "ra_type">number</td><td>소스 높이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ImageData:setPixel" name = "ImageData:setPixel"><span>ImageData:</span><wbr>setPixel</a></p><p class = "function_description">이미지의 특정 위치에있는 픽셀의 색상을 설정합니다.<br /><br />유효한 x 및 y 값은 0에서 시작하여 이미지 너비와 높이에서 1을 뺀 값까지 올라갑니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ImageData:<wbr>setPixel( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">r</span>, <span class = "arguments">g</span>, <span class = "arguments">b</span>, <span class = "arguments">a</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축상의 픽셀의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축의 픽셀 위치입니다.</td></tr><tr><td class = "arguments ra_name">r</td><td class = "ra_type">number</td><td>빨간색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">g</td><td class = "ra_type">number</td><td>녹색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">b</td><td class = "ra_type">number</td><td>파란색 구성 요소 (0-255).</td></tr><tr><td class = "arguments ra_name">a</td><td class = "ra_type">number</td><td>알파 성분 (0-255).</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.joystick" name = "love.joystick">love.joystick</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joystick">Joystick</a>&emsp;물리적 조이스틱을 표현합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.joystick.<a href="#love.joystick.getJoystickCount">getJoystickCount</a>&emsp;연결된 조이스틱의 개수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.joystick.<a href="#love.joystick.getJoysticks">getJoysticks</a>&emsp;연결된 조이스틱 리스트를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.joystick.<a href="#love.joystick.loadGamepadMappings">loadGamepadMappings</a>&emsp;love.joystick.saveGamepadMappings로 만든 게임 패드 매핑 문자열 또는 파일을로드합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.joystick.<a href="#love.joystick.saveGamepadMappings">saveGamepadMappings</a>&emsp;게임 패드로 인식되고 최근에 사용되었거나 게임 패드 바인딩이 수정 된 모든 조이스틱의 가상 게임 패드 매핑을 저장합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.joystick.<a href="#love.joystick.setGamepadMapping">setGamepadMapping</a>&emsp;조이스틱 버튼, 축, 햇을 가상 게임패드에 매핑합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#GamepadAxis">GamepadAxis</a>&emsp;가상 게임패드에서 지원하는 조이스틱 축의 종류입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#GamepadButton">GamepadButton</a>&emsp;가상 게임패드에서 지원하는 조이스틱 버튼의 종류입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#JoystickHat">JoystickHat</a>&emsp;조이스틱 햇의 위치를 표현합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#JoystickInputType">JoystickInputType</a>&emsp;조이스틱 입력의 종류입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.joystick.getJoystickCount" name = "love.joystick.getJoystickCount"><span>love.joystick.</span><wbr>getJoystickCount</a></p><p class = "function_description">연결된 조이스틱의 개수를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joystickcount</span> = love.joystick.<wbr>getJoystickCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joystickcount</td><td class = "ra_type">number</td><td>연결된 조이스틱의 개수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystick.getJoysticks" name = "love.joystick.getJoysticks"><span>love.joystick.</span><wbr>getJoysticks</a></p><p class = "function_description">연결된 조이스틱 리스트를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joysticks</span> = love.joystick.<wbr>getJoysticks()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joysticks</td><td class = "ra_type">table</td><td>연결된 조이스틱 리스트.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystick.loadGamepadMappings" name = "love.joystick.loadGamepadMappings"><span>love.joystick.</span><wbr>loadGamepadMappings</a></p><p class = "function_description"><a href="#love.joystick.saveGamepadMappings">love.joystick.saveGamepadMappings</a>로 만든 게임 패드 매핑 문자열 또는 파일을로드합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.joystick.<wbr>loadGamepadMappings( <span class = "arguments">filename</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">filename</td><td class = "ra_type">string</td><td>매핑 문자열을로드 할 파일 이름입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.joystick.<wbr>loadGamepadMappings( <span class = "arguments">mappings</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mappings</td><td class = "ra_type">string</td><td>로드 할 매핑 문자열입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystick.saveGamepadMappings" name = "love.joystick.saveGamepadMappings"><span>love.joystick.</span><wbr>saveGamepadMappings</a></p><p class = "function_description">게임 패드로 인식되고 최근에 사용되었거나 게임 패드 바인딩이 수정 된 모든 조이스틱의 가상 게임 패드 매핑을 저장합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mappings</span> = love.joystick.<wbr>saveGamepadMappings( <span class = "arguments">filename</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mappings</td><td class = "ra_type">string</td><td>파일에 기록 된 매핑 문자열입니다.</td></tr><tr><td class = "arguments ra_name">filename <span class = "default">(no file)</span></td><td class = "ra_type">string</td><td>매핑 문자열을 저장할 파일 이름입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.joystick.setGamepadMapping" name = "love.joystick.setGamepadMapping"><span>love.joystick.</span><wbr>setGamepadMapping</a></p><p class = "function_description">조이스틱 버튼, 축, 햇을 가상 게임패드에 매핑합니다. 매핑된 조이스틱은 가상 게임패드의 동작과 호환되어 가상 게임패드 관련 함수를 호출할 수 있게 됩니다.<br /><br />L&Ouml;VE에서는 잘 알려져 있는 여러 조이스틱에 대한 매핑 방법을 이미 가지고 있습니다.    이 함수는 L&Ouml;VE에서 지원하지 않는 조이스틱을 가상 게임패드에 매핑시킬 때 사용합니다. 만약 여러분의 게임이 좀 더 범용적으로 조이스틱을 지원하고 싶다면, 이 함수를 응용해 사용자가 직접 조이스틱을 매핑할 수 있는 옵션 화면을 만들어 보세요.<br /><br />가상 게임패드의 조이스틱 축과 버튼은 Xbox 360 컨트롤러에 맞추어져 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.joystick.<wbr>setGamepadMapping( <span class = "arguments">guid</span>, <span class = "arguments">button</span>, <span class = "arguments">inputtype</span>, <span class = "arguments">inputindex</span>, <span class = "arguments">hatdirection</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공적으로 적용되었으면 true.</td></tr><tr><td class = "arguments ra_name">guid</td><td class = "ra_type">string</td><td>매핑할 조이스틱의 GUID.</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type"><a href="#GamepadButton">GamepadButton</a></td><td>매핑할 가상 게임패드 지원 조이스틱 버튼.</td></tr><tr><td class = "arguments ra_name">inputtype</td><td class = "ra_type"><a href="#JoystickInputType">JoystickInputType</a></td><td>매핑할 입력 방식.</td></tr><tr><td class = "arguments ra_name">inputindex</td><td class = "ra_type">number</td><td>매핑할 조이스틱 축, 버튼, 햇의 인덱스.</td></tr><tr><td class = "arguments ra_name">hatdirection</td><td class = "ra_type"><a href="#JoystickHat">JoystickHat</a></td><td>매핑할 조이스틱 햇의 방향. 햇이 아니라면 nil.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.joystick.<wbr>setGamepadMapping( <span class = "arguments">guid</span>, <span class = "arguments">axis</span>, <span class = "arguments">inputtype</span>, <span class = "arguments">inputindex</span>, <span class = "arguments">hatdirection</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공적으로 적용되었으면 true.</td></tr><tr><td class = "arguments ra_name">guid</td><td class = "ra_type">string</td><td>매핑할 조이스틱의 GUID.</td></tr><tr><td class = "arguments ra_name">axis</td><td class = "ra_type"><a href="#GamepadAxis">GamepadAxis</a></td><td>매핑할 가상 게임패드 지원 조이스틱 축.</td></tr><tr><td class = "arguments ra_name">inputtype</td><td class = "ra_type"><a href="#JoystickInputType">JoystickInputType</a></td><td>매핑할 입력 방식.</td></tr><tr><td class = "arguments ra_name">inputindex</td><td class = "ra_type">number</td><td>매핑할 조이스틱 축, 버튼, 햇의 인덱스.</td></tr><tr><td class = "arguments ra_name">hatdirection</td><td class = "ra_type"><a href="#JoystickHat">JoystickHat</a></td><td>매핑할 조이스틱 햇의 방향. 햇이 아니라면 nil.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#GamepadAxis" name = "GamepadAxis">GamepadAxis</a></p><p class = "constant_name">leftx</p><p class = "constant_description">좌측 스틱의 x축.</p><p class = "constant_name">lefty</p><p class = "constant_description">좌측 스틱의 y축.</p><p class = "constant_name">rightx</p><p class = "constant_description">우측 스틱의 x축.</p><p class = "constant_name">righty</p><p class = "constant_description">우측 스틱의 y축.</p><p class = "constant_name">triggerleft</p><p class = "constant_description">왼쪽 아날로그 트리거.</p><p class = "constant_name">triggerright</p><p class = "constant_description">오른쪽 아날로그 트리거.</p></div><div class = "section"><p class = "section_heading"><a href = "#GamepadButton" name = "GamepadButton">GamepadButton</a></p><p class = "constant_name">a</p><p class = "constant_description">A 버튼(아래쪽).</p><p class = "constant_name">b</p><p class = "constant_description">B 버튼(오른쪽).</p><p class = "constant_name">x</p><p class = "constant_description">X 버튼(왼쪽).</p><p class = "constant_name">y</p><p class = "constant_description">Y 버튼(위쪽).</p><p class = "constant_name">back</p><p class = "constant_description">뒤로 버튼.</p><p class = "constant_name">guide</p><p class = "constant_description">가이드 버튼.</p><p class = "constant_name">start</p><p class = "constant_description">시작 버튼.</p><p class = "constant_name">leftstick</p><p class = "constant_description">좌측 스틱 누름 버튼.</p><p class = "constant_name">rightstick</p><p class = "constant_description">우측 스틱 누름 버튼.</p><p class = "constant_name">leftshoulder</p><p class = "constant_description">왼쪽 범퍼.</p><p class = "constant_name">rightshoulder</p><p class = "constant_description">오른쪽 범퍼.</p><p class = "constant_name">dpup</p><p class = "constant_description">방향 패드 위쪽.</p><p class = "constant_name">dpdown</p><p class = "constant_description">방향 패드 아래쪽.</p><p class = "constant_name">dpleft</p><p class = "constant_description">방향 패드 왼쪽.</p><p class = "constant_name">dpright</p><p class = "constant_description">방향 패드 오른쪽.</p></div><div class = "section"><p class = "section_heading"><a href = "#JoystickHat" name = "JoystickHat">JoystickHat</a></p><p class = "constant_name">c</p><p class = "constant_description">가운데</p><p class = "constant_name">d</p><p class = "constant_description">아래</p><p class = "constant_name">l</p><p class = "constant_description">왼쪽</p><p class = "constant_name">ld</p><p class = "constant_description">왼쪽 아래</p><p class = "constant_name">lu</p><p class = "constant_description">왼쪽 위</p><p class = "constant_name">r</p><p class = "constant_description">오른쪽</p><p class = "constant_name">rd</p><p class = "constant_description">오른쪽 아래</p><p class = "constant_name">ru</p><p class = "constant_description">오른쪽 위</p><p class = "constant_name">u</p><p class = "constant_description">위</p></div><div class = "section"><p class = "section_heading"><a href = "#JoystickInputType" name = "JoystickInputType">JoystickInputType</a></p><p class = "constant_name">axis</p><p class = "constant_description">아날로그 축 입력. 대표적으로 Xbox 360 컨트롤러의 좌 우측 스틱이 있으며 세밀한 이동까지도 감지.</p><p class = "constant_name">button</p><p class = "constant_description">버튼 입력.</p><p class = "constant_name">hat</p><p class = "constant_description">8방향 햇 입력. 대표적으로 오락실의 조종 스틱이 있으며 축에 비해 정교하지 못함.</p></div><div class = "section"><p class = "section_heading"><a href = "#Joystick" name = "Joystick">Joystick</a></p><p class = "section_description">물리적 조이스틱을 표현합니다. 일관적인 처리를 위해 조이스틱을 가상 게임패드(Xbox 360 컨트롤러)에 대응시켜 사용할 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.joystick.<a href="#love.joystick.getJoysticks">getJoysticks</a>&emsp;연결된 조이스틱 리스트를 얻어옵니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:isDown">isDown</a>&emsp;조이스틱 버튼이 눌렸는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getAxis">getAxis</a>&emsp;조이스틱 축의 위치를 하나 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getAxes">getAxes</a>&emsp;모든 조이스틱 축의 위치를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getHat">getHat</a>&emsp;조이스틱 햇의 위치를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:isGamepadDown">isGamepadDown</a>&emsp;가상 게임패드 호환 조이스틱 버튼이 눌렸는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getGamepadAxis">getGamepadAxis</a>&emsp;가상 게임패드 호환 조이스틱 축을 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getAxisCount">getAxisCount</a>&emsp;조이스틱 축의 개수를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getButtonCount">getButtonCount</a>&emsp;조이스틱 버튼의 개수를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getHatCount">getHatCount</a>&emsp;조이스틱 햇의 개수를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getName">getName</a>&emsp;조이스틱의 이름을 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getID">getID</a>&emsp;조이스틱 고유의 ID를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getGUID">getGUID</a>&emsp;물리적 조이스틱의 고유한 GUID를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:isConnected">isConnected</a>&emsp;조이스틱이 현재 연결되어 있는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:isGamepad">isGamepad</a>&emsp;조이스틱을 가상 게임 패드로 여길 수 있는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getGamepadMapping">getGamepadMapping</a>&emsp;가상 게임패드에 매핑된 조이스틱 버튼, 축, 햇을 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:getVibration">get</a><span class = "slash">/</span><a href="#Joystick:setVibration">setVibration</a>&emsp;진동 모터의 진도를 설정해 진동을 일으킵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joystick:<a href="#Joystick:isVibrationSupported">isVibrationSupported</a>&emsp;조이스틱이 진동을 지원하는지를 조사합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getAxes" name = "Joystick:getAxes"><span>Joystick:</span><wbr>getAxes</a></p><p class = "function_description">모든 조이스틱 축의 위치를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">axisDir1</span>, <span class = "returns">axisDir2</span>, <span class = "returns">axisDirN</span> = Joystick:<wbr>getAxes()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">axisDir1</td><td class = "ra_type">number</td><td>첫 번째 축.</td></tr><tr><td class = "returns ra_name">axisDir2</td><td class = "ra_type">number</td><td>두 번째 축.</td></tr><tr><td class = "returns ra_name">axisDirN</td><td class = "ra_type">number</td><td>n번째 축.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getAxis" name = "Joystick:getAxis"><span>Joystick:</span><wbr>getAxis</a></p><p class = "function_description">조이스틱 축의 위치를 하나 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">direction</span> = Joystick:<wbr>getAxis( <span class = "arguments">axis</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">direction</td><td class = "ra_type">number</td><td>축의 값.</td></tr><tr><td class = "arguments ra_name">axis</td><td class = "ra_type">number</td><td>얻어올 조이스틱 축의 인덱스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getAxisCount" name = "Joystick:getAxisCount"><span>Joystick:</span><wbr>getAxisCount</a></p><p class = "function_description">조이스틱 축의 개수를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">axes</span> = Joystick:<wbr>getAxisCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">axes</td><td class = "ra_type">number</td><td>조이스틱 축의 개수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getButtonCount" name = "Joystick:getButtonCount"><span>Joystick:</span><wbr>getButtonCount</a></p><p class = "function_description">조이스틱 버튼의 개수를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">buttons</span> = Joystick:<wbr>getButtonCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">buttons</td><td class = "ra_type">number</td><td>조이스틱 버튼의 개수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getGUID" name = "Joystick:getGUID"><span>Joystick:</span><wbr>getGUID</a></p><p class = "function_description">물리적 조이스틱의 고유한 GUID를 얻어옵니다. 이 GUID는 제품의 종류를 구별하는 데 쓰일 수 있습니다. 제품 각각을 구별하는 것이 아님을 유의하세요. 또한 이 값은 운영 체제에 의존적이기도 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">guid</span> = Joystick:<wbr>getGUID()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">guid</td><td class = "ra_type">string</td><td>운영 체제에 의존적인 GUID.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getGamepadAxis" name = "Joystick:getGamepadAxis"><span>Joystick:</span><wbr>getGamepadAxis</a></p><p class = "function_description">가상 게임패드 호환 조이스틱 축을 얻어옵니다. 조이스틱이 가상 게임패드로 여겨지지 않거나 연결되지 않았을 경우, 이 함수는 항상 0을 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">direction</span> = Joystick:<wbr>getGamepadAxis( <span class = "arguments">axis</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">direction</td><td class = "ra_type">number</td><td>축의 값.</td></tr><tr><td class = "arguments ra_name">axis</td><td class = "ra_type"><a href="#GamepadAxis">GamepadAxis</a></td><td>확인할 가상 게임패드 호환 조이스틱 축.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getGamepadMapping" name = "Joystick:getGamepadMapping"><span>Joystick:</span><wbr>getGamepadMapping</a></p><p class = "function_description">가상 게임패드에 매핑된 조이스틱 버튼, 축, 햇을 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">inputtype</span>, <span class = "returns">inputindex</span>, <span class = "returns">hatdirection</span> = Joystick:<wbr>getGamepadMapping( <span class = "arguments">axis</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">inputtype</td><td class = "ra_type"><a href="#JoystickInputType">JoystickInputType</a></td><td>매핑된 입력 방식.</td></tr><tr><td class = "returns ra_name">inputindex</td><td class = "ra_type">number</td><td>매핑된 조이스틱 축, 버튼, 햇의 인덱스.</td></tr><tr><td class = "returns ra_name">hatdirection</td><td class = "ra_type"><a href="#JoystickHat">JoystickHat</a></td><td>매핑된 조이스틱 햇의 방향. 햇이 아니라면 nil.</td></tr><tr><td class = "arguments ra_name">axis</td><td class = "ra_type"><a href="#GamepadAxis">GamepadAxis</a></td><td>매핑을 확인할 가상 게임패드 지원 조이스틱 축.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">inputtype</span>, <span class = "returns">inputindex</span>, <span class = "returns">hatdirection</span> = Joystick:<wbr>getGamepadMapping( <span class = "arguments">button</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">inputtype</td><td class = "ra_type"><a href="#JoystickInputType">JoystickInputType</a></td><td>매핑된 입력 방식.</td></tr><tr><td class = "returns ra_name">inputindex</td><td class = "ra_type">number</td><td>매핑된 조이스틱 축, 버튼, 햇의 인덱스.</td></tr><tr><td class = "returns ra_name">hatdirection</td><td class = "ra_type"><a href="#JoystickHat">JoystickHat</a></td><td>매핑된 조이스틱 햇의 방향. 햇이 아니라면 nil.</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type"><a href="#GamepadAxis">GamepadAxis</a></td><td>매핑을 확인할 가상 게임패드 지원 조이스틱 축.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getHat" name = "Joystick:getHat"><span>Joystick:</span><wbr>getHat</a></p><p class = "function_description">조이스틱 햇의 위치를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">direction</span> = Joystick:<wbr>getHat( <span class = "arguments">hat</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">direction</td><td class = "ra_type"><a href="#JoystickHat">JoystickHat</a></td><td>모자가 밀리는 방향.</td></tr><tr><td class = "arguments ra_name">hat</td><td class = "ra_type">number</td><td>검사 할 모자 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getHatCount" name = "Joystick:getHatCount"><span>Joystick:</span><wbr>getHatCount</a></p><p class = "function_description">조이스틱 햇의 개수를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">hats</span> = Joystick:<wbr>getHatCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">hats</td><td class = "ra_type">number</td><td>조이스틱 햇의 개수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getID" name = "Joystick:getID"><span>Joystick:</span><wbr>getID</a></p><p class = "function_description">조이스틱 고유의 ID를 구합니다. 게임이 실행되는 동안 동일한 조이스틱이 연결 끊기와 재연결을 반복할지라도 ID는 변함이 없지만, 게임이 재실행 되었을 경우 ID가 동일할 것이라는 보장은 없습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">id</span>, <span class = "returns">instanceid</span> = Joystick:<wbr>getID()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">id</td><td class = "ra_type">number</td><td>조이스틱 ID.</td></tr><tr><td class = "returns ra_name">instanceid</td><td class = "ra_type">number</td><td>휘발성 ID. 조이스틱이 재연결될 때마다 매번 변함. 조이스틱이 한 번도 연결된 적이 없다면 nil.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getName" name = "Joystick:getName"><span>Joystick:</span><wbr>getName</a></p><p class = "function_description">조이스틱의 이름을 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">name</span> = Joystick:<wbr>getName()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">name</td><td class = "ra_type">string</td><td>조이스틱 이름.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:getVibration" name = "Joystick:getVibration"><span>Joystick:</span><wbr>getVibration</a></p><p class = "function_description">현재 진동 모터의 진도를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">left</span>, <span class = "returns">right</span> = Joystick:<wbr>getVibration()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">left</td><td class = "ra_type">number</td><td>좌측 진동 모터의 진도.</td></tr><tr><td class = "returns ra_name">right</td><td class = "ra_type">number</td><td>우측 진동 모터의 진도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:isConnected" name = "Joystick:isConnected"><span>Joystick:</span><wbr>isConnected</a></p><p class = "function_description">조이스틱이 현재 연결되어 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">connected</span> = Joystick:<wbr>isConnected()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">connected</td><td class = "ra_type">boolean</td><td>조이스틱이 현재 연결되어 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:isDown" name = "Joystick:isDown"><span>Joystick:</span><wbr>isDown</a></p><p class = "function_description">조이스틱 버튼이 눌렸는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">anyDown</span> = Joystick:<wbr>isDown( <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">anyDown</td><td class = "ra_type">boolean</td><td>하나라도 눌려져 있으면 true.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>확인할 조이스틱 버튼의 인덱스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:isGamepad" name = "Joystick:isGamepad"><span>Joystick:</span><wbr>isGamepad</a></p><p class = "function_description">조이스틱을 가상 게임 패드로 여길 수 있는지 확인합니다.<br /><br />L&Ouml;VE는 자동적으로 잘 알려져 있는 컨트롤러들의 레이아웃을 Xbox 360의 버튼과 축 위치에 맞게 자동으로 매핑합니다. 만약 자동으로 매핑되지 않는 컨트롤러를 매핑시키고 싶다면 <a href="#love.joystick.setGamepadMapping">love.joystick.setGamepadMapping</a>을 사용하세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">isgamepad</span> = Joystick:<wbr>isGamepad()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">isgamepad</td><td class = "ra_type">boolean</td><td>가상 게임 패드로 여길 수 있다면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:isGamepadDown" name = "Joystick:isGamepadDown"><span>Joystick:</span><wbr>isGamepadDown</a></p><p class = "function_description">가상 게임패드 호환 조이스틱 버튼이 눌렸는지 확인합니다. 조이스틱이 가상 게임패드로 여겨지지 않거나 연결되지 않았을 경우, 이 함수는 항상 0을 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">anyDown</span> = Joystick:<wbr>isGamepadDown( <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">anyDown</td><td class = "ra_type">boolean</td><td>단 하나의 버튼이라도 눌려있으면 true.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type"><a href="#GamepadButton">GamepadButton</a></td><td>확인할 가상 게임패드 호환 조이스틱 버튼.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:isVibrationSupported" name = "Joystick:isVibrationSupported"><span>Joystick:</span><wbr>isVibrationSupported</a></p><p class = "function_description">조이스틱이 진동을 지원하는지를 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">supported</span> = Joystick:<wbr>isVibrationSupported()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">supported</td><td class = "ra_type">boolean</td><td>rumble / force feedback vibration이 지원되면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joystick:setVibration" name = "Joystick:setVibration"><span>Joystick:</span><wbr>setVibration</a></p><p class = "function_description">진동 모터의 진도를 설정해 진동을 일으킵니다. 대부분의 조이스틱은 적절한 드라이버의 적절한 지원 없이도 적절하게 잘 작동합니다. 사용하기에 앞서 Joystick:isVibrationSupported를 통해 진동 지원 여부를 확인하세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = Joystick:<wbr>setVibration( <span class = "arguments">left</span>, <span class = "arguments">right</span>, <span class = "arguments">duration</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>진동이 성공적으로 적용되면 true이고, 그렇지 않으면 false입니다.</td></tr><tr><td class = "arguments ra_name">left</td><td class = "ra_type">number</td><td>조이스틱에서 왼쪽 진동 모터의 강도. {0, 1}의 범위 내에 있어야합니다.</td></tr><tr><td class = "arguments ra_name">right</td><td class = "ra_type">number</td><td>조이스틱에 적합한 진동 모터의 강도. {0, 1}의 범위 내에 있어야합니다.</td></tr><tr><td class = "arguments ra_name">duration <span class = "default">(-1)</span></td><td class = "ra_type">number</td><td>진동 지속 시간 (초). 음수 값은 무한 지속 시간을 의미합니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.keyboard" name = "love.keyboard">love.keyboard</a></p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.keyboard.<a href="#love.keyboard.isDown">isDown</a>&emsp;특정 키가 눌렸는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.keyboard.<a href="#love.keyboard.isScancodeDown">isScancodeDown</a>&emsp;지정된 Scancodes가 눌러 졌는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.keyboard.<a href="#love.keyboard.getScancodeFromKey">getScancodeFromKey</a>&emsp;지정된 키에 해당하는 하드웨어 스캔 코드를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.keyboard.<a href="#love.keyboard.getKeyFromScancode">getKeyFromScancode</a>&emsp;지정된 하드웨어 스캔 코드에 해당하는 키를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.keyboard.<a href="#love.keyboard.hasKeyRepeat">has</a><span class = "slash">/</span><a href="#love.keyboard.setKeyRepeat">setKeyRepeat</a>&emsp;키 반복 입력을 감지할 것인지 결정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.keyboard.<a href="#love.keyboard.hasTextInput">has</a><span class = "slash">/</span><a href="#love.keyboard.setTextInput">setTextInput</a>&emsp;텍스트 입력을 감지할 것인지. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#KeyConstant">KeyConstant</a>&emsp;누를 수있는 모든 키. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Scancode">Scancode</a>&emsp;키보드 스캔 코드. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.getKeyFromScancode" name = "love.keyboard.getKeyFromScancode"><span>love.keyboard.</span><wbr>getKeyFromScancode</a></p><p class = "function_description">지정된 하드웨어 스캔 코드에 해당하는 키를 가져옵니다.<br /><br />키 상수와 달리 Scancodes는 키보드 레이아웃에 독립적입니다. 예를 들어 미국 키보드의 "w"키와 동일한 위치에있는 키가 눌러 진 경우 키의 레이블이 무엇이든 사용자의 운영 체제 설정이 무엇이든 관계없이 스캔 코드 "w"가 생성됩니다.<br /><br />Scancodes는 모든 시스템에서 동일한 물리적 위치를 가진 기본 컨트롤을 만드는 데 유용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">key</span> = love.keyboard.<wbr>getKeyFromScancode( <span class = "arguments">scancode</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">key</td><td class = "ra_type"><a href="#KeyConstant">KeyConstant</a></td><td>지정된 스캔 코드에 대응하는 키. 스캔 코드가 현재의 시스템의 KeyConstant에 매핑되어 있지 않은 경우는 「미지의」</td></tr><tr><td class = "arguments ra_name">scancode</td><td class = "ra_type"><a href="#Scancode">Scancode</a></td><td>스캔 코드는 키를 가져옵니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.getScancodeFromKey" name = "love.keyboard.getScancodeFromKey"><span>love.keyboard.</span><wbr>getScancodeFromKey</a></p><p class = "function_description">지정된 키에 해당하는 하드웨어 스캔 코드를 가져옵니다.<br /><br />키 상수와 달리 Scancodes는 키보드 레이아웃에 독립적입니다. 예를 들어 미국 키보드의 "w"키와 동일한 위치에있는 키가 눌러 진 경우 키의 레이블이 무엇이든 사용자의 운영 체제 설정이 무엇이든 관계없이 스캔 코드 "w"가 생성됩니다.<br /><br />Scancodes는 모든 시스템에서 동일한 물리적 위치를 가진 기본 컨트롤을 만드는 데 유용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">scancode</span> = love.keyboard.<wbr>getScancodeFromKey( <span class = "arguments">key</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">scancode</td><td class = "ra_type"><a href="#Scancode">Scancode</a></td><td>지정된 키에 대응하는 스캔 코드. 또는 지정된 키가 현재의 시스템 상에 실제적인 표현을 가지지 않는 경우는 "unknown".</td></tr><tr><td class = "arguments ra_name">key</td><td class = "ra_type"><a href="#KeyConstant">KeyConstant</a></td><td>스캔 코드를 가져 오는 키.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.hasKeyRepeat" name = "love.keyboard.hasKeyRepeat"><span>love.keyboard.</span><wbr>hasKeyRepeat</a></p><p class = "function_description">키 반복 입력을 감지하고 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = love.keyboard.<wbr>hasKeyRepeat()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>키를 누르고 있을 때 반복적으로 감지하고 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.hasTextInput" name = "love.keyboard.hasTextInput"><span>love.keyboard.</span><wbr>hasTextInput</a></p><p class = "function_description">텍스트 입력을 감지하고 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = love.keyboard.<wbr>hasTextInput()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>텍스트 입력을 감지하고 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.isDown" name = "love.keyboard.isDown"><span>love.keyboard.</span><wbr>isDown</a></p><p class = "function_description">특정 키가 눌렸는지 확인합니다. love.keypressed나 love.keyreleased와 혼동하지 마세요.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">anyDown</span> = love.keyboard.<wbr>isDown( <span class = "arguments">key</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">anyDown</td><td class = "ra_type">boolean</td><td>제공된 키가 모두 없으면 true이고, 그렇지 않으면 false입니다.</td></tr><tr><td class = "arguments ra_name">key</td><td class = "ra_type"><a href="#KeyConstant">KeyConstant</a></td><td>확인할 열쇠.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type"><a href="#KeyConstant">KeyConstant</a></td><td>확인할 추가 키.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.isScancodeDown" name = "love.keyboard.isScancodeDown"><span>love.keyboard.</span><wbr>isScancodeDown</a></p><p class = "function_description">지정된 Scancodes가 눌러 졌는지 확인합니다. 사랑과 혼동해서는 안됩니다.<br /><br />일반적인 KeyConstants와 달리 Scancodes는 키보드 레이아웃에 독립적입니다. 스캔 코드 "w"는 미국 키보드의 "w"키와 동일한 위치에있는 키가 눌러 진 키가 무엇인지 또는 사용자의 운영 체제 설정이 무엇이든 상관없이 사용됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">down</span> = love.keyboard.<wbr>isScancodeDown( <span class = "arguments">scancode</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">down</td><td class = "ra_type">boolean</td><td>제공된 Scancode가 다운 된 경우 true이고, 그렇지 않은 경우 false입니다.</td></tr><tr><td class = "arguments ra_name">scancode</td><td class = "ra_type"><a href="#Scancode">Scancode</a></td><td>확인할 Scancode.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type"><a href="#Scancode">Scancode</a></td><td>검사 할 추가 Scancodes.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.setKeyRepeat" name = "love.keyboard.setKeyRepeat"><span>love.keyboard.</span><wbr>setKeyRepeat</a></p><p class = "function_description">키 반복 입력을 감지할 것인지 결정합니다. 기본값은 감지하지 않음 입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.keyboard.<wbr>setKeyRepeat( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>키를 누르고 있을 때 반복적으로 감지하려면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.keyboard.setTextInput" name = "love.keyboard.setTextInput"><span>love.keyboard.</span><wbr>setTextInput</a></p><p class = "function_description">텍스트 입력을 감지할 것인지. 설정합니다. 기본값은 감지함 입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.keyboard.<wbr>setTextInput( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>텍스트 입력을 감지하려면 true.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.keyboard.<wbr>setTextInput( <span class = "arguments">enable</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">w</span>, <span class = "arguments">h</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>텍스트 입력 이벤트의 사용 가능 여부.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>화면 키보드 x 위치.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>화면상의 키보드 y 위치.</td></tr><tr><td class = "arguments ra_name">w</td><td class = "ra_type">number</td><td>화면상의 키보드 너비.</td></tr><tr><td class = "arguments ra_name">h</td><td class = "ra_type">number</td><td>화면상의 키보드 높이.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#KeyConstant" name = "KeyConstant">KeyConstant</a></p><p class = "constant_name">a</p><p class = "constant_description">A 키</p><p class = "constant_name">b</p><p class = "constant_description">B 키</p><p class = "constant_name">c</p><p class = "constant_description">C 키</p><p class = "constant_name">d</p><p class = "constant_description">D 키</p><p class = "constant_name">e</p><p class = "constant_description">E 키</p><p class = "constant_name">f</p><p class = "constant_description">F 키</p><p class = "constant_name">g</p><p class = "constant_description">G 키</p><p class = "constant_name">h</p><p class = "constant_description">H 키</p><p class = "constant_name">i</p><p class = "constant_description">I 키</p><p class = "constant_name">j</p><p class = "constant_description">J 키</p><p class = "constant_name">k</p><p class = "constant_description">K 키</p><p class = "constant_name">l</p><p class = "constant_description">L 키</p><p class = "constant_name">m</p><p class = "constant_description">M 키</p><p class = "constant_name">n</p><p class = "constant_description">N 키</p><p class = "constant_name">o</p><p class = "constant_description">O 키</p><p class = "constant_name">p</p><p class = "constant_description">P 키</p><p class = "constant_name">q</p><p class = "constant_description">Q 키</p><p class = "constant_name">r</p><p class = "constant_description">R 키</p><p class = "constant_name">s</p><p class = "constant_description">S 키</p><p class = "constant_name">t</p><p class = "constant_description">T 키</p><p class = "constant_name">u</p><p class = "constant_description">U 키</p><p class = "constant_name">v</p><p class = "constant_description">V 키</p><p class = "constant_name">w</p><p class = "constant_description">W 키</p><p class = "constant_name">x</p><p class = "constant_description">X 키</p><p class = "constant_name">y</p><p class = "constant_description">Y 키</p><p class = "constant_name">z</p><p class = "constant_description">Z 키</p><p class = "constant_name">0</p><p class = "constant_description">제로 키</p><p class = "constant_name">1</p><p class = "constant_description">하나의 열쇠</p><p class = "constant_name">2</p><p class = "constant_description">두 가지 열쇠</p><p class = "constant_name">3</p><p class = "constant_description">세 가지 열쇠</p><p class = "constant_name">4</p><p class = "constant_description">네 개의 열쇠</p><p class = "constant_name">5</p><p class = "constant_description">다섯 가지 열쇠</p><p class = "constant_name">6</p><p class = "constant_description">6 개의 열쇠</p><p class = "constant_name">7</p><p class = "constant_description">일곱 열쇠</p><p class = "constant_name">8</p><p class = "constant_description">8 개의 열쇠</p><p class = "constant_name">9</p><p class = "constant_description">아홉 개의 열쇠</p><p class = "constant_name">space</p><p class = "constant_description">스페이스 키</p><p class = "constant_name">!</p><p class = "constant_description">느낌표 키</p><p class = "constant_name">"</p><p class = "constant_description">큰 따옴표 키</p><p class = "constant_name">#</p><p class = "constant_description">해시 키</p><p class = "constant_name">$</p><p class = "constant_description">달러 키</p><p class = "constant_name">&</p><p class = "constant_description">앰퍼샌드 키</p><p class = "constant_name">'</p><p class = "constant_description">작은 따옴표 키</p><p class = "constant_name">(</p><p class = "constant_description">왼쪽 괄호 키</p><p class = "constant_name">)</p><p class = "constant_description">오른쪽 괄호 키</p><p class = "constant_name">*</p><p class = "constant_description">별표 키</p><p class = "constant_name">+</p><p class = "constant_description">플러스 키</p><p class = "constant_name">,</p><p class = "constant_description">쉼표 키</p><p class = "constant_name">-</p><p class = "constant_description">하이픈 - 빼기 키</p><p class = "constant_name">.</p><p class = "constant_description">풀 스톱 키</p><p class = "constant_name">/</p><p class = "constant_description">슬래시 키</p><p class = "constant_name">:</p><p class = "constant_description">결장 열쇠</p><p class = "constant_name">;</p><p class = "constant_description">세미콜론 키</p><p class = "constant_name"><</p><p class = "constant_description">덜 중요한 키</p><p class = "constant_name">=</p><p class = "constant_description">동일 키</p><p class = "constant_name">></p><p class = "constant_description">보다 큰 키</p><p class = "constant_name">?</p><p class = "constant_description">물음표 키</p><p class = "constant_name">@</p><p class = "constant_description">기호 키에서</p><p class = "constant_name">[</p><p class = "constant_description">왼쪽 대괄호 키</p><p class = "constant_name">\</p><p class = "constant_description">백 슬래시 키</p><p class = "constant_name">]</p><p class = "constant_description">오른쪽 대괄호 키</p><p class = "constant_name">^</p><p class = "constant_description">캐럿 키</p><p class = "constant_name">_</p><p class = "constant_description">밑줄 키</p><p class = "constant_name">`</p><p class = "constant_description">악센트 부호 키</p><p class = "constant_name">kp0</p><p class = "constant_description">숫자 키패드 0 키</p><p class = "constant_name">kp1</p><p class = "constant_description">숫자 키패드 하나</p><p class = "constant_name">kp2</p><p class = "constant_description">숫자 키패드 2 개</p><p class = "constant_name">kp3</p><p class = "constant_description">숫자 키패드 3 개</p><p class = "constant_name">kp4</p><p class = "constant_description">숫자 키패드 4 개</p><p class = "constant_name">kp5</p><p class = "constant_description">숫자 키패드 5 개</p><p class = "constant_name">kp6</p><p class = "constant_description">숫자 키패드 6 개</p><p class = "constant_name">kp7</p><p class = "constant_description">숫자 키패드 7 개 키</p><p class = "constant_name">kp8</p><p class = "constant_description">숫자 키패드 8 개 키</p><p class = "constant_name">kp9</p><p class = "constant_description">숫자 키패드 9 개</p><p class = "constant_name">kp.</p><p class = "constant_description">숫자판 소수점 키</p><p class = "constant_name">kp/</p><p class = "constant_description">숫자 키패드 키</p><p class = "constant_name">kp*</p><p class = "constant_description">숫자 키패드 키</p><p class = "constant_name">kp-</p><p class = "constant_description">숫자가있는 빼기 키</p><p class = "constant_name">kp+</p><p class = "constant_description">숫자 키 추가 키</p><p class = "constant_name">kpenter</p><p class = "constant_description">숫자 키 입력 키</p><p class = "constant_name">kp=</p><p class = "constant_description">숫자 키패드는 키와 같습니다.</p><p class = "constant_name">up</p><p class = "constant_description">위로 커서 키</p><p class = "constant_name">down</p><p class = "constant_description">아래 커서 키</p><p class = "constant_name">right</p><p class = "constant_description">오른쪽 커서 키</p><p class = "constant_name">left</p><p class = "constant_description">왼쪽 커서 키</p><p class = "constant_name">home</p><p class = "constant_description">홈 키</p><p class = "constant_name">end</p><p class = "constant_description">종료 키</p><p class = "constant_name">pageup</p><p class = "constant_description">페이지 위로 키</p><p class = "constant_name">pagedown</p><p class = "constant_description">Page down 키</p><p class = "constant_name">insert</p><p class = "constant_description">키 삽입</p><p class = "constant_name">backspace</p><p class = "constant_description">백 스페이스 키</p><p class = "constant_name">tab</p><p class = "constant_description">탭 키</p><p class = "constant_name">clear</p><p class = "constant_description">클리어 키</p><p class = "constant_name">return</p><p class = "constant_description">Return 키</p><p class = "constant_name">delete</p><p class = "constant_description">키 삭제</p><p class = "constant_name">f1</p><p class = "constant_description">첫 번째 기능 키</p><p class = "constant_name">f2</p><p class = "constant_description">두 번째 기능 키</p><p class = "constant_name">f3</p><p class = "constant_description">세 번째 기능 키</p><p class = "constant_name">f4</p><p class = "constant_description">네 번째 기능 키</p><p class = "constant_name">f5</p><p class = "constant_description">다섯 번째 기능 키</p><p class = "constant_name">f6</p><p class = "constant_description">6 번째 기능 키</p><p class = "constant_name">f7</p><p class = "constant_description">일곱 번째 기능 키</p><p class = "constant_name">f8</p><p class = "constant_description">8 번째 기능 키</p><p class = "constant_name">f9</p><p class = "constant_description">9 번째 기능 키</p><p class = "constant_name">f10</p><p class = "constant_description">10 번째 기능 키</p><p class = "constant_name">f11</p><p class = "constant_description">11 번째 기능 키</p><p class = "constant_name">f12</p><p class = "constant_description">12 번째 기능 키</p><p class = "constant_name">f13</p><p class = "constant_description">13 번째 기능 키</p><p class = "constant_name">f14</p><p class = "constant_description">14 번째 기능 키</p><p class = "constant_name">f15</p><p class = "constant_description">15 번째 기능 키</p><p class = "constant_name">numlock</p><p class = "constant_description">Num Lock 키</p><p class = "constant_name">capslock</p><p class = "constant_description">Caps-lock 키</p><p class = "constant_name">scrollock</p><p class = "constant_description">스크롤 잠금 키</p><p class = "constant_name">rshift</p><p class = "constant_description">오른쪽 시프트 키</p><p class = "constant_name">lshift</p><p class = "constant_description">왼쪽 시프트 키</p><p class = "constant_name">rctrl</p><p class = "constant_description">오른쪽 컨트롤 키</p><p class = "constant_name">lctrl</p><p class = "constant_description">왼쪽 컨트롤 키</p><p class = "constant_name">ralt</p><p class = "constant_description">오른쪽 Alt 키</p><p class = "constant_name">lalt</p><p class = "constant_description">왼쪽 Alt 키</p><p class = "constant_name">rmeta</p><p class = "constant_description">오른쪽 메타 키</p><p class = "constant_name">lmeta</p><p class = "constant_description">왼쪽 메타 키</p><p class = "constant_name">lsuper</p><p class = "constant_description">왼쪽 수퍼 키</p><p class = "constant_name">rsuper</p><p class = "constant_description">오른쪽 수퍼 키</p><p class = "constant_name">mode</p><p class = "constant_description">모드 키</p><p class = "constant_name">compose</p><p class = "constant_description">작성 키</p><p class = "constant_name">pause</p><p class = "constant_description">일시 중지 키</p><p class = "constant_name">escape</p><p class = "constant_description">이스케이프 키</p><p class = "constant_name">help</p><p class = "constant_description">도움말 키</p><p class = "constant_name">print</p><p class = "constant_description">인쇄 키</p><p class = "constant_name">sysreq</p><p class = "constant_description">시스템 요청 키</p><p class = "constant_name">break</p><p class = "constant_description">브레이크 키</p><p class = "constant_name">menu</p><p class = "constant_description">메뉴 키</p><p class = "constant_name">power</p><p class = "constant_description">전원 키</p><p class = "constant_name">euro</p><p class = "constant_description">유로 (&euro; 유로) 키</p><p class = "constant_name">undo</p><p class = "constant_description">실행 취소 키</p><p class = "constant_name">www</p><p class = "constant_description">WWW 키</p><p class = "constant_name">mail</p><p class = "constant_description">메일 키</p><p class = "constant_name">calculator</p><p class = "constant_description">계산기 키</p><p class = "constant_name">appsearch</p><p class = "constant_description">응용 프로그램 검색 키</p><p class = "constant_name">apphome</p><p class = "constant_description">응용 프로그램 홈 키</p><p class = "constant_name">appback</p><p class = "constant_description">응용 프로그램 뒤로 키</p><p class = "constant_name">appforward</p><p class = "constant_description">응용 프로그램 전달 키</p><p class = "constant_name">apprefresh</p><p class = "constant_description">응용 프로그램 새로 고침 키</p><p class = "constant_name">appbookmarks</p><p class = "constant_description">응용 프로그램 책갈피 키</p></div><div class = "section"><p class = "section_heading"><a href = "#Scancode" name = "Scancode">Scancode</a></p><p class = "constant_name">a</p><p class = "constant_description">미국 레이아웃의 'A'키.</p><p class = "constant_name">b</p><p class = "constant_description">미국 레이아웃의 'B'키.</p><p class = "constant_name">c</p><p class = "constant_description">미국 레이아웃의 'C'키.</p><p class = "constant_name">d</p><p class = "constant_description">미국 레이아웃의 'D'키.</p><p class = "constant_name">e</p><p class = "constant_description">미국 레이아웃의 'E'키.</p><p class = "constant_name">f</p><p class = "constant_description">미국 레이아웃의 'F'키.</p><p class = "constant_name">g</p><p class = "constant_description">미국 레이아웃의 'G'키.</p><p class = "constant_name">h</p><p class = "constant_description">미국 레이아웃의 'H'키.</p><p class = "constant_name">i</p><p class = "constant_description">미국 레이아웃의 'I'키.</p><p class = "constant_name">j</p><p class = "constant_description">미국 레이아웃의 'J'키.</p><p class = "constant_name">k</p><p class = "constant_description">미국 레이아웃의 'K'키.</p><p class = "constant_name">l</p><p class = "constant_description">미국 레이아웃의 'L'키.</p><p class = "constant_name">m</p><p class = "constant_description">미국 레이아웃의 'M'키.</p><p class = "constant_name">n</p><p class = "constant_description">미국 레이아웃의 'N'키.</p><p class = "constant_name">o</p><p class = "constant_description">미국 레이아웃의 'O'키.</p><p class = "constant_name">p</p><p class = "constant_description">미국 레이아웃의 'P'키.</p><p class = "constant_name">q</p><p class = "constant_description">미국 레이아웃의 'Q'키.</p><p class = "constant_name">r</p><p class = "constant_description">미국 레이아웃의 'R'키.</p><p class = "constant_name">s</p><p class = "constant_description">미국 레이아웃의 'S'키.</p><p class = "constant_name">t</p><p class = "constant_description">미국 레이아웃의 'T'키.</p><p class = "constant_name">u</p><p class = "constant_description">미국 레이아웃의 'U'키.</p><p class = "constant_name">v</p><p class = "constant_description">미국 레이아웃의 'V'키.</p><p class = "constant_name">w</p><p class = "constant_description">미국 레이아웃의 'W'키.</p><p class = "constant_name">x</p><p class = "constant_description">미국 레이아웃의 'X'키.</p><p class = "constant_name">y</p><p class = "constant_description">미국 레이아웃의 'Y'키입니다.</p><p class = "constant_name">z</p><p class = "constant_description">미국 레이아웃의 'Z'키.</p><p class = "constant_name">1</p><p class = "constant_description">미국 레이아웃의 '1'키입니다.</p><p class = "constant_name">2</p><p class = "constant_description">미국 레이아웃의 '2'키.</p><p class = "constant_name">3</p><p class = "constant_description">미국 레이아웃의 '3'키.</p><p class = "constant_name">4</p><p class = "constant_description">미국 레이아웃의 '4'키.</p><p class = "constant_name">5</p><p class = "constant_description">미국 레이아웃의 '5'키.</p><p class = "constant_name">6</p><p class = "constant_description">미국 레이아웃의 '6'키.</p><p class = "constant_name">7</p><p class = "constant_description">미국 레이아웃의 '7'키.</p><p class = "constant_name">8</p><p class = "constant_description">미국 레이아웃의 '8'키.</p><p class = "constant_name">9</p><p class = "constant_description">미국 레이아웃의 '9'키.</p><p class = "constant_name">0</p><p class = "constant_description">미국 레이아웃의 '0'키입니다.</p><p class = "constant_name">return</p><p class = "constant_description">미국 레이아웃의 'return'/ 'enter'키.</p><p class = "constant_name">escape</p><p class = "constant_description">미국 레이아웃의 '이스케이프'키.</p><p class = "constant_name">backspace</p><p class = "constant_description">미국 레이아웃의 '백 스페이스'키.</p><p class = "constant_name">tab</p><p class = "constant_description">미국 레이아웃의 '탭'키.</p><p class = "constant_name">space</p><p class = "constant_description">미국 레이아웃의 스페이스 바입니다.</p><p class = "constant_name">-</p><p class = "constant_description">미국 레이아웃의 빼기 키.</p><p class = "constant_name">=</p><p class = "constant_description">미국의 레이아웃에서 같음이 중요합니다.</p><p class = "constant_name">[</p><p class = "constant_description">미국식 레이아웃의 왼쪽 대괄호 키입니다.</p><p class = "constant_name">]</p><p class = "constant_description">미국 레이아웃의 오른쪽 대괄호 키입니다.</p><p class = "constant_name">\</p><p class = "constant_description">미국 레이아웃의 백 슬래시 키입니다.</p><p class = "constant_name">nonus#</p><p class = "constant_description">미국 이외의 해시 스캔 코드</p><p class = "constant_name">;</p><p class = "constant_description">미국 레이아웃의 세미콜론 키입니다.</p><p class = "constant_name">'</p><p class = "constant_description">미국 레이아웃의 아포스트로피 키입니다.</p><p class = "constant_name">`</p><p class = "constant_description">미국 레이아웃의 뒷 - 틱 / 무덤 키.</p><p class = "constant_name">,</p><p class = "constant_description">미국식 레이아웃의 쉼표 키입니다.</p><p class = "constant_name">.</p><p class = "constant_description">미국 레이아웃의 기간 키입니다.</p><p class = "constant_name">/</p><p class = "constant_description">미국 레이아웃의 슬래시 키입니다.</p><p class = "constant_name">capslock</p><p class = "constant_description">미국 레이아웃의 capslock 키입니다.</p><p class = "constant_name">f1</p><p class = "constant_description">미국 레이아웃의 F1 키입니다.</p><p class = "constant_name">f2</p><p class = "constant_description">미국 레이아웃의 F2 키입니다.</p><p class = "constant_name">f3</p><p class = "constant_description">미국 레이아웃의 F3 키입니다.</p><p class = "constant_name">f4</p><p class = "constant_description">미국 레이아웃의 F4 키입니다.</p><p class = "constant_name">f5</p><p class = "constant_description">미국 레이아웃의 F5 키입니다.</p><p class = "constant_name">f6</p><p class = "constant_description">미국 레이아웃의 F6 키입니다.</p><p class = "constant_name">f7</p><p class = "constant_description">미국 레이아웃의 F7 키입니다.</p><p class = "constant_name">f8</p><p class = "constant_description">미국 레이아웃의 F8 키입니다.</p><p class = "constant_name">f9</p><p class = "constant_description">미국 레이아웃의 F9 키입니다.</p><p class = "constant_name">f10</p><p class = "constant_description">미국 레이아웃의 F10 키입니다.</p><p class = "constant_name">f11</p><p class = "constant_description">미국 레이아웃의 F11 키입니다.</p><p class = "constant_name">f12</p><p class = "constant_description">미국 레이아웃의 F12 키입니다.</p><p class = "constant_name">f13</p><p class = "constant_description">미국 레이아웃의 F13 키입니다.</p><p class = "constant_name">f14</p><p class = "constant_description">미국 레이아웃의 F14 키입니다.</p><p class = "constant_name">f15</p><p class = "constant_description">미국 레이아웃의 F15 키입니다.</p><p class = "constant_name">f16</p><p class = "constant_description">미국 레이아웃의 F16 키입니다.</p><p class = "constant_name">f17</p><p class = "constant_description">미국 레이아웃의 F17 키입니다.</p><p class = "constant_name">f18</p><p class = "constant_description">미국 레이아웃의 F18 키입니다.</p><p class = "constant_name">f19</p><p class = "constant_description">미국 레이아웃의 F19 키입니다.</p><p class = "constant_name">f20</p><p class = "constant_description">미국 레이아웃의 F20 키입니다.</p><p class = "constant_name">f21</p><p class = "constant_description">미국 레이아웃의 F21 키입니다.</p><p class = "constant_name">f22</p><p class = "constant_description">미국 레이아웃의 F22 키입니다.</p><p class = "constant_name">f23</p><p class = "constant_description">미국 레이아웃의 F23 키입니다.</p><p class = "constant_name">f24</p><p class = "constant_description">미국 레이아웃의 F24 키입니다.</p><p class = "constant_name">lctrl</p><p class = "constant_description">미국 레이아웃의 왼쪽 컨트롤 키.</p><p class = "constant_name">lshift</p><p class = "constant_description">미국 레이아웃의 왼쪽 쉬프트 키.</p><p class = "constant_name">lalt</p><p class = "constant_description">미국 레이아웃의 왼쪽 alt / option 키.</p><p class = "constant_name">lgui</p><p class = "constant_description">미국식 레이아웃의 왼쪽 GUI (command / windows / super) 키.</p><p class = "constant_name">rctrl</p><p class = "constant_description">미국 레이아웃의 올바른 컨트롤 키입니다.</p><p class = "constant_name">rshift</p><p class = "constant_description">미국 레이아웃의 오른쪽 교대 키입니다.</p><p class = "constant_name">ralt</p><p class = "constant_description">미국 레이아웃의 오른쪽 alt / option 키.</p><p class = "constant_name">rgui</p><p class = "constant_description">미국 레이아웃의 올바른 GUI (명령 / 창 / 수퍼) 키.</p><p class = "constant_name">printscreen</p><p class = "constant_description">미국 레이아웃의 인쇄 화면 키입니다.</p><p class = "constant_name">scrolllock</p><p class = "constant_description">미국 레이아웃의 스크롤 잠금 키입니다.</p><p class = "constant_name">pause</p><p class = "constant_description">미국 레이아웃의 일시 중지 키입니다.</p><p class = "constant_name">insert</p><p class = "constant_description">미국 레이아웃의 삽입 키입니다.</p><p class = "constant_name">home</p><p class = "constant_description">미국 레이아웃의 홈 키입니다.</p><p class = "constant_name">numlock</p><p class = "constant_description">미국 레이아웃의 numlock / clear 키입니다.</p><p class = "constant_name">pageup</p><p class = "constant_description">미국 레이아웃의 페이지 업 키입니다.</p><p class = "constant_name">delete</p><p class = "constant_description">미국 레이아웃의 앞으로 삭제 키입니다.</p><p class = "constant_name">end</p><p class = "constant_description">미국 레이아웃의 끝 키.</p><p class = "constant_name">pagedown</p><p class = "constant_description">미국 레이아웃의 페이지 다운 키입니다.</p><p class = "constant_name">right</p><p class = "constant_description">미국 레이아웃의 오른쪽 화살표 키.</p><p class = "constant_name">left</p><p class = "constant_description">미국 레이아웃의 왼쪽 화살표 키입니다.</p><p class = "constant_name">down</p><p class = "constant_description">미국 레이아웃의 아래쪽 화살표 키.</p><p class = "constant_name">up</p><p class = "constant_description">미국 레이아웃의 위쪽 화살표 키입니다.</p><p class = "constant_name">nonusbackslash</p><p class = "constant_description">미국 이외의 백 슬래시 스캔 코드</p><p class = "constant_name">application</p><p class = "constant_description">미국 레이아웃의 응용 프로그램 키입니다. Windows 컨텍스트 메뉴, 키 작성.</p><p class = "constant_name">execute</p><p class = "constant_description">미국 레이아웃에서 '실행'키.</p><p class = "constant_name">help</p><p class = "constant_description">미국 레이아웃의 '도움말'키.</p><p class = "constant_name">menu</p><p class = "constant_description">미국 레이아웃의 'menu'키.</p><p class = "constant_name">select</p><p class = "constant_description">미국 레이아웃의 '선택'키.</p><p class = "constant_name">stop</p><p class = "constant_description">미국 레이아웃의 '정지'키.</p><p class = "constant_name">again</p><p class = "constant_description">미국 레이아웃의 '다시'키.</p><p class = "constant_name">undo</p><p class = "constant_description">미국 레이아웃의 '실행 취소'키입니다.</p><p class = "constant_name">cut</p><p class = "constant_description">미국 레이아웃의 'cut'키.</p><p class = "constant_name">copy</p><p class = "constant_description">미국 레이아웃의 '복사'키.</p><p class = "constant_name">paste</p><p class = "constant_description">미국 레이아웃의 'paste'키.</p><p class = "constant_name">find</p><p class = "constant_description">미국 레이아웃의 '찾기'키.</p><p class = "constant_name">kp/</p><p class = "constant_description">키패드 슬래시 키는 미국식 레이아웃입니다.</p><p class = "constant_name">kp*</p><p class = "constant_description">미국 레이아웃의 키패드 '*'키.</p><p class = "constant_name">kp-</p><p class = "constant_description">키패드에서 미국 레이아웃의 키 빼기.</p><p class = "constant_name">kp+</p><p class = "constant_description">키패드 플러스 키 미국 레이아웃입니다.</p><p class = "constant_name">kp=</p><p class = "constant_description">키패드는 미국 레이아웃의 키와 동일합니다.</p><p class = "constant_name">kpenter</p><p class = "constant_description">키패드는 미국 레이아웃에 키를 입력합니다.</p><p class = "constant_name">kp1</p><p class = "constant_description">미국 레이아웃의 키패드 '1'키.</p><p class = "constant_name">kp2</p><p class = "constant_description">미국 레이아웃의 키패드 '2'키.</p><p class = "constant_name">kp3</p><p class = "constant_description">미국 레이아웃의 키패드 '3'키.</p><p class = "constant_name">kp4</p><p class = "constant_description">미국 레이아웃의 키패드 '4'키.</p><p class = "constant_name">kp5</p><p class = "constant_description">미국 레이아웃의 키패드 '5'키.</p><p class = "constant_name">kp6</p><p class = "constant_description">미국 레이아웃의 키패드 '6'키.</p><p class = "constant_name">kp7</p><p class = "constant_description">미국 레이아웃의 키패드 '7'키.</p><p class = "constant_name">kp8</p><p class = "constant_description">미국 레이아웃의 키패드 '8'키.</p><p class = "constant_name">kp9</p><p class = "constant_description">미국 레이아웃의 키패드 '9'키.</p><p class = "constant_name">kp0</p><p class = "constant_description">미국 레이아웃의 키패드 '0'키.</p><p class = "constant_name">kp.</p><p class = "constant_description">미국 레이아웃의 키패드 기간 키입니다.</p><p class = "constant_name">international1</p><p class = "constant_description">미국 레이아웃의 첫 번째 국제 키입니다. 아시아 키보드에서 사용됩니다.</p><p class = "constant_name">international2</p><p class = "constant_description">미국 레이아웃에 두 번째 국제 키입니다.</p><p class = "constant_name">international3</p><p class = "constant_description">미국 레이아웃의 세 번째 국제 키입니다. 엔.</p><p class = "constant_name">international4</p><p class = "constant_description">미국 레이아웃의 네 번째 국제 키입니다.</p><p class = "constant_name">international5</p><p class = "constant_description">미국 레이아웃의 다섯 번째 국제 열쇠.</p><p class = "constant_name">international6</p><p class = "constant_description">미국 레이아웃의 여섯 번째 국제 열쇠.</p><p class = "constant_name">international7</p><p class = "constant_description">미국 레이아웃의 7 번째 국제 열쇠.</p><p class = "constant_name">international8</p><p class = "constant_description">미국 레이아웃의 8 번째 국제 열쇠.</p><p class = "constant_name">international9</p><p class = "constant_description">미국 레이아웃상의 9 번째 국제 열쇠.</p><p class = "constant_name">lang1</p><p class = "constant_description">한글 / 영어 토글 스캔 코드.</p><p class = "constant_name">lang2</p><p class = "constant_description">한자 변환 스캔 코드.</p><p class = "constant_name">lang3</p><p class = "constant_description">카타카나 스캔 코드.</p><p class = "constant_name">lang4</p><p class = "constant_description">히라가나 스캔 코드.</p><p class = "constant_name">lang5</p><p class = "constant_description">Zenkaku / Hankaku 스캔 코드.</p><p class = "constant_name">mute</p><p class = "constant_description">미국 레이아웃의 음소거 키입니다.</p><p class = "constant_name">volumeup</p><p class = "constant_description">미국 레이아웃의 볼륨 업 키입니다.</p><p class = "constant_name">volumedown</p><p class = "constant_description">미국식 레이아웃의 볼륨 다운 키입니다.</p><p class = "constant_name">audionext</p><p class = "constant_description">미국 레이아웃의 오디오 다음 트랙 키입니다.</p><p class = "constant_name">audioprev</p><p class = "constant_description">미국 레이아웃의 오디오 이전 트랙 키입니다.</p><p class = "constant_name">audiostop</p><p class = "constant_description">미국 레이아웃의 오디오 정지 키입니다.</p><p class = "constant_name">audioplay</p><p class = "constant_description">미국 레이아웃의 오디오 재생 키입니다.</p><p class = "constant_name">audiomute</p><p class = "constant_description">미국 레이아웃의 오디오 음소거 키입니다.</p><p class = "constant_name">mediaselect</p><p class = "constant_description">미국 레이아웃의 미디어 선택 키입니다.</p><p class = "constant_name">www</p><p class = "constant_description">미국 레이아웃의 'WWW'키.</p><p class = "constant_name">mail</p><p class = "constant_description">미국 레이아웃의 메일 키입니다.</p><p class = "constant_name">calculator</p><p class = "constant_description">미국 레이아웃의 계산기 키입니다.</p><p class = "constant_name">computer</p><p class = "constant_description">미국 레이아웃의 '컴퓨터'키.</p><p class = "constant_name">acsearch</p><p class = "constant_description">미국 레이아웃의 AC 검색 키입니다.</p><p class = "constant_name">achome</p><p class = "constant_description">미국 레이아웃의 AC 홈 키입니다.</p><p class = "constant_name">acback</p><p class = "constant_description">미국 레이아웃의 AC Back 키.</p><p class = "constant_name">acforward</p><p class = "constant_description">미국식 레이아웃의 AC 전달 키입니다.</p><p class = "constant_name">acstop</p><p class = "constant_description">Th 미국식 레이아웃의 AC Stop 키.</p><p class = "constant_name">acrefresh</p><p class = "constant_description">미국 레이아웃의 AC 새로 고침 키.</p><p class = "constant_name">acbookmarks</p><p class = "constant_description">미국 레이아웃의 AC 북마크 키입니다.</p><p class = "constant_name">power</p><p class = "constant_description">시스템 전원 스캔 코드.</p><p class = "constant_name">brightnessdown</p><p class = "constant_description">밝기 감소 스캔 코드</p><p class = "constant_name">brightnessup</p><p class = "constant_description">밝기 증가 스캔 코드</p><p class = "constant_name">displayswitch</p><p class = "constant_description">디스플레이 스위치 스캔 코드.</p><p class = "constant_name">kbdillumtoggle</p><p class = "constant_description">키보드 조명이 스캔 코드를 전환합니다.</p><p class = "constant_name">kbdillumdown</p><p class = "constant_description">키보드 조명이 스캔 코드를 내립니다.</p><p class = "constant_name">kbdillumup</p><p class = "constant_description">스캔 키보드 위로 키보드가 켜집니다.</p><p class = "constant_name">eject</p><p class = "constant_description">스캔 코드를 꺼냅니다.</p><p class = "constant_name">sleep</p><p class = "constant_description">시스템 sleep scancode.</p><p class = "constant_name">alterase</p><p class = "constant_description">아메리칸 레이아웃의 alt-erase 키.</p><p class = "constant_name">sysreq</p><p class = "constant_description">미국 레이아웃의 sysreq 키.</p><p class = "constant_name">cancel</p><p class = "constant_description">미국 레이아웃의 '취소'키.</p><p class = "constant_name">clear</p><p class = "constant_description">미국 레이아웃의 '명확한'키.</p><p class = "constant_name">prior</p><p class = "constant_description">미국 레이아웃의 '이전'키입니다.</p><p class = "constant_name">return2</p><p class = "constant_description">미국 레이아웃의 'return2'키.</p><p class = "constant_name">separator</p><p class = "constant_description">미국 레이아웃의 '구분 기호'키입니다.</p><p class = "constant_name">out</p><p class = "constant_description">미국 레이아웃의 'out'키.</p><p class = "constant_name">oper</p><p class = "constant_description">미국 레이아웃의 'oper'키.</p><p class = "constant_name">clearagain</p><p class = "constant_description">미국 레이아웃의 'clearagain'키.</p><p class = "constant_name">crsel</p><p class = "constant_description">미국 레이아웃의 'crsel'키.</p><p class = "constant_name">exsel</p><p class = "constant_description">미국 레이아웃의 'exsel'키.</p><p class = "constant_name">kp00</p><p class = "constant_description">미국 레이아웃의 키패드 00 키.</p><p class = "constant_name">kp000</p><p class = "constant_description">키패드 000 키 미국 레이아웃입니다.</p><p class = "constant_name">thsousandsseparator</p><p class = "constant_description">미국 레이아웃의 천 단위 구분 기호 키.</p><p class = "constant_name">decimalseparator</p><p class = "constant_description">미국식 레이아웃의 소수점 구분 기호 키입니다.</p><p class = "constant_name">currencyunit</p><p class = "constant_description">미국 레이아웃의 통화 단위 키입니다.</p><p class = "constant_name">currencysubunit</p><p class = "constant_description">미국식 레이아웃의 통화 하위 단위 키입니다.</p><p class = "constant_name">app1</p><p class = "constant_description">'app1'스캔 코드.</p><p class = "constant_name">app2</p><p class = "constant_description">'app2'스캔 코드.</p><p class = "constant_name">unknown</p><p class = "constant_description">알 수없는 키.</p></div><div class = "section"><p class = "section_heading"><a href = "#love.math" name = "love.math">love.math</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#BezierCurve">BezierCurve</a>&emsp;베지에 곡선입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedData">CompressedData</a>&emsp;특정 알고리즘을 사용하여 압축 된 바이트 데이터를 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RandomGenerator">RandomGenerator</a>&emsp;자기 고유의 상태를 가지는 난수 생성기입니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.noise">noise</a>&emsp;1~4차원에 대한 Simplex 노이즈를 생성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.random">random</a>&emsp;고르게 분포되어 있는 유사난수를 생성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.randomNormal">randomNormal</a>&emsp;정규 분포를 따르는 유사난수를 생성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.getRandomSeed">get</a><span class = "slash">/</span><a href="#love.math.setRandomSeed">setRandomSeed</a>&emsp;난수 생성기의 시드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.getRandomState">get</a><span class = "slash">/</span><a href="#love.math.setRandomState">setRandomState</a>&emsp;난수 생성 프로그램의 현재 상태를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.isConvex">isConvex</a>&emsp;볼록한 다각형인지 검사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.triangulate">triangulate</a>&emsp;단순한 다각형을 삼각형으로 분해합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.compress">compress</a>&emsp;특정 압축 알고리즘을 사용하여 문자열이나 데이터를 압축합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.decompress">decompress</a>&emsp;CompressedData 또는 이전에 압축 된 문자열 또는 Data 객체의 압축을 해제합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.linearToGamma">linearToGamma</a>&emsp;선형 공간 (RGB)에서 감마 공간 (sRGB)으로 색상을 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.gammaToLinear">gammaToLinear</a>&emsp;색을 감마선 (sRGB)에서 선형 공간 (RGB)으로 변환합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CompressedDataFormat">CompressedDataFormat</a>&emsp;압축 된 데이터 형식. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.math.compress" name = "love.math.compress"><span>love.math.</span><wbr>compress</a></p><p class = "function_description">특정 압축 알고리즘을 사용하여 문자열이나 데이터를 압축합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">compressedData</span> = love.math.<wbr>compress( <span class = "arguments">rawstring</span>, <span class = "arguments">format</span>, <span class = "arguments">level</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">compressedData</td><td class = "ra_type"><a href="#CompressedData">CompressedData</a></td><td>문자열의 압축 된 버전을 포함하는 새 Data 객체입니다.</td></tr><tr><td class = "arguments ra_name">rawstring</td><td class = "ra_type">string</td><td>압축 할 원시 (압축되지 않은) 문자열.</td></tr><tr><td class = "arguments ra_name">format <span class = "default">("lz4")</span></td><td class = "ra_type"><a href="#CompressedDataFormat">CompressedDataFormat</a></td><td>문자열을 압축 할 때 사용할 형식입니다.</td></tr><tr><td class = "arguments ra_name">level <span class = "default">(-1)</span></td><td class = "ra_type">number</td><td>사용할 압축 수준 (0 ~ 9)입니다. -1은 기본 수준을 나타냅니다. 이 인수의의 L는 사용되는 압축 형식에 따라 다 (니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">compressedData</span> = love.math.<wbr>compress( <span class = "arguments">data</span>, <span class = "arguments">format</span>, <span class = "arguments">level</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">compressedData</td><td class = "ra_type"><a href="#CompressedData">CompressedData</a></td><td>원시 데이터의 압축 된 버전을 포함하는 새 Data 객체입니다.</td></tr><tr><td class = "arguments ra_name">data</td><td class = "ra_type"><a href="#Data">Data</a></td><td>압축 할 원시 (압축되지 않은) 데이터가 포함 된 Data 객체입니다.</td></tr><tr><td class = "arguments ra_name">format <span class = "default">("lz4")</span></td><td class = "ra_type"><a href="#CompressedDataFormat">CompressedDataFormat</a></td><td>데이터를 압축 할 때 사용할 형식입니다.</td></tr><tr><td class = "arguments ra_name">level <span class = "default">(-1)</span></td><td class = "ra_type">number</td><td>사용할 압축 수준 (0 ~ 9)입니다. -1은 기본 수준을 나타냅니다. 이 인수의의 L는 사용되는 압축 형식에 따라 다 (니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.decompress" name = "love.math.decompress"><span>love.math.</span><wbr>decompress</a></p><p class = "function_description">CompressedData 또는 이전에 압축 된 문자열 또는 Data 객체의 압축을 해제합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rawstring</span> = love.math.<wbr>decompress( <span class = "arguments">compressedData</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rawstring</td><td class = "ra_type">string</td><td>원시 압축 해제 된 데이터가 들어있는 문자열입니다.</td></tr><tr><td class = "arguments ra_name">compressedData</td><td class = "ra_type"><a href="#CompressedData">CompressedData</a></td><td>압축 해제 할 압축 데이터.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rawstring</span> = love.math.<wbr>decompress( <span class = "arguments">compressedString</span>, <span class = "arguments">format</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rawstring</td><td class = "ra_type">string</td><td>원시 압축 해제 된 데이터가 들어있는 문자열입니다.</td></tr><tr><td class = "arguments ra_name">compressedString</td><td class = "ra_type">string</td><td>이전에 <a href="#love.math.compress">love.math.compress</a>로 압축 된 데이터가 포함 된 문자열입니다.</td></tr><tr><td class = "arguments ra_name">format</td><td class = "ra_type"><a href="#CompressedDataFormat">CompressedDataFormat</a></td><td>주어진 문자열을 압축하는 데 사용 된 형식.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rawstring</span> = love.math.<wbr>decompress( <span class = "arguments">data</span>, <span class = "arguments">format</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rawstring</td><td class = "ra_type">string</td><td>원시 압축 해제 된 데이터가 들어있는 문자열입니다.</td></tr><tr><td class = "arguments ra_name">data</td><td class = "ra_type"><a href="#Data">Data</a></td><td>이전에 <a href="#love.math.compress">love.math.compress</a>로 압축 된 데이터가 포함 된 Data 객체입니다.</td></tr><tr><td class = "arguments ra_name">format</td><td class = "ra_type"><a href="#CompressedDataFormat">CompressedDataFormat</a></td><td>주어진 데이터를 압축하는 데 사용 된 형식.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.gammaToLinear" name = "love.math.gammaToLinear"><span>love.math.</span><wbr>gammaToLinear</a></p><p class = "function_description">색을 감마선 (sRGB)에서 선형 공간 (RGB)으로 변환합니다. 이것은 감마 보정을 할 때 유용하며 L-VE가 자동으로 변환을 처리하지 않는 몇 가지 경우에 선형 RGB에서 수학을 수행해야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">lr</span>, <span class = "returns">lg</span>, <span class = "returns">lb</span> = love.math.<wbr>gammaToLinear( <span class = "arguments">r</span>, <span class = "arguments">g</span>, <span class = "arguments">b</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">lr</td><td class = "ra_type">number</td><td>선형 RGB 공간에서 변환 된 색상의 빨강 채널입니다.</td></tr><tr><td class = "returns ra_name">lg</td><td class = "ra_type">number</td><td>선형 RGB 공간에서 변환 된 색상의 녹색 채널입니다.</td></tr><tr><td class = "returns ra_name">lb</td><td class = "ra_type">number</td><td>선형 RGB 공간에서 변환 된 색상의 파란색 채널입니다.</td></tr><tr><td class = "arguments ra_name">r</td><td class = "ra_type">number</td><td>변환 할 sRGB 색상의 빨간색 채널입니다.</td></tr><tr><td class = "arguments ra_name">g</td><td class = "ra_type">number</td><td>변환 할 sRGB 색상의 녹색 채널입니다.</td></tr><tr><td class = "arguments ra_name">b</td><td class = "ra_type">number</td><td>변환 할 sRGB 색상의 파란색 채널입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">lr</span>, <span class = "returns">lg</span>, <span class = "returns">lb</span> = love.math.<wbr>gammaToLinear( <span class = "arguments">color</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">lr</td><td class = "ra_type">number</td><td>선형 RGB 공간에서 변환 된 색상의 빨강 채널입니다.</td></tr><tr><td class = "returns ra_name">lg</td><td class = "ra_type">number</td><td>선형 RGB 공간에서 변환 된 색상의 녹색 채널입니다.</td></tr><tr><td class = "returns ra_name">lb</td><td class = "ra_type">number</td><td>선형 RGB 공간에서 변환 된 색상의 파란색 채널입니다.</td></tr><tr><td class = "arguments ra_name">color</td><td class = "ra_type">table</td><td>변환 할 sRGB 색상의 빨강, 녹색 및 파랑 채널이있는 배열입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">lc</span> = love.math.<wbr>gammaToLinear( <span class = "arguments">c</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">lc</td><td class = "ra_type">number</td><td>선형 RGB 공간에서의 색상 채널 값입니다.</td></tr><tr><td class = "arguments ra_name">c</td><td class = "ra_type">number</td><td>변환 할 sRGB 공간의 색상 채널 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.getRandomSeed" name = "love.math.getRandomSeed"><span>love.math.</span><wbr>getRandomSeed</a></p><p class = "function_description">난수 생성기의 시드를 얻어옵니다.<br /><br />루아에선 모든 수를 배정밀도 부동소수점(double)으로 처리합니다. 때문에 2^53 이상의 정수의 경우 그 값을 정확하게 표시하지 못합니다. 시드는 2^64 정수로 이루어져 있으므로 L&Ouml;VE는 이를 온전히 전달하기 위해 비트를 둘로 쪼개서 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">low</span>, <span class = "returns">high</span> = love.math.<wbr>getRandomSeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">low</td><td class = "ra_type">number</td><td>64비트 시드값의 하위 32비트를 표현하는 정수.</td></tr><tr><td class = "returns ra_name">high</td><td class = "ra_type">number</td><td>64비트 시드값의 상위 32비트를 표현하는 정수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.getRandomState" name = "love.math.getRandomState"><span>love.math.</span><wbr>getRandomState</a></p><p class = "function_description">난수 생성 프로그램의 현재 상태를 가져옵니다. 나중에 RandomGenerator : setState와 함께 사용하는 경우에만 유용하게 사용되는 불투명 한 구현 종속적 문자열을 반환합니다.<br /><br />이것은 RandomGenerator와 다릅니다. getSeed는 RandomGenerator의 현재 상태를 가져 오는 반면 getSeed는 이전에 설정된 시드 값을 가져옵니다.<br /><br />상태 문자열의 값은 현재 운영 체제에 의존하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">state</span> = love.math.<wbr>getRandomState()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">state</td><td class = "ra_type">string</td><td>문자열로 표현 된 RandomGenerator 객체의 현재 상태입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.isConvex" name = "love.math.isConvex"><span>love.math.</span><wbr>isConvex</a></p><p class = "function_description">볼록한 다각형인지 검사합니다.<br /><br />PolygonShape, 특정 형태의 Mesh, <a href="#love.graphics.polygon">love.graphics.polygon</a>으로 그려지는 다각형은 반드시 볼록한 다각형이어야 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">convex</span> = love.math.<wbr>isConvex( <span class = "arguments">vertices</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">convex</td><td class = "ra_type">boolean</td><td>볼록한 다각형이면 true를 리턴.</td></tr><tr><td class = "arguments ra_name">vertices</td><td class = "ra_type">table</td><td>{x1, y1, x2, y2, x3, y3, ...}의 형태로 나타내는 꼭짓점 테이블.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">convex</span> = love.math.<wbr>isConvex( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">x3</span>, <span class = "arguments">y3</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">convex</td><td class = "ra_type">boolean</td><td>주어진 다각형이 볼록인지 여부.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>x 축에있는 다각형의 첫 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>다각형의 첫 번째 꼭지점 위치를 Y 축에 지정합니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>x 축에있는 다각형의 두 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>다각형의 두 번째 꼭지점 위치를 Y 축에 지정합니다.</td></tr><tr><td class = "arguments ra_name">x3</td><td class = "ra_type">number</td><td>x 축에있는 다각형의 세 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y3</td><td class = "ra_type">number</td><td>다각형의 세 번째 꼭지점 위치를 Y 축에 지정합니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 정점.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.linearToGamma" name = "love.math.linearToGamma"><span>love.math.</span><wbr>linearToGamma</a></p><p class = "function_description">선형 공간 (RGB)에서 감마 공간 (sRGB)으로 색상을 변환합니다. 이는 선형 RGB 색상 공간이 어두운 색상에 대해 sRGB보다 정밀도가 낮기 때문에 이미지에 선형 RGB 색상 값을 저장할 때 유용합니다. 그리기시 눈에 띄는 색상 띠가 발생할 수 있습니다.<br /><br />일반적으로 화면에 표시되는 모양을 기반으로 선택한 색상은 이미 감마 공간에 있으므로 이중 변환하면 안됩니다. 수학을 사용하여 계산 된 색상은 종종 선형 RGB 공간에 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cr</span>, <span class = "returns">cg</span>, <span class = "returns">cb</span> = love.math.<wbr>linearToGamma( <span class = "arguments">lr</span>, <span class = "arguments">lg</span>, <span class = "arguments">lb</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cr</td><td class = "ra_type">number</td><td>감마 sRGB 영역의 변환 된 색상의 빨강 채널입니다.</td></tr><tr><td class = "returns ra_name">cg</td><td class = "ra_type">number</td><td>감마 sRGB 영역의 변환 된 색상의 녹색 채널입니다.</td></tr><tr><td class = "returns ra_name">cb</td><td class = "ra_type">number</td><td>감마 sRGB 공간의 변환 된 색상의 파란색 채널입니다.</td></tr><tr><td class = "arguments ra_name">lr</td><td class = "ra_type">number</td><td>변환 할 선형 RGB 색상의 빨강 채널입니다.</td></tr><tr><td class = "arguments ra_name">lg</td><td class = "ra_type">number</td><td>변환 할 선형 RGB 색상의 녹색 채널입니다.</td></tr><tr><td class = "arguments ra_name">lb</td><td class = "ra_type">number</td><td>변환 할 선형 RGB 색상의 파란색 채널입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cr</span>, <span class = "returns">cg</span>, <span class = "returns">cb</span> = love.math.<wbr>linearToGamma( <span class = "arguments">color</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cr</td><td class = "ra_type">number</td><td>감마 sRGB 영역의 변환 된 색상의 빨강 채널입니다.</td></tr><tr><td class = "returns ra_name">cg</td><td class = "ra_type">number</td><td>감마 sRGB 영역의 변환 된 색상의 녹색 채널입니다.</td></tr><tr><td class = "returns ra_name">cb</td><td class = "ra_type">number</td><td>감마 sRGB 공간의 변환 된 색상의 파란색 채널입니다.</td></tr><tr><td class = "arguments ra_name">color</td><td class = "ra_type">table</td><td>변환 할 선형 RGB 색상의 빨강, 녹색 및 파랑 채널이있는 배열입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">c</span> = love.math.<wbr>linearToGamma( <span class = "arguments">lc</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">c</td><td class = "ra_type">number</td><td>감마 sRGB 영역의 컬러 채널 값입니다.</td></tr><tr><td class = "arguments ra_name">lc</td><td class = "ra_type">number</td><td>변환 할 선형 RGB 공간의 색상 채널 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.newBezierCurve" name = "love.math.newBezierCurve"><span>love.math.</span><wbr>newBezierCurve</a></p><p class = "function_description">새로운 베지에 곡선을 생성합니다.<br /><br />인자로 넘어온 조절점의 개수가 곡선의 차수를 결정합니다. 예를 들어 세 점은 이차 베지에 곡선을, 네 점은 삼차 베지에 곡선을 만들게 됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">curve</span> = love.math.<wbr>newBezierCurve( <span class = "arguments">vertices</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">curve</td><td class = "ra_type"><a href="#BezierCurve">BezierCurve</a></td><td>새 베지에 곡선 객체.</td></tr><tr><td class = "arguments ra_name">vertices</td><td class = "ra_type">table</td><td>{x1, y1, x2, y2, x3, y3, ...}과 같은 형태로 이루어진 조절점 테이블.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">curve</span> = love.math.<wbr>newBezierCurve( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">x3</span>, <span class = "arguments">y3</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">curve</td><td class = "ra_type"><a href="#BezierCurve">BezierCurve</a></td><td>B&eacute;zier 커브 오브젝트.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>x 축에서 제어 다각형의 첫 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>y 축상의 제어 다각형의 첫 번째 정점 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>x 축에서 제어 다각형의 두 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>y 축에서 제어 다각형의 두 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">x3</td><td class = "ra_type">number</td><td>x 축에서 제어 다각형의 세 번째 꼭지점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y3</td><td class = "ra_type">number</td><td>y 축상의 제어 다각형의 세 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 정점.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.newRandomGenerator" name = "love.math.newRandomGenerator"><span>love.math.</span><wbr>newRandomGenerator</a></p><p class = "function_description">새로운 난수 생성기를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rng</span> = love.math.<wbr>newRandomGenerator()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rng</td><td class = "ra_type"><a href="#RandomGenerator">RandomGenerator</a></td><td>난수 생성기.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rng</span> = love.math.<wbr>newRandomGenerator( <span class = "arguments">seed</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rng</td><td class = "ra_type"><a href="#RandomGenerator">RandomGenerator</a></td><td>새로운 난수 생성기 객체입니다.</td></tr><tr><td class = "arguments ra_name">seed</td><td class = "ra_type">number</td><td>이 객체에 사용할 초기 시드 번호입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rng</span> = love.math.<wbr>newRandomGenerator( <span class = "arguments">low</span>, <span class = "arguments">high</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rng</td><td class = "ra_type"><a href="#RandomGenerator">RandomGenerator</a></td><td>난수 생성기.</td></tr><tr><td class = "arguments ra_name">low</td><td class = "ra_type">number</td><td>이 객체에 사용할 64비트 시드값의 하위 32비트를 표현하는 정수.</td></tr><tr><td class = "arguments ra_name">high</td><td class = "ra_type">number</td><td>이 객체에 사용할 64비트 시드값의 상위 32비트를 표현하는 정수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.noise" name = "love.math.noise"><span>love.math.</span><wbr>noise</a></p><p class = "function_description">1~4차원에 대한 Simplex 노이즈를 생성합니다.<br /><br />Simplex 노이즈(영어)는Perlin 노이즈(영어)의 업그레이드 버전입니다. PCG(영어)에 폭넓게 사용됩니다.<br /><br />Stefan Gustavson의 Simplex noise demystified(영어)에서 Simplex 노이즈에 관한 자세한 설명을 얻으실 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = love.math.<wbr>noise( <span class = "arguments">x</span> )</span></span></p><p class = "variant_description">1차원 Simplex 노이즈를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">number</td><td>0과 1 사이의 노이즈 값.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 값.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = love.math.<wbr>noise( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><p class = "variant_description">2차원 Simplex 노이즈를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">number</td><td>0과 1 사이의 노이즈 값.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 2차원 벡터의 첫 번째 값.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 2차원 벡터의 두 번째 값.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = love.math.<wbr>noise( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">z</span> )</span></span></p><p class = "variant_description">3차원 Simplex 노이즈를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">number</td><td>0과 1 사이의 노이즈 값.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 3차원 벡터의 첫 번째 값.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 3차원 벡터의 두 번째 값.</td></tr><tr><td class = "arguments ra_name">z</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 3차원 벡터의 세 번째 값.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = love.math.<wbr>noise( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">z</span>, <span class = "arguments">w</span> )</span></span></p><p class = "variant_description">4차원 Simplex 노이즈를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">number</td><td>0과 1 사이의 노이즈 값.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 4차원 벡터의 첫 번째 값.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 4차원 벡터의 두 번째 값.</td></tr><tr><td class = "arguments ra_name">z</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 4차원 벡터의 세 번째 값.</td></tr><tr><td class = "arguments ra_name">w</td><td class = "ra_type">number</td><td>노이즈를 만드는 데 사용되는 4차원 벡터의 네 번째 값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.random" name = "love.math.random"><span>love.math.</span><wbr>random</a></p><p class = "function_description">고르게 분포되어 있는 유사난수를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = love.math.<wbr>random()</span></span></p><p class = "variant_description">1에 고르게 분포되어 있는 난수를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>난수.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = love.math.<wbr>random( <span class = "arguments">max</span> )</span></span></p><p class = "variant_description">max에 고르게 분포되어 있는 난수를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>난수.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>난수의 최댓값.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = love.math.<wbr>random( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><p class = "variant_description">max에 고르게 분포되어 있는 난수를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>난수.</td></tr><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>난수의 최솟값.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>난수의 최댓값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.randomNormal" name = "love.math.randomNormal"><span>love.math.</span><wbr>randomNormal</a></p><p class = "function_description">정규 분포를 따르는 유사난수를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = love.math.<wbr>randomNormal( <span class = "arguments">stddev</span>, <span class = "arguments">mean</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>난수.</td></tr><tr><td class = "arguments ra_name">stddev <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>표준편차.</td></tr><tr><td class = "arguments ra_name">mean <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>평균.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.setRandomSeed" name = "love.math.setRandomSeed"><span>love.math.</span><wbr>setRandomSeed</a></p><p class = "function_description">난수 생성기의 시드를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.math.<wbr>setRandomSeed( <span class = "arguments">seed</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">seed</td><td class = "ra_type">number</td><td>임의 화를 시드 할 정수입니다. {1, 2 ^ 53}의 범위 내에 있어야합니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.math.<wbr>setRandomSeed( <span class = "arguments">low</span>, <span class = "arguments">high</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">low</td><td class = "ra_type">number</td><td>64비트 시드값의 하위 32비트를 표현하는 정수.</td></tr><tr><td class = "arguments ra_name">high</td><td class = "ra_type">number</td><td>64비트 시드값의 상위 32비트를 표현하는 정수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.setRandomState" name = "love.math.setRandomState"><span>love.math.</span><wbr>setRandomState</a></p><p class = "function_description">난수 생성 프로그램의 현재 상태를 가져옵니다. 나중에 RandomGenerator : setState와 함께 사용하는 경우에만 유용하게 사용되는 불투명 한 구현 종속적 문자열을 반환합니다.<br /><br />이것은 RandomGenerator와 다릅니다. getSeed는 RandomGenerator의 현재 상태를 가져 오는 반면 getSeed는 이전에 설정된 시드 값을 가져옵니다.<br /><br />상태 문자열의 값은 현재 운영 체제에 의존하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.math.<wbr>setRandomState( <span class = "arguments">state</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">state</td><td class = "ra_type">string</td><td>문자열로 표현 된 RandomGenerator 객체의 현재 상태입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.math.triangulate" name = "love.math.triangulate"><span>love.math.</span><wbr>triangulate</a></p><p class = "function_description">단순한 다각형을 삼각형으로 분해합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">triangles</span> = love.math.<wbr>triangulate( <span class = "arguments">polygon</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">triangles</td><td class = "ra_type">table</td><td>&lt;nowiki&gt;{{x1, y1, x2, y2, x3, y3},  {x1, y1, x2, y2, x3, y3}, ...}&lt;/nowiki&gt;의 형태로 나타내는 삼각형 리스트.</td></tr><tr><td class = "arguments ra_name">polygon</td><td class = "ra_type">table</td><td>삼각형으로 분해할 다각형. 선분이 서로 겹처있으면 분해 불가.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">triangles</span> = love.math.<wbr>triangulate( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">x3</span>, <span class = "arguments">y3</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">triangles</td><td class = "ra_type">table</td><td>다각형이 {{x1, y1, x2, y2, x3, y3}, {x1, y1, x2, y2, x3, y3}, ...} 형태로 구성된 삼각형 목록.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>x 축에있는 다각형의 첫 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>다각형의 첫 번째 꼭지점 위치를 Y 축에 지정합니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>x 축에있는 다각형의 두 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>다각형의 두 번째 꼭지점 위치를 Y 축에 지정합니다.</td></tr><tr><td class = "arguments ra_name">x3</td><td class = "ra_type">number</td><td>x 축에있는 다각형의 세 번째 꼭지점 위치입니다.</td></tr><tr><td class = "arguments ra_name">y3</td><td class = "ra_type">number</td><td>다각형의 세 번째 꼭지점 위치를 Y 축에 지정합니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 정점.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#CompressedDataFormat" name = "CompressedDataFormat">CompressedDataFormat</a></p><p class = "constant_name">lz4</p><p class = "constant_description">LZ4 압축 형식입니다. 압축과 압축 해제는 매우 빠르지 만 압축률이 좋지 않습니다. 압축 레벨 9가 지정되면 LZ4-HC가 사용됩니다.</p><p class = "constant_name">zlib</p><p class = "constant_description">zlib 형식은 작은 비트의 헤더 데이터로 DEFLATE 압축 된 데이터입니다. 상대적으로 느리게 압축되고 중간 정도의 속도로 압축이 풀리고 적절한 압축률을 갖습니다.</p><p class = "constant_name">gzip</p><p class = "constant_description">gzip 형식은 zlib보다 약간 큰 헤더가있는 DEFLATE 압축 데이터입니다. DEFLATE를 사용하기 때문에 zlib 형식과 동일한 압축 특성을 갖습니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#BezierCurve" name = "BezierCurve">BezierCurve</a></p><p class = "section_description">베지에 곡선입니다.<br /><br />이 곡선에 대한 자세한 정보는 위키백과의 베지에 곡선 항목을 참조하세요.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.newBezierCurve">newBezierCurve</a>&emsp;새로운 베지에 곡선을 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:render">render</a>&emsp;곡선을 짧은 선분들로 분해합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:renderSegment">renderSegment</a>&emsp;love.graphics.line과 함께 사용할 곡선의 특정 부분에 대한 좌표 목록을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:getSegment">getSegment</a>&emsp;이 BezierCurve의 지정된 세그먼트에 해당하는 BezierCurve를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:getDerivative">getDerivative</a>&emsp;베지에 곡선의 도함수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:getDegree">getDegree</a>&emsp;베지에 곡선의 차수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:insertControlPoint">insertControlPoint</a>&emsp;i번째 위치 다음에 조절점을 삽입합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:removeControlPoint">removeControlPoint</a>&emsp;지정된 제어점을 제거합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:getControlPoint">get</a><span class = "slash">/</span><a href="#BezierCurve:setControlPoint">setControlPoint</a>&emsp;i번째 조절점을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:getControlPointCount">getControlPointCount</a>&emsp;조절점의 개수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:translate">translate</a>&emsp;곡선을 상대적인 위치로 이동시킵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:scale">scale</a>&emsp;곡선을 확대합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:rotate">rotate</a>&emsp;곡선을 회전합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">BezierCurve:<a href="#BezierCurve:evaluate">evaluate</a>&emsp;매개 변수 t에서 Bzier 곡선을 계산하십시오. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:evaluate" name = "BezierCurve:evaluate"><span>BezierCurve:</span><wbr>evaluate</a></p><p class = "function_description">매개 변수 t에서 Bzier 곡선을 계산하십시오. 매개 변수는 0과 1 사이에 있어야합니다 (포함).<br /><br />이 함수는 경로 또는 트윈 매개 변수를 따라 객체를 이동하는 데 사용할 수 있습니다. 그러나 곡선을 렌더링하는 데 사용하면 안됩니다. BezierCurve : render를 참조하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = BezierCurve:<wbr>evaluate( <span class = "arguments">t</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>매개 변수 t에서 곡선의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>매개 변수 t에서 곡선의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">t</td><td class = "ra_type">number</td><td>곡선을 어디에서 평가할 것인가?</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:getControlPoint" name = "BezierCurve:getControlPoint"><span>BezierCurve:</span><wbr>getControlPoint</a></p><p class = "function_description">i번째 조절점을 얻어옵니다. 인덱스는 1부터 시작합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = BezierCurve:<wbr>getControlPoint( <span class = "arguments">i</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>조절점의 x좌표.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>조절점의 y좌표.</td></tr><tr><td class = "arguments ra_name">i</td><td class = "ra_type">number</td><td>얻어올 조절점의 인덱스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:getControlPointCount" name = "BezierCurve:getControlPointCount"><span>BezierCurve:</span><wbr>getControlPointCount</a></p><p class = "function_description">조절점의 개수를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">count</span> = BezierCurve:<wbr>getControlPointCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">count</td><td class = "ra_type">number</td><td>조절점의 개수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:getDegree" name = "BezierCurve:getDegree"><span>BezierCurve:</span><wbr>getDegree</a></p><p class = "function_description">베지에 곡선의 차수를 구합니다. 차수는 조절점 개수 - 1 입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">degree</span> = BezierCurve:<wbr>getDegree()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">degree</td><td class = "ra_type">number</td><td>베지에 곡선의 차수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:getDerivative" name = "BezierCurve:getDerivative"><span>BezierCurve:</span><wbr>getDerivative</a></p><p class = "function_description">베지에 곡선의 도함수를 구합니다.<br /><br />이 함수는 곡선을 따라 움직이고 있는 스프라이트의 이동 방향을 회전 시킬 때, 곡선 내의 특정한 지점에서 직각 방향을 구할 때와 같은 특수한 경우에 아주 유용하게 사용할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">derivative</span> = BezierCurve:<wbr>getDerivative()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">derivative</td><td class = "ra_type"><a href="#BezierCurve">BezierCurve</a></td><td>미분당한 베지에 곡선.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:getSegment" name = "BezierCurve:getSegment"><span>BezierCurve:</span><wbr>getSegment</a></p><p class = "function_description">이 BezierCurve의 지정된 세그먼트에 해당하는 BezierCurve를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">curve</span> = BezierCurve:<wbr>getSegment( <span class = "arguments">startpoint</span>, <span class = "arguments">endpoint</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">curve</td><td class = "ra_type"><a href="#BezierCurve">BezierCurve</a></td><td>지정된 세그먼트에 해당하는 베 지어 곡선.</td></tr><tr><td class = "arguments ra_name">startpoint</td><td class = "ra_type">number</td><td>커브를 따라 시작하는 점입니다. 0에서 1 사이 여야합니다.</td></tr><tr><td class = "arguments ra_name">endpoint</td><td class = "ra_type">number</td><td>세그먼트의 끝. 0에서 1 사이 여야합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:insertControlPoint" name = "BezierCurve:insertControlPoint"><span>BezierCurve:</span><wbr>insertControlPoint</a></p><p class = "function_description">i번째 위치 다음에 조절점을 삽입합니다. 인덱스는 1부터 시작합니다. 음수 인덱스의 경우 -1은 마지막 위치를, -2는 마지막 점의 바로 앞 점을 가리킵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">BezierCurve:<wbr>insertControlPoint( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">i</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>조절점의 x좌표.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>조절점의 y좌표.</td></tr><tr><td class = "arguments ra_name">i <span class = "default">(-1)</span></td><td class = "ra_type">number</td><td>삽입할 조절점의 인덱스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:removeControlPoint" name = "BezierCurve:removeControlPoint"><span>BezierCurve:</span><wbr>removeControlPoint</a></p><p class = "function_description">지정된 제어점을 제거합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">BezierCurve:<wbr>removeControlPoint( <span class = "arguments">index</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>제거 할 컨트롤 포인트의 인덱스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:render" name = "BezierCurve:render"><span>BezierCurve:</span><wbr>render</a></p><p class = "function_description">곡선을 짧은 선분들로 분해합니다. <a href="#love.graphics.line">love.graphics.line</a>을 이용해 분해한 선분들을 화면에 출력할 수 있습니다.<br /><br />이 함수는 곡선을 짧은 선분들로 분해해 각 점의 좌표를 리턴합니다. 만약 특정한 하나의 위치를 구하길 원한다면 BezierCurve:evaluate을 참조하시길 바랍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">coordinates</span> = BezierCurve:<wbr>render( <span class = "arguments">depth</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">coordinates</td><td class = "ra_type">table</td><td>각 점의 좌표 리스트.</td></tr><tr><td class = "arguments ra_name">depth <span class = "default">(5)</span></td><td class = "ra_type">number</td><td>분해한 후 리턴될 점들의 개수. 값이 클수록 더 정밀함.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:renderSegment" name = "BezierCurve:renderSegment"><span>BezierCurve:</span><wbr>renderSegment</a></p><p class = "function_description"><a href="#love.graphics.line">love.graphics.line</a>과 함께 사용할 곡선의 특정 부분에 대한 좌표 목록을 가져옵니다.<br /><br />이 함수는 재귀 적 세분을 사용하여 Bzier 곡선을 샘플링합니다. 깊이 매개 변수를 사용하여 재귀 깊이를 제어 할 수 있습니다.<br /><br />매개 변수가있는 곡선의 위치를 ​​알아야하는 경우 BezierCurve : evaluate을 사용하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">coordinates</span> = BezierCurve:<wbr>renderSegment( <span class = "arguments">startpoint</span>, <span class = "arguments">endpoint</span>, <span class = "arguments">depth</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">coordinates</td><td class = "ra_type">table</td><td>커브상의 x, y 좌표 쌍 포인트 목록입니다.</td></tr><tr><td class = "arguments ra_name">startpoint</td><td class = "ra_type">number</td><td>커브를 따라 시작하는 점입니다. 0에서 1 사이 여야합니다.</td></tr><tr><td class = "arguments ra_name">endpoint</td><td class = "ra_type">number</td><td>렌더링 할 세그먼트의 끝입니다. 0에서 1 사이 여야합니다.</td></tr><tr><td class = "arguments ra_name">depth <span class = "default">(5)</span></td><td class = "ra_type">number</td><td>재귀 적 하위 단계의 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:rotate" name = "BezierCurve:rotate"><span>BezierCurve:</span><wbr>rotate</a></p><p class = "function_description">곡선을 회전합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">BezierCurve:<wbr>rotate( <span class = "arguments">angle</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">angle</td><td class = "ra_type">number</td><td>회전할 라디안.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>회전의 중심이 될 x좌표.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>회전의 중심이 될 y좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:scale" name = "BezierCurve:scale"><span>BezierCurve:</span><wbr>scale</a></p><p class = "function_description">곡선을 확대합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">BezierCurve:<wbr>scale( <span class = "arguments">s</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">s</td><td class = "ra_type">number</td><td>확대 배율.</td></tr><tr><td class = "arguments ra_name">ox <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>확대의 중심이 될 x좌표.</td></tr><tr><td class = "arguments ra_name">oy <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>확대의 중심이 될 y좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:setControlPoint" name = "BezierCurve:setControlPoint"><span>BezierCurve:</span><wbr>setControlPoint</a></p><p class = "function_description">i번째 조절점을 설정합니다. 인덱스는 1부터 시작합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">BezierCurve:<wbr>setControlPoint( <span class = "arguments">i</span>, <span class = "arguments">ox</span>, <span class = "arguments">oy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">i</td><td class = "ra_type">number</td><td>설정할 조절점의 인덱스.</td></tr><tr><td class = "arguments ra_name">ox</td><td class = "ra_type">number</td><td>조절점의 x좌표.</td></tr><tr><td class = "arguments ra_name">oy</td><td class = "ra_type">number</td><td>조절점의 y좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#BezierCurve:translate" name = "BezierCurve:translate"><span>BezierCurve:</span><wbr>translate</a></p><p class = "function_description">곡선을 상대적인 위치로 이동시킵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">BezierCurve:<wbr>translate( <span class = "arguments">dx</span>, <span class = "arguments">dy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">dx</td><td class = "ra_type">number</td><td>이동시킬 x축 거리.</td></tr><tr><td class = "arguments ra_name">dy</td><td class = "ra_type">number</td><td>이동시킬 y축 거리.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#CompressedData" name = "CompressedData">CompressedData</a></p><p class = "section_description">특정 알고리즘을 사용하여 압축 된 바이트 데이터를 나타냅니다.<br /><br /><a href="#love.math.decompress">love.math.decompress</a>는 데이터를 압축 해제하는 데 사용할 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.compress">compress</a>&emsp;특정 압축 알고리즘을 사용하여 문자열이나 데이터를 압축합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">CompressedData:<a href="#CompressedData:getFormat">getFormat</a>&emsp;CompressedData의 압축 형식을 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Data">Data</a>&emsp;모든 데이터 타입의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#CompressedData:getFormat" name = "CompressedData:getFormat"><span>CompressedData:</span><wbr>getFormat</a></p><p class = "function_description">CompressedData의 압축 형식을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">format</span> = CompressedData:<wbr>getFormat()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">format</td><td class = "ra_type"><a href="#CompressedDataFormat">CompressedDataFormat</a></td><td>CompressedData의 형식.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#RandomGenerator" name = "RandomGenerator">RandomGenerator</a></p><p class = "section_description">자기 고유의 상태를 가지는 난수 생성기입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.math.<a href="#love.math.newRandomGenerator">newRandomGenerator</a>&emsp;새로운 난수 생성기를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">RandomGenerator:<a href="#RandomGenerator:random">random</a>&emsp;고르게 분포되어 있는 유사난수를 생성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RandomGenerator:<a href="#RandomGenerator:randomNormal">randomNormal</a>&emsp;정규 분포를 따르는 유사난수를 생성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RandomGenerator:<a href="#RandomGenerator:getSeed">get</a><span class = "slash">/</span><a href="#RandomGenerator:setSeed">setSeed</a>&emsp;난수 생성기의 시드를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RandomGenerator:<a href="#RandomGenerator:getState">get</a><span class = "slash">/</span><a href="#RandomGenerator:setState">setState</a>&emsp;난수 생성기의 현재 상태를 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#RandomGenerator:getSeed" name = "RandomGenerator:getSeed"><span>RandomGenerator:</span><wbr>getSeed</a></p><p class = "function_description">난수 생성기의 시드를 얻어옵니다.<br /><br />루아에선 모든 수를 배정밀도 부동소수점(double)으로 처리합니다. 때문에 2^53 이상의 정수의 경우 그 값을 정확하게 표시하지 못합니다. 시드는 2^64 정수로 이루어져 있으므로 L&Ouml;VE는 이를 온전히 전달하기 위해 비트를 둘로 쪼개서 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">low</span>, <span class = "returns">high</span> = RandomGenerator:<wbr>getSeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">low</td><td class = "ra_type">number</td><td>64비트 시드값의 하위 32비트를 표현하는 정수.</td></tr><tr><td class = "returns ra_name">high</td><td class = "ra_type">number</td><td>64비트 시드값의 상위 32비트를 표현하는 정수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RandomGenerator:getState" name = "RandomGenerator:getState"><span>RandomGenerator:</span><wbr>getState</a></p><p class = "function_description">난수 생성 프로그램의 현재 상태를 가져옵니다. 나중에 RandomGenerator : setState와 함께 사용하는 경우에만 유용하게 사용되는 불투명 한 구현 종속적 문자열을 반환합니다.<br /><br />이것은 RandomGenerator와 다릅니다. getSeed는 RandomGenerator의 현재 상태를 가져 오는 반면 getSeed는 이전에 설정된 시드 값을 가져옵니다.<br /><br />상태 문자열의 값은 현재 운영 체제에 의존하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">state</span> = RandomGenerator:<wbr>getState()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">state</td><td class = "ra_type">string</td><td>문자열로 표현 된 RandomGenerator 객체의 현재 상태입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RandomGenerator:random" name = "RandomGenerator:random"><span>RandomGenerator:</span><wbr>random</a></p><p class = "function_description">고르게 분포되어 있는 유사난수를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = RandomGenerator:<wbr>random()</span></span></p><p class = "variant_description">1에 고르게 분포되어 있는 난수를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>난수.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = RandomGenerator:<wbr>random( <span class = "arguments">max</span> )</span></span></p><p class = "variant_description">max에 고르게 분포되어 있는 난수를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>난수.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>난수의 최댓값.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = RandomGenerator:<wbr>random( <span class = "arguments">min</span>, <span class = "arguments">max</span> )</span></span></p><p class = "variant_description">max에 고르게 분포되어 있는 난수를 생성합니다.</p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>난수.</td></tr><tr><td class = "arguments ra_name">min</td><td class = "ra_type">number</td><td>난수의 최솟값.</td></tr><tr><td class = "arguments ra_name">max</td><td class = "ra_type">number</td><td>난수의 최댓값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RandomGenerator:randomNormal" name = "RandomGenerator:randomNormal"><span>RandomGenerator:</span><wbr>randomNormal</a></p><p class = "function_description">정규 분포를 따르는 유사난수를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">number</span> = RandomGenerator:<wbr>randomNormal( <span class = "arguments">stddev</span>, <span class = "arguments">mean</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">number</td><td class = "ra_type">number</td><td>일반적으로 분산 된 난수 (stddev) Â와 지정된 평균.</td></tr><tr><td class = "arguments ra_name">stddev <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>분포의 표준 편차.</td></tr><tr><td class = "arguments ra_name">mean <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>분포의 평균.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RandomGenerator:setSeed" name = "RandomGenerator:setSeed"><span>RandomGenerator:</span><wbr>setSeed</a></p><p class = "function_description">난수 생성기의 시드를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RandomGenerator:<wbr>setSeed( <span class = "arguments">seed</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">seed</td><td class = "ra_type">number</td><td>임의 화를 시드 할 정수입니다. {1, 2 ^ 53}의 범위 내에 있어야합니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RandomGenerator:<wbr>setSeed( <span class = "arguments">low</span>, <span class = "arguments">high</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">low</td><td class = "ra_type">number</td><td>64비트 시드값의 하위 32비트를 표현하는 정수.</td></tr><tr><td class = "arguments ra_name">high <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>64비트 시드값의 상위 32비트를 표현하는 정수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RandomGenerator:setState" name = "RandomGenerator:setState"><span>RandomGenerator:</span><wbr>setState</a></p><p class = "function_description">난수 생성기의 현재 상태를 설정합니다. 이 함수의 인수로 사용되는 값은 불투명 한 구현 종속적 문자열이며 RandomGenerator : getState에 대한 이전 호출에서만 발생해야합니다.<br /><br />이것은 RandomGenerator : setSeed와 달리 setState가 RandomGenerator의 현재 구현 종속 상태를 직접 설정하는 반면 setSeed는 새로운 시드 값을 제공합니다.<br /><br />상태 문자열의 효과는 현재 운영 체제에 의존하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RandomGenerator:<wbr>setState( <span class = "arguments">state</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">state</td><td class = "ra_type">string</td><td>캐릭터 라인으로서 나타내지는 RandomGenerator 오브젝트의 새로운 상태입니다. 이것은 RandomGenerator : getState에 대한 이전 호출에서 기인해야합니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.mouse" name = "love.mouse">love.mouse</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Cursor">Cursor</a>&emsp;커서 모양을 표현합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.isDown">isDown</a>&emsp;마우스 버튼이 눌렸는지 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.getPosition">get</a><span class = "slash">/</span><a href="#love.mouse.setPosition">setPosition</a>&emsp;마우스의 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.getX">get</a><span class = "slash">/</span><a href="#love.mouse.setX">setX</a>&emsp;마우스의 x좌표를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.getY">get</a><span class = "slash">/</span><a href="#love.mouse.setY">setY</a>&emsp;마우스의 y좌표를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.isGrabbed">is</a><span class = "slash">/</span><a href="#love.mouse.setGrabbed">setGrabbed</a>&emsp;마우스를 윈도우 내에 가둡니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.getRelativeMode">get</a><span class = "slash">/</span><a href="#love.mouse.setRelativeMode">setRelativeMode</a>&emsp;마우스의 상대 모드를 사용할지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.getCursor">get</a><span class = "slash">/</span><a href="#love.mouse.setCursor">setCursor</a>&emsp;마우스 커서를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.isVisible">is</a><span class = "slash">/</span><a href="#love.mouse.setVisible">setVisible</a>&emsp;마우스 커서의 가시성을 설정합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CursorType">CursorType</a>&emsp;커서 모양의 종류를 표현합니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.getCursor" name = "love.mouse.getCursor"><span>love.mouse.</span><wbr>getCursor</a></p><p class = "function_description">현재 커서를 받아옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cursor</span> = love.mouse.<wbr>getCursor()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cursor</td><td class = "ra_type"><a href="#Cursor">Cursor</a></td><td>현재 설정되어 있는 커서.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.getPosition" name = "love.mouse.getPosition"><span>love.mouse.</span><wbr>getPosition</a></p><p class = "function_description">마우스의 현재 위치를 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = love.mouse.<wbr>getPosition()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>마우스의 x좌표.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>마우스의 y좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.getRelativeMode" name = "love.mouse.getRelativeMode"><span>love.mouse.</span><wbr>getRelativeMode</a></p><p class = "function_description">마우스의 상대 모드가 사용 가능한지 여부를 가져옵니다.<br /><br />상대 모드를 사용하면 커서가 숨겨져 마우스가 움직일 때 움직이지 않지만 상대 마우스 동작 이벤트는 여전히 love.mousemoved를 통해 생성됩니다. 이렇게하면 커서가 화면의 가장자리에 달라 붙지 않고 무기한 어느 방향 으로든 움직일 수 있습니다.<br /><br />상대 마우스 동작 이벤트가 생성되는 경우에도 상대 모드가 활성화되어있는 동안보고 된 마우스 위치는 업데이트되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = love.mouse.<wbr>getRelativeMode()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>상대 모드가 사용 가능하면 참이고, 사용 불가능하면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.getSystemCursor" name = "love.mouse.getSystemCursor"><span>love.mouse.</span><wbr>getSystemCursor</a></p><p class = "function_description">시스템에 내장된 커서 모양을 받아옵니다.<br /><br />커서의 모양을 바꾸고 싶을 때, 종종 현재 커서의 좌표에 이미지를 출력해서 표현합니다. 하지만 프레임 레이트가 낮을 경우 커서의 위치를 이미지가 따라가지 못하는 경우가 발생합니다. L&Ouml;VE의 Cursor는 프레임 레이트에 완전히 독립적으로 동작하므로 이러한 문제가 발생하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cursor</span> = love.mouse.<wbr>getSystemCursor( <span class = "arguments">ctype</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cursor</td><td class = "ra_type"><a href="#Cursor">Cursor</a></td><td>시스템 내장 커서.</td></tr><tr><td class = "arguments ra_name">ctype</td><td class = "ra_type"><a href="#CursorType">CursorType</a></td><td>커서 모양의 종류.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.getX" name = "love.mouse.getX"><span>love.mouse.</span><wbr>getX</a></p><p class = "function_description">마우스의 x좌표를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span> = love.mouse.<wbr>getX()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>마우스의 x좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.getY" name = "love.mouse.getY"><span>love.mouse.</span><wbr>getY</a></p><p class = "function_description">마우스의 y좌표를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">y</span> = love.mouse.<wbr>getY()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>마우스의 y좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.hasCursor" name = "love.mouse.hasCursor"><span>love.mouse.</span><wbr>hasCursor</a></p><p class = "function_description">커서 기능이 지원되는지 여부를 가져옵니다.<br /><br />지원되지 않으면 <a href="#love.mouse.newCursor">love.mouse.newCursor</a> 및 <a href="#love.mouse.getSystemCursor">love.mouse.getSystemCursor</a>를 호출하면 오류가 발생합니다. 모바일 장치는 커서를 지원하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">hascursor</span> = love.mouse.<wbr>hasCursor()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">hascursor</td><td class = "ra_type">boolean</td><td>시스템에 커서 기능이 있는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.isDown" name = "love.mouse.isDown"><span>love.mouse.</span><wbr>isDown</a></p><p class = "function_description">마우스 버튼이 눌렸는지 조사합니다. 이 함수로는 마우스 휠을 통한 스크롤을 감지할 수 없습니다. 스크롤을 감지하고 싶은 경우 콜백 함수인 love.mousepressed를 사용하세요. </p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">down</span> = love.mouse.<wbr>isDown( <span class = "arguments">button</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">down</td><td class = "ra_type">boolean</td><td>지정된 버튼이 눌러져 있으면 true입니다.</td></tr><tr><td class = "arguments ra_name">button</td><td class = "ra_type">number</td><td>확인할 단추의 인덱스입니다. 1은 기본 마우스 버튼이고 2는 보조 마우스 버튼입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>확인할 추가 버튼 번호.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.isGrabbed" name = "love.mouse.isGrabbed"><span>love.mouse.</span><wbr>isGrabbed</a></p><p class = "function_description">마우스가 윈도우 내에 갇혀 있는지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">grabbed</span> = love.mouse.<wbr>isGrabbed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">grabbed</td><td class = "ra_type">boolean</td><td>현재 마우스가 갇혀 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.isVisible" name = "love.mouse.isVisible"><span>love.mouse.</span><wbr>isVisible</a></p><p class = "function_description">마우스 커서가 보이는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">visible</span> = love.mouse.<wbr>isVisible()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">visible</td><td class = "ra_type">boolean</td><td>보이면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.newCursor" name = "love.mouse.newCursor"><span>love.mouse.</span><wbr>newCursor</a></p><p class = "function_description">ImageData나 파일로부터 Cursor 객체를 생성합니다.<br /><br />커서의 모양을 바꾸고 싶을 때, 종종 현재 커서의 좌표에 이미지를 출력해서 표현합니다. 하지만 프레임 레이트가 낮을 경우 커서의 위치를 이미지가 따라가지 못하는 경우가 발생합니다. L&Ouml;VE의 Cursor는 프레임 레이트에 완전히 독립적으로 동작하므로 이러한 문제가 발생하지 않습니다.<br /><br />핫스팟이라는 것은 실제 커서의 좌표를 말합니다. 일반적인 화살표 모양의 커서의 경우 좌측 상단의 끝 부분이 되겠고, 손가락 모양의 경우에는 검지손가락의 끝을 의미합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cursor</span> = love.mouse.<wbr>newCursor( <span class = "arguments">imageData</span>, <span class = "arguments">hotx</span>, <span class = "arguments">hoty</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cursor</td><td class = "ra_type"><a href="#Cursor">Cursor</a></td><td>새 Cursor 객체.</td></tr><tr><td class = "arguments ra_name">imageData</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>커서로 사용할 ImageData.</td></tr><tr><td class = "arguments ra_name">hotx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>ImageData 안에서 핫스팟의 x좌표.</td></tr><tr><td class = "arguments ra_name">hoty <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>ImageData 안에서 핫스팟의 y좌표.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cursor</span> = love.mouse.<wbr>newCursor( <span class = "arguments">filepath</span>, <span class = "arguments">hotx</span>, <span class = "arguments">hoty</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cursor</td><td class = "ra_type"><a href="#Cursor">Cursor</a></td><td>새 Cursor 객체.</td></tr><tr><td class = "arguments ra_name">filepath</td><td class = "ra_type">string</td><td>커서로 사용할 이미지 파일의 이름.</td></tr><tr><td class = "arguments ra_name">hotx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>이미지 안에서 핫스팟의 x좌표.</td></tr><tr><td class = "arguments ra_name">hoty <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>이미지 안에서 핫스팟의 y좌표.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cursor</span> = love.mouse.<wbr>newCursor( <span class = "arguments">fileData</span>, <span class = "arguments">hotx</span>, <span class = "arguments">hoty</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cursor</td><td class = "ra_type"><a href="#Cursor">Cursor</a></td><td>새 Cursor 객체.</td></tr><tr><td class = "arguments ra_name">fileData</td><td class = "ra_type"><a href="#FileData">FileData</a></td><td>커서로 사용할, 이미지를 표현하고 있는 FileData.</td></tr><tr><td class = "arguments ra_name">hotx <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>이미지 안에서 핫스팟의 x좌표.</td></tr><tr><td class = "arguments ra_name">hoty <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>이미지 안에서 핫스팟의 y좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.setCursor" name = "love.mouse.setCursor"><span>love.mouse.</span><wbr>setCursor</a></p><p class = "function_description">마우스 커서를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setCursor()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setCursor( <span class = "arguments">cursor</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">cursor</td><td class = "ra_type"><a href="#Cursor">Cursor</a></td><td>사용할 마우스 커서 객체.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.setGrabbed" name = "love.mouse.setGrabbed"><span>love.mouse.</span><wbr>setGrabbed</a></p><p class = "function_description">마우스를 윈도우 내에 가둡니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setGrabbed( <span class = "arguments">grab</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">grab</td><td class = "ra_type">boolean</td><td>마우스를 가두려면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.setPosition" name = "love.mouse.setPosition"><span>love.mouse.</span><wbr>setPosition</a></p><p class = "function_description">마우스의 위치를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setPosition( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>마우스의 x좌표.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>마우스의 y좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.setRelativeMode" name = "love.mouse.setRelativeMode"><span>love.mouse.</span><wbr>setRelativeMode</a></p><p class = "function_description">마우스의 상대 모드를 사용할지 여부를 설정합니다.<br /><br />상대 모드가 활성화되면 커서는 숨겨지고 마우스가 움직일 때 움직이지 않지만 상대 마우스 동작 이벤트는 여전히 love.mousemoved를 통해 생성됩니다. 이렇게하면 커서가 화면의 가장자리에 달라 붙지 않고 무기한 어느 방향 으로든 움직일 수 있습니다.<br /><br />상대 마우스 동작 이벤트가 생성되는 경우에도 상대 모드가 활성화되어있는 동안보고 된 마우스 위치는 업데이트되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setRelativeMode( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>상대 모드를 사용하려면 true이고, 사용하지 않으려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.setVisible" name = "love.mouse.setVisible"><span>love.mouse.</span><wbr>setVisible</a></p><p class = "function_description">마우스 커서의 가시성을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setVisible( <span class = "arguments">visible</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">visible</td><td class = "ra_type">boolean</td><td>보이면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.setX" name = "love.mouse.setX"><span>love.mouse.</span><wbr>setX</a></p><p class = "function_description">마우스의 x좌표를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setX( <span class = "arguments">x</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>마우스의 x좌표.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.mouse.setY" name = "love.mouse.setY"><span>love.mouse.</span><wbr>setY</a></p><p class = "function_description">마우스의 y좌표를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.mouse.<wbr>setY( <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>마우스의 y좌표.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#CursorType" name = "CursorType">CursorType</a></p><p class = "constant_name">image</p><p class = "constant_description">사용자 정의 이미지를 사용하는 커서.</p><p class = "constant_name">arrow</p><p class = "constant_description">화살표.</p><p class = "constant_name">ibeam</p><p class = "constant_description">텍스트를 편집할 때 나오는 I 비슷하게 생긴 모양.</p><p class = "constant_name">wait</p><p class = "constant_description">모래시계.</p><p class = "constant_name">waitarrow</p><p class = "constant_description">화살표와 모래시계.</p><p class = "constant_name">crosshair</p><p class = "constant_description">더하기 모양.</p><p class = "constant_name">sizenwse</p><p class = "constant_description">↖＋↘. 주로 윈도우 크기 조절 시 나타남.</p><p class = "constant_name">sizenesw</p><p class = "constant_description">↗＋↙. 주로 윈도우 크기 조절 시 나타남.</p><p class = "constant_name">sizewe</p><p class = "constant_description">↔. 주로 윈도우 크기 조절 시 나타남.</p><p class = "constant_name">sizens</p><p class = "constant_description">↕. 주로 윈도우 크기 조절 시 나타남.</p><p class = "constant_name">sizeall</p><p class = "constant_description">↔＋↕.</p><p class = "constant_name">no</p><p class = "constant_description">사용할 수 없음. 금지를 나타낼 때 사용. 동그란 원에 사선이 그어져 있는 모양.</p><p class = "constant_name">hand</p><p class = "constant_description">손가락. 주로 하이퍼 링크에 커서를 댈 때 나타남.</p></div><div class = "section"><p class = "section_heading"><a href = "#Cursor" name = "Cursor">Cursor</a></p><p class = "section_description">커서 모양을 표현합니다.<br /><br />커서의 모양을 바꾸고 싶을 때, 종종 현재 커서의 좌표에 이미지를 출력해서 표현합니다. 하지만 프레임 레이트가 낮을 경우 커서의 위치를 이미지가 따라가지 못하는 경우가 발생합니다. L&Ouml;VE의 Cursor는 프레임 레이트에 완전히 독립적으로 동작하므로 이러한 문제가 발생하지 않습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.getSystemCursor">getSystemCursor</a>&emsp;시스템에 내장된 커서 모양을 받아옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.mouse.<a href="#love.mouse.newCursor">newCursor</a>&emsp;ImageData나 파일로부터 Cursor 객체를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Cursor:<a href="#Cursor:getType">getType</a>&emsp;커서의 종류를 받아옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Cursor:getType" name = "Cursor:getType"><span>Cursor:</span><wbr>getType</a></p><p class = "function_description">커서의 종류를 받아옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cursortype</span> = Cursor:<wbr>getType()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cursortype</td><td class = "ra_type"><a href="#CursorType">CursorType</a></td><td>커서의 종류.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.physics" name = "love.physics">love.physics</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Body">Body</a>&emsp;몸체는 속도와 위치가있는 물체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ChainShape">ChainShape</a>&emsp;ChainShape는 여러 선 세그먼트로 구성됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CircleShape">CircleShape</a>&emsp;원은 모양을 확장하고 반경과 로컬 위치를 추가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Contact">Contact</a>&emsp;연락처는 세계의 충돌을 관리하기 위해 만들어진 개체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#EdgeShape">EdgeShape</a>&emsp;EdgeShape는 선 세그먼트입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#DistanceJoint">DistanceJoint</a>&emsp;두 시체를 같은 거리에 두십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Fixture">Fixture</a>&emsp;치구는 몸체에 도형을 부착합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FrictionJoint">FrictionJoint</a>&emsp;FrictionJoint는 몸체에 마찰을가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#GearJoint">GearJoint</a>&emsp;시체를 기어처럼 작동하도록 유지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MotorJoint">MotorJoint</a>&emsp;두 바디 간의 상대 모션을 제어합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MouseJoint">MouseJoint</a>&emsp;마우스로 개체를 제어하는 ​​데 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PolygonShape">PolygonShape</a>&emsp;다각형은 8면까지 볼록한 다각형입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PrismaticJoint">PrismaticJoint</a>&emsp;Bodies 간의 상대 모션을 하나의 공유 축으로 제한합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PulleyJoint">PulleyJoint</a>&emsp;풀리를 통해 연결된 시체를 시뮬레이션 할 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RevoluteJoint">RevoluteJoint</a>&emsp;두 개체가 공유 지점을 중심으로 회전하도록 허용합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RopeJoint">RopeJoint</a>&emsp;RopeJoint는 두 바디에서 두 점 사이의 최대 거리를 적용합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shape">Shape</a>&emsp;모양은 love.physics에서 사용 된 단단한 2 차원 기하학적 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#WeldJoint">WeldJoint</a>&emsp;WeldJoint는 본질적으로 두 개의 몸체를 서로 붙입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#WheelJoint">WheelJoint</a>&emsp;두 번째 본문의 한 점을 첫 번째 본문의 한 행으로 제한합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#World">World</a>&emsp;세상은 모든 몸과 관절을 포함하는 대상입니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.getDistance">getDistance</a>&emsp;두 개의 조명기와 두 조명기 사이의 가장 가까운 두 점을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.getMeter">get</a><span class = "slash">/</span><a href="#love.physics.setMeter">setMeter</a>&emsp;픽셀을 미터 스케일 인수로 설정합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#BodyType">BodyType</a>&emsp;몸의 유형. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#JointType">JointType</a>&emsp;관절의 종류가 다릅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ShapeType">ShapeType</a>&emsp;Shape : getType에 의해 돌려 주어지는 Shape의 형태는 다릅니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.getDistance" name = "love.physics.getDistance"><span>love.physics.</span><wbr>getDistance</a></p><p class = "function_description">두 개의 조명기와 두 조명기 사이의 가장 가까운 두 점을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">distance</span>, <span class = "returns">x1</span>, <span class = "returns">y1</span>, <span class = "returns">x2</span>, <span class = "returns">y2</span> = love.physics.<wbr>getDistance( <span class = "arguments">fixture1</span>, <span class = "arguments">fixture2</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">distance</td><td class = "ra_type">number</td><td>두 점의 거리.</td></tr><tr><td class = "returns ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 점의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 점의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 점의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 점의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">fixture1</td><td class = "ra_type"><a href="#Fixture">Fixture</a></td><td>첫 번째 고정 장치.</td></tr><tr><td class = "arguments ra_name">fixture2</td><td class = "ra_type"><a href="#Fixture">Fixture</a></td><td>두 번째 고정 장치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.getMeter" name = "love.physics.getMeter"><span>love.physics.</span><wbr>getMeter</a></p><p class = "function_description">세상의 규모를 알 수 있습니다.<br /><br />세계 규모는 미터 당 픽셀 수입니다. 모양 크기를이 배율의 10 배 미만으로 유지하십시오.<br /><br />이것은 Box2D의 물리 구조가 0.1m ~ 10m 크기의 물체에서 잘 작동하도록 조정 되었기 때문에 중요합니다. 모든 물리 좌표는 물리 계산을 위해이 수로 나뉩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">scale</span> = love.physics.<wbr>getMeter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">scale</td><td class = "ra_type">number</td><td>크기는 1 미터 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newBody" name = "love.physics.newBody"><span>love.physics.</span><wbr>newBody</a></p><p class = "function_description">새 본문을 만듭니다.<br /><br />시체에는 세 가지 유형이 있습니다. 정적 바디는 움직이지 않고 무한한 질량을 가지며 레벨 경계로 사용될 수 있습니다. 다이나믹 바디는 시뮬레이션의 주요 행위자이며 모든 것과 충돌합니다. 운동기구는 힘에 반응하지 않고 동적 인 몸체에만 충돌합니다.<br /><br />몸체의 질량은 Fixture가 부착되거나 제거 될 때 계산되지만 Body : setMass 또는 Body : resetMassData로 언제든지 변경할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">body</span> = love.physics.<wbr>newBody( <span class = "arguments">world</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">type</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">body</td><td class = "ra_type"><a href="#Body">Body</a></td><td>새로운 몸.</td></tr><tr><td class = "arguments ra_name">world</td><td class = "ra_type"><a href="#World">World</a></td><td>몸을 만들 세계.</td></tr><tr><td class = "arguments ra_name">x <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>몸체의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>몸체의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">type <span class = "default">("static")</span></td><td class = "ra_type"><a href="#BodyType">BodyType</a></td><td>몸의 유형.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newChainShape" name = "love.physics.newChainShape"><span>love.physics.</span><wbr>newChainShape</a></p><p class = "function_description">새로운 ChainShape를 만듭니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newChainShape( <span class = "arguments">loop</span>, <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#ChainShape">ChainShape</a></td><td>새로운 모양.</td></tr><tr><td class = "arguments ra_name">loop</td><td class = "ra_type">boolean</td><td>체인이 첫 번째 점으로 되돌아 가야하는 경우</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 포인트 위치.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newChainShape( <span class = "arguments">loop</span>, <span class = "arguments">points</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#ChainShape">ChainShape</a></td><td>새로운 모양.</td></tr><tr><td class = "arguments ra_name">loop</td><td class = "ra_type">boolean</td><td>체인이 첫 번째 점으로 되돌아 가야하는 경우</td></tr><tr><td class = "arguments ra_name">points</td><td class = "ra_type">table</td><td>{x1, y1, x2, y2, ...}의 형태로 ChainShape를 구성 할 점 목록입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newCircleShape" name = "love.physics.newCircleShape"><span>love.physics.</span><wbr>newCircleShape</a></p><p class = "function_description">새로운 CircleShape를 만듭니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newCircleShape( <span class = "arguments">radius</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#CircleShape">CircleShape</a></td><td>새로운 모양.</td></tr><tr><td class = "arguments ra_name">radius</td><td class = "ra_type">number</td><td>원의 반지름입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newCircleShape( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">radius</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#CircleShape">CircleShape</a></td><td>새로운 모양.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>원의 x 오프셋입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>원의 y 오프셋입니다.</td></tr><tr><td class = "arguments ra_name">radius</td><td class = "ra_type">number</td><td>원의 반지름입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newDistanceJoint" name = "love.physics.newDistanceJoint"><span>love.physics.</span><wbr>newDistanceJoint</a></p><p class = "function_description">두 바디 사이에 거리 조인트를 만듭니다.<br /><br />이 조인트는 두 물체의 두 점 사이의 거리를 일정하게 제한합니다. 이 두 점은 월드 좌표로 지정되며 두 관절은이 관절을 만들 때 제자리에 있다고 가정합니다. 첫 번째 앵커 포인트는 첫 번째 바디에 연결되고 두 번째 앵커 포인트는 두 번째 바디에 연결되고 점들은 거리 조인트의 길이를 정의합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newDistanceJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#DistanceJoint">DistanceJoint</a></td><td>새로운 거리 조인트.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>조인트에 부착 할 첫 번째 바디.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>접합부에 부착 할 두 번째 몸체.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 고정 점 (월드 공간)의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 고정 점 (월드 공간)의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 앵커 포인트 (월드 공간)의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 앵커 포인트 (월드 공간)의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newEdgeShape" name = "love.physics.newEdgeShape"><span>love.physics.</span><wbr>newEdgeShape</a></p><p class = "function_description">가장자리 모양을 만듭니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newEdgeShape( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#EdgeShape">EdgeShape</a></td><td>새로운 모양.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 점의 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newFixture" name = "love.physics.newFixture"><span>love.physics.</span><wbr>newFixture</a></p><p class = "function_description">Fixture를 생성하고 본체에 부착합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fixture</span> = love.physics.<wbr>newFixture( <span class = "arguments">body</span>, <span class = "arguments">shape</span>, <span class = "arguments">density</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fixture</td><td class = "ra_type"><a href="#Fixture">Fixture</a></td><td>새로운 조명기.</td></tr><tr><td class = "arguments ra_name">body</td><td class = "ra_type"><a href="#Body">Body</a></td><td>고정물을 부착 한 몸체.</td></tr><tr><td class = "arguments ra_name">shape</td><td class = "ra_type"><a href="#Shape">Shape</a></td><td>고정물의 모양.</td></tr><tr><td class = "arguments ra_name">density <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>고정구의 밀도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newFrictionJoint" name = "love.physics.newFrictionJoint"><span>love.physics.</span><wbr>newFrictionJoint</a></p><p class = "function_description">두 몸체 사이에 마찰 조인트를 만듭니다. FrictionJoint는 몸체에 마찰을가합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newFrictionJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#FrictionJoint">FrictionJoint</a></td><td>새로운 FrictionJoint.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>조인트에 부착 할 첫 번째 바디.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>접합부에 부착 할 두 번째 몸체.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>앵커 포인트의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>앵커 포인트의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 몸체가 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newGearJoint" name = "love.physics.newGearJoint"><span>love.physics.</span><wbr>newGearJoint</a></p><p class = "function_description">두 개의 조인트를 연결하는 기어 조인트를 생성하십시오.<br /><br />기어 조인트는 프리즘 또는 회전 조인트 중 하나 인 두 개의 조인트를 연결합니다. 이 관절을 사용하려면 사용하는 관절이 각각의 시체를지면에 연결하고 첫 번째 시체로지면이 있어야합니다. 시체와 관절을 파괴 할 때 다른 관절보다 먼저 기어 관절을 파괴해야합니다.<br /><br />기어 조인트는 연결된 조인트의 각도 또는 거리 값이 서로 관련되는 비율을 결정합니다. 공식 coordinate1 + ratio * coordinate2에는 항상 기어 접합이 생성 될 때 설정되는 상수 값이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newGearJoint( <span class = "arguments">joint1</span>, <span class = "arguments">joint2</span>, <span class = "arguments">ratio</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#GearJoint">GearJoint</a></td><td>새로운 기어 조인트.</td></tr><tr><td class = "arguments ra_name">joint1</td><td class = "ra_type"><a href="#Joint">Joint</a></td><td>첫 번째 조인트는 기어 조인트와 연결됩니다.</td></tr><tr><td class = "arguments ra_name">joint2</td><td class = "ra_type"><a href="#Joint">Joint</a></td><td>기어 조인트와 연결하는 두 번째 조인트.</td></tr><tr><td class = "arguments ra_name">ratio <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>기어비.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newMotorJoint" name = "love.physics.newMotorJoint"><span>love.physics.</span><wbr>newMotorJoint</a></p><p class = "function_description">두 바디 사이의 상대 모션을 제어하는 ​​두 바디 사이의 조인트를 작성합니다.<br /><br />모터 관절이 생성되면 위치 오프셋 및 회전 오프셋을 지정할 수있을뿐만 아니라 목표 오프셋에 도달하는 데 적용되는 최대 모터 힘 및 토크도 지정할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newMotorJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">correctionFactor</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#MotorJoint">MotorJoint</a></td><td>새로운 모터 조인트.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>조인트에 부착 할 첫 번째 바디.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>접합부에 부착 할 두 번째 몸체.</td></tr><tr><td class = "arguments ra_name">correctionFactor <span class = "default">(0.3)</span></td><td class = "ra_type">number</td><td>관절의 초기 위치 보정 계수로 {0, 1} 범위입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newMouseJoint" name = "love.physics.newMouseJoint"><span>love.physics.</span><wbr>newMouseJoint</a></p><p class = "function_description">몸체와 마우스 사이에 조인트를 만듭니다.<br /><br />이 조인트는 실제로 몸을 세계의 고정 된 점에 연결합니다. 마우스를 따라 가려면 고정 소수점을 모든 timestep (아래 예)마다 업데이트해야합니다.<br /><br />바디 위치를 직접 변경하는 대신 MouseJoint를 사용하면 다른 조인트와의 충돌 및 반응이 물리 엔진에 의해 처리된다는 이점이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newMouseJoint( <span class = "arguments">body</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#MouseJoint">MouseJoint</a></td><td>새로운 마우스 조인트.</td></tr><tr><td class = "arguments ra_name">body</td><td class = "ra_type"><a href="#Body">Body</a></td><td>마우스에 부착 할 몸체입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>연결 지점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>연결 지점의 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newPolygonShape" name = "love.physics.newPolygonShape"><span>love.physics.</span><wbr>newPolygonShape</a></p><p class = "function_description">새로운 PolygonShape를 작성합니다.<br /><br />이 모양은 최대 8 개의 꼭지점을 가질 수 있으며 볼록한 모양을 형성해야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newPolygonShape( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#PolygonShape">PolygonShape</a></td><td>새로운 PolygonShape.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>x 축상의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>y 축의 첫 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>x 축상의 두 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>y 축상의 두 번째 점의 위치입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>폴리곤 셰이프를 만들기 위해 더 많은 점 위치를 계속 전달할 수 있습니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newPolygonShape( <span class = "arguments">vertices</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#PolygonShape">PolygonShape</a></td><td>새로운 PolygonShape.</td></tr><tr><td class = "arguments ra_name">vertices</td><td class = "ra_type">table</td><td>{x1, y1, x2, y2, x3, y3, ...} 형식으로 다각형을 구성 할 정점 목록입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newPrismaticJoint" name = "love.physics.newPrismaticJoint"><span>love.physics.</span><wbr>newPrismaticJoint</a></p><p class = "function_description">두 몸체 사이에 프리즘 조인트를 만듭니다.<br /><br />프리즘 형 조인트는 두 바디가 지정된 축에서 서로 상대적으로 움직 이도록 제한합니다. 상대 회전을 허용하지 않습니다. 그 정의와 작동은 회전 조인트와 비슷하지만 각도와 토크를 대체하는 힘과 힘이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newPrismaticJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">ax</span>, <span class = "arguments">ay</span>, <span class = "arguments">collideConnected</span>, <span class = "arguments">referenceAngle</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#PrismaticJoint">PrismaticJoint</a></td><td>새로운 프리즘 조인트입니다.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>프리즘 결합으로 연결되는 첫 번째 몸체.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>두 번째 몸체는 프리즘 조인트와 연결됩니다.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>최초의 엥커 포인트의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>최초의 엥커 포인트의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 앵커 포인트의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>2 번째의 엥커 포인트의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">ax</td><td class = "ra_type">number</td><td>축 단위 벡터의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">ay</td><td class = "ra_type">number</td><td>축 단위 벡터의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr><tr><td class = "arguments ra_name">referenceAngle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>body1과 body2 사이의 참조 각 (라디안 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newPulleyJoint" name = "love.physics.newPulleyJoint"><span>love.physics.</span><wbr>newPulleyJoint</a></p><p class = "function_description">두 몸체를 서로 결합시키고지면을 연결하는 풀리 조인트를 만듭니다.<br /><br />풀리 조인트는 선택 블록과 태클로 도르래를 시뮬레이션합니다. 비율 매개 변수가 1과 다른 값을 갖는 경우 모의 로프는 다른 쪽보다 한 쪽에서 더 빨리 확장됩니다. 풀리 조인트에서 시뮬레이트 된 로프의 전체 길이는 일정 길이 1 + 비 * 길이 2이며 풀리 조인트를 만들 때 설정됩니다.<br /><br />풀리 조인트는 한면이 완전히 확장되면 예기치 않게 동작 할 수 있습니다. setMaxLengths 메소드를 사용하여 각면에서 얻을 수있는 최대 길이를 제한하는 것이 좋습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newPulleyJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">gx1</span>, <span class = "arguments">gy1</span>, <span class = "arguments">gx2</span>, <span class = "arguments">gy2</span>, <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">ratio</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#PulleyJoint">PulleyJoint</a></td><td>새로운 풀리 조인트.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>풀리 조인트를 연결하는 첫 번째 바디.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>풀리 조인트와 연결되는 두 번째 몸체.</td></tr><tr><td class = "arguments ra_name">gx1</td><td class = "ra_type">number</td><td>첫 번째 몸체의지면 앵커의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">gy1</td><td class = "ra_type">number</td><td>첫 번째 몸체의지면 앵커의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">gx2</td><td class = "ra_type">number</td><td>두 번째 몸체의지면 앵커의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">gy2</td><td class = "ra_type">number</td><td>두 번째 몸체의지면 앵커의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 몸체에있는 풀리 조인트 앵커의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 몸체에있는 풀리 조인트 앵커의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 몸체에있는 풀리 조인트 앵커의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 몸체에있는 풀리 조인트 앵커의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">ratio <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>합동 비율.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newRectangleShape" name = "love.physics.newRectangleShape"><span>love.physics.</span><wbr>newRectangleShape</a></p><p class = "function_description">직사각형 다각형을 만들기위한 속기.<br /><br />기본적으로 로컬 원점은 그래픽의 왼쪽 상단이 아니라 직사각형의 가운데에 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newRectangleShape( <span class = "arguments">width</span>, <span class = "arguments">height</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#PolygonShape">PolygonShape</a></td><td>새로운 PolygonShape.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>사각형의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>사각형의 높이입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = love.physics.<wbr>newRectangleShape( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">width</span>, <span class = "arguments">height</span>, <span class = "arguments">angle</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#PolygonShape">PolygonShape</a></td><td>새로운 PolygonShape.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 축을 따른 오프셋입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 축을 따른 오프셋입니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>사각형의 너비입니다.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>사각형의 높이입니다.</td></tr><tr><td class = "arguments ra_name">angle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>사각형의 초기 각도입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newRevoluteJoint" name = "love.physics.newRevoluteJoint"><span>love.physics.</span><wbr>newRevoluteJoint</a></p><p class = "function_description">두 바디 사이에 피벗 조인트를 작성합니다.<br /><br />이 조인트는 두 개의 몸체를 피봇 할 수있는 지점에 연결합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newRevoluteJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#RevoluteJoint">RevoluteJoint</a></td><td>새로운 회전 조인트.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>첫 번째 몸.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>두 번째 몸.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>연결 지점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>연결 지점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newRevoluteJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">collideConnected</span>, <span class = "arguments">referenceAngle</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#RevoluteJoint">RevoluteJoint</a></td><td>새로운 회전 조인트.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>첫 번째 몸.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>두 번째 몸.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 연결점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>최초의 접속점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 연결 지점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 연결점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr><tr><td class = "arguments ra_name">referenceAngle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newRopeJoint" name = "love.physics.newRopeJoint"><span>love.physics.</span><wbr>newRopeJoint</a></p><p class = "function_description">두 몸체 사이에 조인트를 만듭니다. 그것의 유일한 기능은이 시체들 사이에 최대한의 거리를 두는 것입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newRopeJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">maxLength</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#RopeJoint">RopeJoint</a></td><td>새로운 RopeJoint.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>조인트에 부착 할 첫 번째 바디.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>접합부에 부착 할 두 번째 몸체.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>최초의 엥커 포인트의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>최초의 엥커 포인트의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 앵커 포인트의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 앵커 포인트의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">maxLength</td><td class = "ra_type">number</td><td>시체의 최대 거리.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newWeldJoint" name = "love.physics.newWeldJoint"><span>love.physics.</span><wbr>newWeldJoint</a></p><p class = "function_description">두 바디 사이에 구속 조건 조인트를 작성합니다. WeldJoint는 본질적으로 두 개의 몸체를 서로 붙입니다. 그러나 제약 조건은 Box2D의 반복 솔버로 인해 조금 부드럽습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newWeldJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">collideConnected</span>, <span class = "arguments">referenceAngle</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#WeldJoint">WeldJoint</a></td><td>새로운 용접 조인트.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>조인트에 부착 할 첫 번째 바디.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>접합부에 부착 할 두 번째 몸체.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 고정 점 (월드 공간)의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 고정 점 (월드 공간)의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 앵커 포인트 (월드 공간)의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 앵커 포인트 (월드 공간)의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr><tr><td class = "arguments ra_name">referenceAngle <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>body1과 body2 사이의 참조 각 (라디안 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newWheelJoint" name = "love.physics.newWheelJoint"><span>love.physics.</span><wbr>newWheelJoint</a></p><p class = "function_description">휠 조인트를 만듭니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint</span> = love.physics.<wbr>newWheelJoint( <span class = "arguments">body1</span>, <span class = "arguments">body2</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">ax</span>, <span class = "arguments">ay</span>, <span class = "arguments">collideConnected</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint</td><td class = "ra_type"><a href="#WheelJoint">WheelJoint</a></td><td>새로운 WheelJoint.</td></tr><tr><td class = "arguments ra_name">body1</td><td class = "ra_type"><a href="#Body">Body</a></td><td>첫 번째 몸.</td></tr><tr><td class = "arguments ra_name">body2</td><td class = "ra_type"><a href="#Body">Body</a></td><td>두 번째 몸.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>앵커 포인트의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>앵커 포인트의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">ax</td><td class = "ra_type">number</td><td>축 단위 벡터의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">ay</td><td class = "ra_type">number</td><td>축 단위 벡터의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">collideConnected <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>두 본문이 서로 충돌해야하는지 여부를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.newWorld" name = "love.physics.newWorld"><span>love.physics.</span><wbr>newWorld</a></p><p class = "function_description">새로운 세계를 창조합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">world</span> = love.physics.<wbr>newWorld( <span class = "arguments">xg</span>, <span class = "arguments">yg</span>, <span class = "arguments">sleep</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">world</td><td class = "ra_type"><a href="#World">World</a></td><td>용감한 새로운 세상.</td></tr><tr><td class = "arguments ra_name">xg <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>중력의 x 성분.</td></tr><tr><td class = "arguments ra_name">yg <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>중력의 y 성분.</td></tr><tr><td class = "arguments ra_name">sleep <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>이 세상의 시체가 자고 있는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.physics.setMeter" name = "love.physics.setMeter"><span>love.physics.</span><wbr>setMeter</a></p><p class = "function_description">픽셀을 미터 스케일 인수로 설정합니다.<br /><br />물리 모듈의 모든 좌표는이 숫자로 나누어 져 미터로 변환되며 그래픽 변환이 필요없이 객체를 화면에 직접 그릴 수있는 편리한 방법을 만듭니다.<br /><br />크기의 10 배 이하의 모양을 만드는 것이 좋습니다. 이것은 Box2D가 0.1에서 10 미터의 모양 크기에서 잘 작동하도록 조정 되었기 때문에 중요합니다. 기본 미터 스케일은 30입니다.<br /><br />love.physics.setMeter는 생성 된 객체에 소급 적용되지 않습니다. 생성 된 객체는 미터 좌표를 유지하지만 배율 인수는 픽셀 좌표에 영향을줍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.physics.<wbr>setMeter( <span class = "arguments">scale</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">scale</td><td class = "ra_type">number</td><td>정수로서의 스케일 인수.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#BodyType" name = "BodyType">BodyType</a></p><p class = "constant_name">static</p><p class = "constant_description">정적 체는 움직이지 않습니다.</p><p class = "constant_name">dynamic</p><p class = "constant_description">동적 인 몸체가 모든 몸체와 충돌합니다.</p><p class = "constant_name">kinematic</p><p class = "constant_description">키네마 틱 바디는 동적 바디에만 충돌합니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#JointType" name = "JointType">JointType</a></p><p class = "constant_name">distance</p><p class = "constant_description">거리 관절.</p><p class = "constant_name">gear</p><p class = "constant_description">기어 조인트.</p><p class = "constant_name">mouse</p><p class = "constant_description">MouseJoint.</p><p class = "constant_name">prismatic</p><p class = "constant_description">프리즘 관절.</p><p class = "constant_name">pulley</p><p class = "constant_description">풀리 조인트.</p><p class = "constant_name">revolute</p><p class = "constant_description">RevoluteJoint.</p><p class = "constant_name">friction</p><p class = "constant_description">마찰 조인트.</p><p class = "constant_name">weld</p><p class = "constant_description">웰드 조인트.</p><p class = "constant_name">rope</p><p class = "constant_description">로프 조인트.</p></div><div class = "section"><p class = "section_heading"><a href = "#ShapeType" name = "ShapeType">ShapeType</a></p><p class = "constant_name">circle</p><p class = "constant_description">모양은 원 모양입니다.</p><p class = "constant_name">polygon</p><p class = "constant_description">Shape는 PolygonShape입니다.</p><p class = "constant_name">edge</p><p class = "constant_description">모양은 EdgeShape입니다.</p><p class = "constant_name">chain</p><p class = "constant_description">모양은 체인 셰이프입니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#Body" name = "Body">Body</a></p><p class = "section_description">몸체는 속도와 위치가있는 물체입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newBody">newBody</a>&emsp;새 본문을 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:applyAngularImpulse">applyAngularImpulse</a>&emsp;몸에 각진 충격을가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:applyForce">applyForce</a>&emsp;몸에 힘을가하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:applyLinearImpulse">applyLinearImpulse</a>&emsp;몸에 충격을가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:applyTorque">applyTorque</a>&emsp;몸에 토크를가하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:destroy">destroy</a>&emsp;시체를 명시 적으로 파괴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getContactList">getContactList</a>&emsp;본문에 첨부 된 모든 연락처 목록을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getFixtureList">getFixtureList</a>&emsp;모든 조명기가있는 테이블을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getJointList">getJointList</a>&emsp;이 Body에 연결된 Joint가 들어있는 테이블을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getLinearVelocityFromLocalPoint">getLinearVelocityFromLocalPoint</a>&emsp;몸체의 한 점의 선 속도를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getLinearVelocityFromWorldPoint">getLinearVelocityFromWorldPoint</a>&emsp;몸체의 한 점의 선 속도를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getLocalCenter">getLocalCenter</a>&emsp;로컬 좌표로 질량 위치의 중심을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getLocalPoint">getLocalPoint</a>&emsp;세계 좌표에서 로컬 좌표로 포인트를 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getLocalVector">getLocalVector</a>&emsp;벡터를 월드 좌표에서 로컬 좌표로 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getWorld">getWorld</a>&emsp;몸이 사는 세상을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getWorldCenter">getWorldCenter</a>&emsp;세계 좌표에서 질량 위치의 중심을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getWorldPoint">getWorldPoint</a>&emsp;로컬 좌표에서 세계 좌표로 점을 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getWorldPoints">getWorldPoints</a>&emsp;로컬 좌표에서 세계 좌표로 여러 점을 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getWorldVector">getWorldVector</a>&emsp;벡터를 로컬 좌표에서 월드 좌표로 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:isDestroyed">isDestroyed</a>&emsp;Body가 소멸되었는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:resetMassData">resetMassData</a>&emsp;조명기의 질량 특성에서 다시 계산하여 몸체의 질량을 재설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:isActive">is</a><span class = "slash">/</span><a href="#Body:setActive">setActive</a>&emsp;월드에서 본문이 활성 상태인지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getAngle">get</a><span class = "slash">/</span><a href="#Body:setAngle">setAngle</a>&emsp;몸의 각도를 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getAngularDamping">get</a><span class = "slash">/</span><a href="#Body:setAngularDamping">setAngularDamping</a>&emsp;Body의 각도 감쇠를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getAngularVelocity">get</a><span class = "slash">/</span><a href="#Body:setAngularVelocity">setAngularVelocity</a>&emsp;Body의 각속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:isAwake">is</a><span class = "slash">/</span><a href="#Body:setAwake">setAwake</a>&emsp;시체를 깨우거나 잠자기 상태로 만듭니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:isBullet">is</a><span class = "slash">/</span><a href="#Body:setBullet">setBullet</a>&emsp;본문의 글 머리 상태를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:isFixedRotation">is</a><span class = "slash">/</span><a href="#Body:setFixedRotation">setFixedRotation</a>&emsp;몸체가 고정 된 회전을 가지는지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getGravityScale">get</a><span class = "slash">/</span><a href="#Body:setGravityScale">setGravityScale</a>&emsp;몸체에 새로운 중력 스케일 인수를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getInertia">get</a><span class = "slash">/</span><a href="#Body:setInertia">setInertia</a>&emsp;몸체의 관성을 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getLinearDamping">get</a><span class = "slash">/</span><a href="#Body:setLinearDamping">setLinearDamping</a>&emsp;바디의 선형 댐핑을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getLinearVelocity">get</a><span class = "slash">/</span><a href="#Body:setLinearVelocity">setLinearVelocity</a>&emsp;Body에 대한 새로운 선형 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getMass">get</a><span class = "slash">/</span><a href="#Body:setMass">setMass</a>&emsp;질량을 킬로그램 단위로 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getMassData">get</a><span class = "slash">/</span><a href="#Body:setMassData">setMassData</a>&emsp;계산 된 대량 데이터를 무시합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getPosition">get</a><span class = "slash">/</span><a href="#Body:setPosition">setPosition</a>&emsp;몸체의 위치를 ​​설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:isSleepingAllowed">is</a><span class = "slash">/</span><a href="#Body:setSleepingAllowed">setSleepingAllowed</a>&emsp;바디의 수면 동작을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getType">get</a><span class = "slash">/</span><a href="#Body:setType">setType</a>&emsp;새로운 본문 유형을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getUserData">get</a><span class = "slash">/</span><a href="#Body:setUserData">setUserData</a>&emsp;Lua 값을 본문과 연관시킵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getX">get</a><span class = "slash">/</span><a href="#Body:setX">setX</a>&emsp;본문의 x 위치를 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">Body:<a href="#Body:getY">get</a><span class = "slash">/</span><a href="#Body:setY">setY</a>&emsp;본문의 y 위치를 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Body:applyAngularImpulse" name = "Body:applyAngularImpulse"><span>Body:</span><wbr>applyAngularImpulse</a></p><p class = "function_description">몸에 각진 충격을가합니다. 이것은 몸의 기세에 단 한번의 즉각적인 추가를 만든다.<br /><br />질량이 큰 몸체는 덜 반응합니다. 반응은 타임 스텝 (timestep)에 의존하지 않으며, 1 초 동안 연속적으로 힘을 가하는 것과 같습니다. 충격은 몸에 단 한번 누르는 것이 가장 좋습니다. 바디에 대한 지속적인 푸시를 위해서는 body : applyForce를 사용하는 것이 더 좋습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>applyAngularImpulse( <span class = "arguments">impulse</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">impulse</td><td class = "ra_type">number</td><td>초당 킬로그램 - 평방 미터의 충격.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:applyForce" name = "Body:applyForce"><span>Body:</span><wbr>applyForce</a></p><p class = "function_description">몸에 힘을가하십시오.<br /><br />힘은 몸체를 한 방향으로 밀어 낸다. 질량이 큰 몸체는 덜 반응합니다. 반응은 또한 힘이 적용되는 시간에 따라 달라집니다. 힘이 전체 시간 단계에 걸쳐 연속적으로 작용하기 때문에 짧은 시간 간격으로 짧은 시간 동안 몸체를 밀 수 있습니다. 따라서 힘은 여러 타임 스텝에서 몸에 지속적으로 힘을 가하는 데 (중력과 같이) 사용하는 것이 가장 좋습니다. timestep과 무관 한 단일 푸시의 경우 Body : applyLinearImpulse를 사용하는 것이 좋습니다.<br /><br />힘을 가하는 위치가 주어지지 않으면 신체의 질량 중심에서 작용합니다. 질량 중심으로 향하지 않는 힘의 부분은 몸체가 회전하도록합니다 (회전 관성에 따라 달라집니다).<br /><br />힘 요소와 위치는 월드 좌표로 주어져야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>applyForce( <span class = "arguments">fx</span>, <span class = "arguments">fy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">fx</td><td class = "ra_type">number</td><td>힘의 x 성분은 질량 중심에 적용됩니다.</td></tr><tr><td class = "arguments ra_name">fy</td><td class = "ra_type">number</td><td>힘의 y 성분은 질량 중심에 적용됩니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>applyForce( <span class = "arguments">fx</span>, <span class = "arguments">fy</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">fx</td><td class = "ra_type">number</td><td>적용 할 힘의 x 성분.</td></tr><tr><td class = "arguments ra_name">fy</td><td class = "ra_type">number</td><td>적용 할 힘의 y 요소입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>힘을 적용 할 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>힘을 적용하는 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:applyLinearImpulse" name = "Body:applyLinearImpulse"><span>Body:</span><wbr>applyLinearImpulse</a></p><p class = "function_description">몸에 충격을가합니다. 이것은 몸의 기세에 단 한번의 즉각적인 추가를 만든다.<br /><br />충동은 몸을 한 방향으로 밀어냅니다. 질량이 큰 몸체는 덜 반응합니다. 반응은 타임 스텝 (timestep)에 의존하지 않으며, 1 초 동안 연속적으로 힘을 가하는 것과 같습니다. 충격은 몸에 단 한번 누르는 것이 가장 좋습니다. 바디에 대한 지속적인 푸시를 위해서는 body : applyForce를 사용하는 것이 더 좋습니다.<br /><br />임펄스를 적용 할 위치가 주어지지 않으면 몸의 질량 중심에서 작용합니다. 질량 중심으로 향하지 않는 충격의 부분은 몸체가 회전하도록합니다 (회전 관성에 따라 달라집니다).<br /><br />임펄스 구성 요소와 위치는 월드 좌표로 지정해야합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>applyLinearImpulse( <span class = "arguments">ix</span>, <span class = "arguments">iy</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ix</td><td class = "ra_type">number</td><td>임펄스의 x 성분은 질량 중심에 적용됩니다.</td></tr><tr><td class = "arguments ra_name">iy</td><td class = "ra_type">number</td><td>임펄스의 y 성분은 질량 중심에 적용됩니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>applyLinearImpulse( <span class = "arguments">ix</span>, <span class = "arguments">iy</span>, <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ix</td><td class = "ra_type">number</td><td>임펄스의 x 성분.</td></tr><tr><td class = "arguments ra_name">iy</td><td class = "ra_type">number</td><td>임펄스의 y 성분입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>임펄스를 적용 할 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>임펄스를 적용하는 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:applyTorque" name = "Body:applyTorque"><span>Body:</span><wbr>applyTorque</a></p><p class = "function_description">몸에 토크를가하십시오.<br /><br />토크는 몸체의 각속도 (스핀)를 변화시키는 힘과 같습니다. 이 효과는 몸체의 회전 관성에 따라 달라집니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>applyTorque( <span class = "arguments">torque</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">torque</td><td class = "ra_type">number</td><td>적용 할 토크.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:destroy" name = "Body:destroy"><span>Body:</span><wbr>destroy</a></p><p class = "function_description">시체를 명시 적으로 파괴합니다. 가비지 수집을 기다릴 시간이 없으면이 함수를 사용하여 개체를 즉시 해제 할 수 있지만이 함수를 호출 한 후에 개체를 사용하려고하면 오류가 발생합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>destroy()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getAngle" name = "Body:getAngle"><span>Body:</span><wbr>getAngle</a></p><p class = "function_description">몸의 각도를 잡아라.<br /><br />각도는 라디안 단위로 측정됩니다. 각도로 변환해야한다면 math.deg를 사용하십시오.<br /><br />0 라디안의 값은 "오른쪽으로보고있는"것을 의미합니다. 라디안은 반 시계 방향으로 증가하지만 Y 축은 아래로 향하므로 시계 방향으로 표시됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">angle</span> = Body:<wbr>getAngle()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">angle</td><td class = "ra_type">number</td><td>라디안 단위의 각도입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getAngularDamping" name = "Body:getAngularDamping"><span>Body:</span><wbr>getAngularDamping</a></p><p class = "function_description">몸의 각도 댐핑을 가져옵니다.<br /><br />각도 감쇠는 시간에 따른 각속도의 감소 속도입니다. 감쇠가없고 외부 힘이없는 회전 몸체는 무기한으로 계속 회전합니다. 댐핑이있는 회전 몸체는 점차 회전을 멈 춥니 다.<br /><br />댐핑은 마찰과 같지 않습니다 - 그들은 함께 모델링 될 수 있습니다. 그러나 Box2D (및 L-VE) 만 댐핑을 제공합니다.<br /><br />댐핑 매개 변수는 0과 무한대 사이에 있어야하며, 0은 댐핑이 없음을 의미하고 무한대는 전체 댐핑을 의미합니다. 일반적으로 0과 0.1 사이의 감쇠 값을 사용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">damping</span> = Body:<wbr>getAngularDamping()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">damping</td><td class = "ra_type">number</td><td>각도 댐핑의 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getAngularVelocity" name = "Body:getAngularVelocity"><span>Body:</span><wbr>getAngularVelocity</a></p><p class = "function_description">몸체의 각속도를 구하십시오.<br /><br />각속도는 시간에 따른 각도 변화의 비율입니다.<br /><br />세계에서 변경되었습니다 : 토크 적용, 중심 힘 / 충격 및 각도 감쇠 해제를 적용하여 업데이트합니다. Body : setAngularVelocity로 직접 설정할 수 있습니다.<br /><br />시간이 지남에 따라 위치 변경 비율이 필요한 경우 Body : getLinearVelocity를 사용하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">w</span> = Body:<wbr>getAngularVelocity()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">w</td><td class = "ra_type">number</td><td>라디안 / 초 단위의 각속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getContactList" name = "Body:getContactList"><span>Body:</span><wbr>getContactList</a></p><p class = "function_description">본문에 첨부 된 모든 연락처 목록을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">contacts</span> = Body:<wbr>getContactList()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">contacts</td><td class = "ra_type">table</td><td>본문과 관련된 모든 연락처가있는 목록입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getFixtureList" name = "Body:getFixtureList"><span>Body:</span><wbr>getFixtureList</a></p><p class = "function_description">모든 조명기가있는 테이블을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fixtures</span> = Body:<wbr>getFixtureList()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fixtures</td><td class = "ra_type">table</td><td>모든 조명기들로 이루어진 시퀀스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getGravityScale" name = "Body:getGravityScale"><span>Body:</span><wbr>getGravityScale</a></p><p class = "function_description">중력 배율 인수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">scale</span> = Body:<wbr>getGravityScale()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">scale</td><td class = "ra_type">number</td><td>중력 규모 인자.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getInertia" name = "Body:getInertia"><span>Body:</span><wbr>getInertia</a></p><p class = "function_description">몸체의 회전 관성을 가져옵니다.<br /><br />회전 관성은 몸을 회전시키기가 얼마나 힘든가.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">inertia</span> = Body:<wbr>getInertia()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">inertia</td><td class = "ra_type">number</td><td>몸의 회전 관성.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getJointList" name = "Body:getJointList"><span>Body:</span><wbr>getJointList</a></p><p class = "function_description">이 Body에 연결된 Joint가 들어있는 테이블을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joints</span> = Body:<wbr>getJointList()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joints</td><td class = "ra_type">table</td><td>몸에 연결된 관절과의 순서.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getLinearDamping" name = "Body:getLinearDamping"><span>Body:</span><wbr>getLinearDamping</a></p><p class = "function_description">Body의 선형 감쇠를 가져옵니다.<br /><br />선형 감쇠는 시간에 따른 선형 속도의 감소 속도입니다. 댐핑이없고 외력이없는 움직이는 몸체는 우주 에서처럼 계속 움직일 것입니다. 댐핑 기능이있는 이동체는 점차 움직이지 않습니다.<br /><br />댐핑은 마찰과 같지 않습니다 - 그들은 함께 모델링 될 수 있습니다. 그러나 Box2D (및 L-VE) 만 댐핑을 제공합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">damping</span> = Body:<wbr>getLinearDamping()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">damping</td><td class = "ra_type">number</td><td>선형 감쇠의 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getLinearVelocity" name = "Body:getLinearVelocity"><span>Body:</span><wbr>getLinearVelocity</a></p><p class = "function_description">몸체의 중심으로부터 선형 속도를 가져옵니다.<br /><br />선형 속도는 시간에 따른 위치 변화의 비율입니다.<br /><br />시간 경과에 따른 각도 변경 비율이 필요한 경우 Body : getAngularVelocity를 사용하십시오. 질량 중심과 다른 점의 선 속도를 구해야하는 경우 :<br /><br />본문 : getLinearVelocityFromLocalPoint를 사용하면 점을 로컬 좌표로 지정할 수 있습니다.<br /><br />본문 : getLinearVelocityFromWorldPoint를 사용하면 좌표를 세계 좌표로 지정할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = Body:<wbr>getLinearVelocity()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>속도 벡터의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>속도 벡터의 y 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getLinearVelocityFromLocalPoint" name = "Body:getLinearVelocityFromLocalPoint"><span>Body:</span><wbr>getLinearVelocityFromLocalPoint</a></p><p class = "function_description">몸체의 한 점의 선 속도를 구합니다.<br /><br />몸체 위의 점에 대한 선형 속도는 몸체 중심에서의 속도와 몸체 회전에서 그 점에서의 속도입니다.<br /><br />몸체의 점은 로컬 좌표로 주어져야합니다. Body : getLinearVelocityFromWorldPoint를 사용하여 이것을 월드 좌표와 함께 지정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">vx</span>, <span class = "returns">vy</span> = Body:<wbr>getLinearVelocityFromLocalPoint( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">vx</td><td class = "ra_type">number</td><td>점 (x, y)에서 속도의 x 성분.</td></tr><tr><td class = "returns ra_name">vy</td><td class = "ra_type">number</td><td>점 (x, y)에서 속도의 y 성분.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>속도를 측정하는 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>속도를 측정하는 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getLinearVelocityFromWorldPoint" name = "Body:getLinearVelocityFromWorldPoint"><span>Body:</span><wbr>getLinearVelocityFromWorldPoint</a></p><p class = "function_description">몸체의 한 점의 선 속도를 구합니다.<br /><br />몸체 위의 점에 대한 선형 속도는 몸체 중심에서의 속도와 몸체 회전에서 그 점에서의 속도입니다.<br /><br />몸의 포인트는 세계 좌표로 주어져야합니다. Body : getLinearVelocityFromLocalPoint를 사용하여 이것을 로컬 좌표로 지정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">vx</span>, <span class = "returns">vy</span> = Body:<wbr>getLinearVelocityFromWorldPoint( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">vx</td><td class = "ra_type">number</td><td>점 (x, y)에서 속도의 x 성분.</td></tr><tr><td class = "returns ra_name">vy</td><td class = "ra_type">number</td><td>점 (x, y)에서 속도의 y 성분.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>속도를 측정하는 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>속도를 측정하는 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getLocalCenter" name = "Body:getLocalCenter"><span>Body:</span><wbr>getLocalCenter</a></p><p class = "function_description">로컬 좌표로 질량 위치의 중심을 가져옵니다.<br /><br />Body : getWorldCenter를 사용하여 세계 좌표에서 질량 중심을 얻습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = Body:<wbr>getLocalCenter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>질량 중심의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>질량 중심의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getLocalPoint" name = "Body:getLocalPoint"><span>Body:</span><wbr>getLocalPoint</a></p><p class = "function_description">세계 좌표에서 로컬 좌표로 포인트를 변환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">localX</span>, <span class = "returns">localY</span> = Body:<wbr>getLocalPoint( <span class = "arguments">worldX</span>, <span class = "arguments">worldY</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">localX</td><td class = "ra_type">number</td><td>로컬 좌표의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">localY</td><td class = "ra_type">number</td><td>로컬 좌표의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">worldX</td><td class = "ra_type">number</td><td>세계 좌표의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">worldY</td><td class = "ra_type">number</td><td>세계 좌표의 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getLocalVector" name = "Body:getLocalVector"><span>Body:</span><wbr>getLocalVector</a></p><p class = "function_description">벡터를 월드 좌표에서 로컬 좌표로 변환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">localX</span>, <span class = "returns">localY</span> = Body:<wbr>getLocalVector( <span class = "arguments">worldX</span>, <span class = "arguments">worldY</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">localX</td><td class = "ra_type">number</td><td>로컬 좌표의 벡터 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">localY</td><td class = "ra_type">number</td><td>로컬 좌표의 벡터 y 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">worldX</td><td class = "ra_type">number</td><td>세계 좌표의 벡터 x 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">worldY</td><td class = "ra_type">number</td><td>세계 좌표의 벡터 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getMass" name = "Body:getMass"><span>Body:</span><wbr>getMass</a></p><p class = "function_description">시체의 질량을 구하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mass</span> = Body:<wbr>getMass()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mass</td><td class = "ra_type">number</td><td>몸의 질량 (킬로그램).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getMassData" name = "Body:getMassData"><span>Body:</span><wbr>getMassData</a></p><p class = "function_description">질량, 중심 및 회전 관성을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">mass</span>, <span class = "returns">inertia</span> = Body:<wbr>getMassData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>질량 중심의 x 위치입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>질량 중심의 y 위치입니다.</td></tr><tr><td class = "returns ra_name">mass</td><td class = "ra_type">number</td><td>몸체의 질량.</td></tr><tr><td class = "returns ra_name">inertia</td><td class = "ra_type">number</td><td>회전 관성.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getPosition" name = "Body:getPosition"><span>Body:</span><wbr>getPosition</a></p><p class = "function_description">몸의 위치를 ​​잡아라.<br /><br />이것은 신체의 질량 중심이 아닐 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = Body:<wbr>getPosition()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>x 위치.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getType" name = "Body:getType"><span>Body:</span><wbr>getType</a></p><p class = "function_description">본문의 형식을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">type</span> = Body:<wbr>getType()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">type</td><td class = "ra_type"><a href="#BodyType">BodyType</a></td><td>몸 유형.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getUserData" name = "Body:getUserData"><span>Body:</span><wbr>getUserData</a></p><p class = "function_description">이 Body와 관련된 루아 값을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = Body:<wbr>getUserData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">any</td><td>Lua 값은 본문과 관련됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getWorld" name = "Body:getWorld"><span>Body:</span><wbr>getWorld</a></p><p class = "function_description">몸이 사는 세상을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">world</span> = Body:<wbr>getWorld()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">world</td><td class = "ra_type"><a href="#World">World</a></td><td>몸이 사는 세상.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getWorldCenter" name = "Body:getWorldCenter"><span>Body:</span><wbr>getWorldCenter</a></p><p class = "function_description">세계 좌표에서 질량 위치의 중심을 가져옵니다.<br /><br />Body : getLocalCenter를 사용하여 로컬 좌표로 질량 중심을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = Body:<wbr>getWorldCenter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>질량 중심의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>질량 중심의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getWorldPoint" name = "Body:getWorldPoint"><span>Body:</span><wbr>getWorldPoint</a></p><p class = "function_description">로컬 좌표에서 세계 좌표로 점을 변환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">worldX</span>, <span class = "returns">worldY</span> = Body:<wbr>getWorldPoint( <span class = "arguments">localX</span>, <span class = "arguments">localY</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">worldX</td><td class = "ra_type">number</td><td>세계 좌표의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">worldY</td><td class = "ra_type">number</td><td>세계 좌표의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">localX</td><td class = "ra_type">number</td><td>로컬 좌표의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">localY</td><td class = "ra_type">number</td><td>로컬 좌표의 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getWorldPoints" name = "Body:getWorldPoints"><span>Body:</span><wbr>getWorldPoints</a></p><p class = "function_description">로컬 좌표에서 세계 좌표로 여러 점을 변환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x1</span>, <span class = "returns">y1</span>, <span class = "returns">x2</span>, <span class = "returns">y2</span>, <span class = "returns">...</span> = Body:<wbr>getWorldPoints( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 점의 변형 된 x 위치입니다.</td></tr><tr><td class = "returns ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 점의 변형 된 y 위치입니다.</td></tr><tr><td class = "returns ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 점의 변형 된 x 위치입니다.</td></tr><tr><td class = "returns ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 점의 변형 된 y 위치입니다.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>추가 점의 변형 된 x 및 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>더 많은 x와 y 포인트.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getWorldVector" name = "Body:getWorldVector"><span>Body:</span><wbr>getWorldVector</a></p><p class = "function_description">벡터를 로컬 좌표에서 월드 좌표로 변환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">worldX</span>, <span class = "returns">worldY</span> = Body:<wbr>getWorldVector( <span class = "arguments">localX</span>, <span class = "arguments">localY</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">worldX</td><td class = "ra_type">number</td><td>세계 좌표의 벡터 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">worldY</td><td class = "ra_type">number</td><td>세계 좌표의 벡터 y 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">localX</td><td class = "ra_type">number</td><td>로컬 좌표의 벡터 x 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">localY</td><td class = "ra_type">number</td><td>로컬 좌표의 벡터 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getX" name = "Body:getX"><span>Body:</span><wbr>getX</a></p><p class = "function_description">세계 좌표계에서 몸체의 x 위치를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span> = Body:<wbr>getX()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>세계 좌표의 x 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:getY" name = "Body:getY"><span>Body:</span><wbr>getY</a></p><p class = "function_description">세계 좌표계에서 y 좌표를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">y</span> = Body:<wbr>getY()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>세계 좌표의 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:isActive" name = "Body:isActive"><span>Body:</span><wbr>isActive</a></p><p class = "function_description">바디가 시뮬레이션에서 활발하게 사용되는지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">status</span> = Body:<wbr>isActive()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">status</td><td class = "ra_type">boolean</td><td>본문이 활성화되어 있으면 true이고 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:isAwake" name = "Body:isAwake"><span>Body:</span><wbr>isAwake</a></p><p class = "function_description">본문의 휴면 상태를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">status</span> = Body:<wbr>isAwake()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">status</td><td class = "ra_type">boolean</td><td>본문이 깨어지면 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:isBullet" name = "Body:isBullet"><span>Body:</span><wbr>isBullet</a></p><p class = "function_description">몸의 총알 상태를 가져옵니다.<br /><br />신체 충돌을 확인하는 방법에는 두 가지가 있습니다.<br /><br />세계가 업데이트 될 때의 위치 (기본값)<br /><br />연속 충돌 감지 (CCD)<br /><br />기본 방법은 효율적이지만, 매우 빠르게 움직이는 몸체는 충돌을 일으키지 않고 다른 몸체로 점프 할 수 있습니다. 총알으로 설정된 신체는 CCD를 사용합니다. 이것은 덜 효율적이지만 신속하게 움직일 때 점프하지 않을 것입니다.<br /><br />정적 물체 (질량이 0 인)는 항상 CCD를 사용하므로 벽이 빨리 움직이는 물체가 총알이 아니더라도 통과시키지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">status</span> = Body:<wbr>isBullet()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">status</td><td class = "ra_type">boolean</td><td>몸의 총알 상태.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:isDestroyed" name = "Body:isDestroyed"><span>Body:</span><wbr>isDestroyed</a></p><p class = "function_description">Body가 소멸되었는지 여부를 가져옵니다. 파괴 된 시체는 사용할 수 없습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">destroyed</span> = Body:<wbr>isDestroyed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">destroyed</td><td class = "ra_type">boolean</td><td>시체가 파괴되는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:isFixedRotation" name = "Body:isFixedRotation"><span>Body:</span><wbr>isFixedRotation</a></p><p class = "function_description">몸체 회전이 잠겨 있는지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fixed</span> = Body:<wbr>isFixedRotation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fixed</td><td class = "ra_type">boolean</td><td>본문의 회전이 잠겨 있으면 true이고 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:isSleepingAllowed" name = "Body:isSleepingAllowed"><span>Body:</span><wbr>isSleepingAllowed</a></p><p class = "function_description">몸의 수면 동작을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">status</span> = Body:<wbr>isSleepingAllowed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">status</td><td class = "ra_type">boolean</td><td>본문이 휴면 할 수 있으면 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:resetMassData" name = "Body:resetMassData"><span>Body:</span><wbr>resetMassData</a></p><p class = "function_description">조명기의 질량 특성에서 다시 계산하여 몸체의 질량을 재설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>resetMassData()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setActive" name = "Body:setActive"><span>Body:</span><wbr>setActive</a></p><p class = "function_description">월드에서 본문이 활성 상태인지 여부를 설정합니다.<br /><br />비활성 바디는 시뮬레이션에 참여하지 않습니다. 이동하거나 충돌을 일으키지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setActive( <span class = "arguments">active</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">active</td><td class = "ra_type">boolean</td><td>몸이 활성 상태인지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setAngle" name = "Body:setAngle"><span>Body:</span><wbr>setAngle</a></p><p class = "function_description">몸의 각도를 설정하십시오.<br /><br />각도는 라디안 단위로 측정됩니다. 각도에서 변환해야하는 경우 math.rad를 사용하십시오.<br /><br />0 라디안의 값은 "오른쪽으로보고있는"것을 의미합니다. 라디안은 반 시계 방향으로 증가하지만 Y 축은 아래로 향하므로 시계 방향으로 표시됩니다.<br /><br />각도를 변경하여 다른 신체와 충돌을 일으킬 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setAngle( <span class = "arguments">angle</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">angle</td><td class = "ra_type">number</td><td>라디안 단위의 각도입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setAngularDamping" name = "Body:setAngularDamping"><span>Body:</span><wbr>setAngularDamping</a></p><p class = "function_description">Body의 각도 감쇠를 설정합니다.<br /><br />각도 댐핑의 정의에 대해서는 Body : getAngularDamping을 참조하십시오.<br /><br />각도 댐핑은 0에서 무한대까지의 값을 취할 수 있습니다. 0과 0.1 사이에 머무르는 것이 좋습니다. 다른 값은 비현실적입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setAngularDamping( <span class = "arguments">damping</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">damping</td><td class = "ra_type">number</td><td>새로운 각도 댐핑.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setAngularVelocity" name = "Body:setAngularVelocity"><span>Body:</span><wbr>setAngularVelocity</a></p><p class = "function_description">Body의 각속도를 설정합니다.<br /><br />각속도는 시간에 따른 각도 변화의 비율입니다.<br /><br />이 함수는 아무 것도 누적하지 않습니다. World에 대한 마지막 호출 이후 이전에 적용된 모든 충동 : 업데이트가 손실됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setAngularVelocity( <span class = "arguments">w</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">w</td><td class = "ra_type">number</td><td>새로운 각속도 (초당 라디안)</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setAwake" name = "Body:setAwake"><span>Body:</span><wbr>setAwake</a></p><p class = "function_description">시체를 깨우거나 잠자기 상태로 만듭니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setAwake( <span class = "arguments">awake</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">awake</td><td class = "ra_type">boolean</td><td>신체 수면 상태.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setBullet" name = "Body:setBullet"><span>Body:</span><wbr>setBullet</a></p><p class = "function_description">본문의 글 머리 상태를 설정합니다.<br /><br />신체 충돌을 확인하는 방법에는 두 가지가 있습니다.<br /><br />세계가 업데이트 될 때의 위치 (기본값)<br /><br />연속 충돌 감지 (CCD)<br /><br />기본 방법은 효율적이지만, 매우 빠르게 움직이는 몸체는 충돌을 일으키지 않고 다른 몸체로 점프 할 수 있습니다. 총알으로 설정된 신체는 CCD를 사용합니다. 이것은 덜 효율적이지만 신속하게 움직일 때 점프하지 않을 것입니다.<br /><br />정적 물체 (질량이 0 인)는 항상 CCD를 사용하므로 벽이 빨리 움직이는 물체가 총알이 아니더라도 통과시키지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setBullet( <span class = "arguments">status</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">status</td><td class = "ra_type">boolean</td><td>몸의 총알 상태.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setFixedRotation" name = "Body:setFixedRotation"><span>Body:</span><wbr>setFixedRotation</a></p><p class = "function_description">몸체가 고정 된 회전을 가지는지 여부를 설정합니다.<br /><br />고정 된 회전을 갖는 몸체는 회전하는 속도를 변화시키지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setFixedRotation( <span class = "arguments">fixed</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">fixed</td><td class = "ra_type">boolean</td><td>신체가 고정 된 회전을 가져야하는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setGravityScale" name = "Body:setGravityScale"><span>Body:</span><wbr>setGravityScale</a></p><p class = "function_description">몸체에 새로운 중력 스케일 인수를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setGravityScale( <span class = "arguments">scale</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">scale</td><td class = "ra_type">number</td><td>새로운 중력 스케일 계수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setInertia" name = "Body:setInertia"><span>Body:</span><wbr>setInertia</a></p><p class = "function_description">몸체의 관성을 설정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setInertia( <span class = "arguments">inertia</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">inertia</td><td class = "ra_type">number</td><td>새 관성 모멘트 (미터 당 제곱 킬로미터).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setLinearDamping" name = "Body:setLinearDamping"><span>Body:</span><wbr>setLinearDamping</a></p><p class = "function_description">바디의 선형 댐핑을 설정합니다.<br /><br />선형 댐핑의 정의에 대해서는 Body : getLinearDamping을 참조하십시오.<br /><br />선형 댐핑은 0에서 무한대까지의 값을 취할 수 있습니다. 0과 0.1 사이에 머무르는 것이 좋습니다. 다른 값들은 객체들을 "떠 다니는"것처럼 보일 것입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setLinearDamping( <span class = "arguments">ld</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ld</td><td class = "ra_type">number</td><td>새로운 선형 감쇠.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setLinearVelocity" name = "Body:setLinearVelocity"><span>Body:</span><wbr>setLinearVelocity</a></p><p class = "function_description">Body에 대한 새로운 선형 속도를 설정합니다.<br /><br />이 함수는 아무 것도 누적하지 않습니다. World에 대한 마지막 호출 이후 이전에 적용된 모든 충동 : 업데이트가 손실됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setLinearVelocity( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>속도 벡터의 x 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>속도 벡터의 y 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setMass" name = "Body:setMass"><span>Body:</span><wbr>setMass</a></p><p class = "function_description">질량을 킬로그램 단위로 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setMass( <span class = "arguments">mass</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mass</td><td class = "ra_type">number</td><td>질량 (킬로그램).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setMassData" name = "Body:setMassData"><span>Body:</span><wbr>setMassData</a></p><p class = "function_description">계산 된 대량 데이터를 무시합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setMassData( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">mass</span>, <span class = "arguments">inertia</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>로컬 좌표의 질량 중심의 x 성분입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>로컬 좌표의 질량 중심의 y 성분입니다.</td></tr><tr><td class = "arguments ra_name">mass</td><td class = "ra_type">number</td><td>질량 (킬로그램).</td></tr><tr><td class = "arguments ra_name">inertia</td><td class = "ra_type">number</td><td>회전 관성 (킬로그램 / 제곱미터).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setPosition" name = "Body:setPosition"><span>Body:</span><wbr>setPosition</a></p><p class = "function_description">몸체의 위치를 ​​설정하십시오.<br /><br />이것은 신체의 질량 중심이 아닐 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setPosition( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 위치.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 위치입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setSleepingAllowed" name = "Body:setSleepingAllowed"><span>Body:</span><wbr>setSleepingAllowed</a></p><p class = "function_description">바디의 수면 동작을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setSleepingAllowed( <span class = "arguments">allowed</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">allowed</td><td class = "ra_type">boolean</td><td>본문이 휴면 할 수 있으면 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setType" name = "Body:setType"><span>Body:</span><wbr>setType</a></p><p class = "function_description">새로운 본문 유형을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setType( <span class = "arguments">type</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">type</td><td class = "ra_type"><a href="#BodyType">BodyType</a></td><td>새로운 유형.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setUserData" name = "Body:setUserData"><span>Body:</span><wbr>setUserData</a></p><p class = "function_description">Lua 값을 본문과 연관시킵니다.<br /><br />참조를 삭제하려면 명시 적으로 nil을 전달하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setUserData( <span class = "arguments">value</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">value</td><td class = "ra_type">any</td><td>Body와 연결할 Lua 값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setX" name = "Body:setX"><span>Body:</span><wbr>setX</a></p><p class = "function_description">본문의 x 위치를 설정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setX( <span class = "arguments">x</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>x 위치.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Body:setY" name = "Body:setY"><span>Body:</span><wbr>setY</a></p><p class = "function_description">본문의 y 위치를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Body:<wbr>setY( <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>y 위치입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#ChainShape" name = "ChainShape">ChainShape</a></p><p class = "section_description">ChainShape는 여러 선 세그먼트로 구성됩니다. 지형의 경계를 만드는 데 사용할 수 있습니다. 모양에 볼륨이없고 PolygonShape 및 CircleShape에서만 충돌 할 수 있습니다.<br /><br />PolygonShape와 달리 ChainShape에는 꼭지점 제한이 없거나 볼록한 모양을 형성해야하지만 자체 교차점은 지원되지 않습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newChainShape">newChainShape</a>&emsp;새로운 ChainShape를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">ChainShape:<a href="#ChainShape:getChildEdge">getChildEdge</a>&emsp;셰이프의 자식을 EdgeShape로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ChainShape:<a href="#ChainShape:getPoint">getPoint</a>&emsp;도형의 포인트를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ChainShape:<a href="#ChainShape:getPoints">getPoints</a>&emsp;도형의 모든 점을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ChainShape:<a href="#ChainShape:getVertexCount">getVertexCount</a>&emsp;도형에있는 정점 수를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ChainShape:<a href="#ChainShape:getNextVertex">get</a><span class = "slash">/</span><a href="#ChainShape:setNextVertex">setNextVertex</a>&emsp;다음 모양에 대한 연결을 설정하는 정점을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">ChainShape:<a href="#ChainShape:getPreviousVertex">get</a><span class = "slash">/</span><a href="#ChainShape:setPreviousVertex">setPreviousVertex</a>&emsp;이전 도형에 대한 연결을 설정하는 꼭짓점을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shape">Shape</a>&emsp;모양은 love.physics에서 사용 된 단단한 2 차원 기하학적 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:getChildEdge" name = "ChainShape:getChildEdge"><span>ChainShape:</span><wbr>getChildEdge</a></p><p class = "function_description">셰이프의 자식을 EdgeShape로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">EdgeShape</span> = ChainShape:<wbr>getChildEdge( <span class = "arguments">index</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">EdgeShape</td><td class = "ra_type">number</td><td>EdgeShape로서의 아이.</td></tr><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>아이의 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:getNextVertex" name = "ChainShape:getNextVertex"><span>ChainShape:</span><wbr>getNextVertex</a></p><p class = "function_description">다음 도형에 대한 연결을 설정하는 정점을 가져옵니다.<br /><br />다음 및 이전 ChainShape 버텍스를 설정하면 플랫 셰이프가 모서리를 따라 슬라이드하고 새 셰이프 위로 이동하는 경우 원하지 않는 충돌을 방지하는 데 도움이 될 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ChainShape:<wbr>getNextVertex( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x <span class = "default">(nil)</span></td><td class = "ra_type">number</td><td>정점의 x 성분, 또는 ChainShape : setNextVertex가 불려 가지 않은 경우는 nil</td></tr><tr><td class = "arguments ra_name">y <span class = "default">(nil)</span></td><td class = "ra_type">number</td><td>정점의 y 성분, 또는 ChainShape : setNextVertex가 불려 가지 않은 경우는 nil</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:getPoint" name = "ChainShape:getPoint"><span>ChainShape:</span><wbr>getPoint</a></p><p class = "function_description">도형의 포인트를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = ChainShape:<wbr>getPoint( <span class = "arguments">index</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>점의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>점의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">index</td><td class = "ra_type">number</td><td>반환 할 점의 인덱스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:getPoints" name = "ChainShape:getPoints"><span>ChainShape:</span><wbr>getPoints</a></p><p class = "function_description">도형의 모든 점을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x1</span>, <span class = "returns">y1</span>, <span class = "returns">x2</span>, <span class = "returns">y2</span>, <span class = "returns">...</span> = ChainShape:<wbr>getPoints()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 점의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 점의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 점의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 점의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>추가 x 및 y 값.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:getPreviousVertex" name = "ChainShape:getPreviousVertex"><span>ChainShape:</span><wbr>getPreviousVertex</a></p><p class = "function_description">이전 도형과의 연결을 설정하는 정점을 가져옵니다.<br /><br />다음 및 이전 ChainShape 버텍스를 설정하면 플랫 셰이프가 모서리를 따라 슬라이드하고 새 셰이프 위로 이동하는 경우 원하지 않는 충돌을 방지하는 데 도움이 될 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = ChainShape:<wbr>getPreviousVertex()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x <span class = "default">(nil)</span></td><td class = "ra_type">number</td><td>정점의 x 성분, 또는 ChainShape : setNextVertex가 불려 가지 않은 경우는 nil</td></tr><tr><td class = "returns ra_name">y <span class = "default">(nil)</span></td><td class = "ra_type">number</td><td>정점의 y 성분, 또는 ChainShape : setNextVertex가 불려 가지 않은 경우는 nil</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:getVertexCount" name = "ChainShape:getVertexCount"><span>ChainShape:</span><wbr>getVertexCount</a></p><p class = "function_description">도형에있는 정점 수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">count</span> = ChainShape:<wbr>getVertexCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">count</td><td class = "ra_type">number</td><td>정점의 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:setNextVertex" name = "ChainShape:setNextVertex"><span>ChainShape:</span><wbr>setNextVertex</a></p><p class = "function_description">다음 모양에 대한 연결을 설정하는 정점을 설정합니다.<br /><br />이렇게하면 평면 모양이 모서리를 따라 슬라이드하고 새로운 모양으로 넘어갈 때 원하지 않는 충돌을 방지 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ChainShape:<wbr>setNextVertex( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>정점의 x 성분.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>정점의 y 성분입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#ChainShape:setPreviousVertex" name = "ChainShape:setPreviousVertex"><span>ChainShape:</span><wbr>setPreviousVertex</a></p><p class = "function_description">이전 도형에 대한 연결을 설정하는 꼭짓점을 설정합니다.<br /><br />이렇게하면 평면 모양이 모서리를 따라 슬라이드하고 새로운 모양으로 넘어갈 때 원하지 않는 충돌을 방지 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">ChainShape:<wbr>setPreviousVertex( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>정점의 x 성분.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>정점의 y 성분입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#CircleShape" name = "CircleShape">CircleShape</a></p><p class = "section_description">원은 모양을 확장하고 반경과 로컬 위치를 추가합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newCircleShape">newCircleShape</a>&emsp;새로운 CircleShape를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">CircleShape:<a href="#CircleShape:getPoint">get</a><span class = "slash">/</span><a href="#CircleShape:setPoint">setPoint</a>&emsp;원 모양의 중심 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">CircleShape:<a href="#CircleShape:getRadius">get</a><span class = "slash">/</span><a href="#CircleShape:setRadius">setRadius</a>&emsp;원의 반경을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shape">Shape</a>&emsp;모양은 love.physics에서 사용 된 단단한 2 차원 기하학적 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#CircleShape:getPoint" name = "CircleShape:getPoint"><span>CircleShape:</span><wbr>getPoint</a></p><p class = "function_description">원 모양의 중심점을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = CircleShape:<wbr>getPoint()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>원의 중심점의 x- 성분입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>원의 중심점의 y- 성분입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#CircleShape:getRadius" name = "CircleShape:getRadius"><span>CircleShape:</span><wbr>getRadius</a></p><p class = "function_description">원 모양의 반경을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">radius</span> = CircleShape:<wbr>getRadius()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">radius</td><td class = "ra_type">number</td><td>원의 반지름입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#CircleShape:setPoint" name = "CircleShape:setPoint"><span>CircleShape:</span><wbr>setPoint</a></p><p class = "function_description">원 모양의 중심 위치를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">CircleShape:<wbr>setPoint( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>원의 새로운 중심점의 x- 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>원의 새로운 중심점의 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#CircleShape:setRadius" name = "CircleShape:setRadius"><span>CircleShape:</span><wbr>setRadius</a></p><p class = "function_description">원의 반경을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">CircleShape:<wbr>setRadius( <span class = "arguments">radius</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">radius</td><td class = "ra_type">number</td><td>원의 반지름입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Contact" name = "Contact">Contact</a></p><p class = "section_description">연락처는 세계의 충돌을 관리하기 위해 만들어진 개체입니다.</p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:getFixtures">getFixtures</a>&emsp;접촉하는 도형을 보유하고있는 두 개의 Fixture를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:getNormal">getNormal</a>&emsp;접촉하고있는 두 도형 사이의 법선 벡터를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:getPositions">getPositions</a>&emsp;충돌하는 두 조명기의 접촉점을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:isTouching">isTouching</a>&emsp;배달 용 지지품지지 용품이 용품 용의 용품 용센스품 용품 용품 용품 용품 용품 용품 용품 용품 용품 용습비 용 용품 용스터 vol 용 용습품품 용스터 vol 용 용습 용습습 vol = volmed 용품 volmed 용품 volmed 용품 volmed 용품 </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:resetFriction">resetFriction</a>&emsp;접점 마찰을 두 조명기의 혼합 값으로 재설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:resetRestitution">resetRestitution</a>&emsp;접점 비히클을 두 조명기의 혼합 값으로 재설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:isEnabled">is</a><span class = "slash">/</span><a href="#Contact:setEnabled">setEnabled</a>&emsp;연락처를 사용하거나 사용하지 않도록 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:getFriction">get</a><span class = "slash">/</span><a href="#Contact:setFriction">setFriction</a>&emsp;접촉 마찰을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Contact:<a href="#Contact:getRestitution">get</a><span class = "slash">/</span><a href="#Contact:setRestitution">setRestitution</a>&emsp;접촉 반발을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Contact:getFixtures" name = "Contact:getFixtures"><span>Contact:</span><wbr>getFixtures</a></p><p class = "function_description">접촉하는 도형을 보유하고있는 두 개의 Fixture를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fixtureA</span>, <span class = "returns">fixtureB</span> = Contact:<wbr>getFixtures()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fixtureA</td><td class = "ra_type"><a href="#Fixture">Fixture</a></td><td>첫 번째 Fixture.</td></tr><tr><td class = "returns ra_name">fixtureB</td><td class = "ra_type"><a href="#Fixture">Fixture</a></td><td>두번째기구.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:getFriction" name = "Contact:getFriction"><span>Contact:</span><wbr>getFriction</a></p><p class = "function_description">접촉하고있는 두 도형 사이의 마찰을 얻습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">friction</span> = Contact:<wbr>getFriction()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">friction</td><td class = "ra_type">number</td><td>접촉의 마찰.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:getNormal" name = "Contact:getNormal"><span>Contact:</span><wbr>getNormal</a></p><p class = "function_description">접촉하고있는 두 도형 사이의 법선 벡터를 구합니다.<br /><br />이 함수는 첫 번째 모양에서 두 번째 모양을 가리키는 단위 벡터의 좌표를 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">nx</span>, <span class = "returns">ny</span> = Contact:<wbr>getNormal()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">nx</td><td class = "ra_type">number</td><td>법선 벡터의 x 성분입니다.</td></tr><tr><td class = "returns ra_name">ny</td><td class = "ra_type">number</td><td>법선 벡터의 y 성분입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:getPositions" name = "Contact:getPositions"><span>Contact:</span><wbr>getPositions</a></p><p class = "function_description">충돌하는 두 조명기의 접촉점을 가져옵니다. 하나 또는 두 개의 포인트가있을 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x1</span>, <span class = "returns">y1</span>, <span class = "returns">x2</span>, <span class = "returns">y2</span> = Contact:<wbr>getPositions()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x1</td><td class = "ra_type">number</td><td>첫 번째 접점의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y1</td><td class = "ra_type">number</td><td>첫 번째 접점의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 접점의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 접점의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:getRestitution" name = "Contact:getRestitution"><span>Contact:</span><wbr>getRestitution</a></p><p class = "function_description">연락을주고받는 두 가지 모양 사이의 보상을 얻으십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">restitution</span> = Contact:<wbr>getRestitution()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">restitution</td><td class = "ra_type">number</td><td>두 모양 사이의 보상.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:isEnabled" name = "Contact:isEnabled"><span>Contact:</span><wbr>isEnabled</a></p><p class = "function_description">대화 상대의 사용 가능 여부를 가져옵니다. preSolve 콜백에서 연락처가 비활성화 된 경우 콜리 전이 무시됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = Contact:<wbr>isEnabled()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>유효하게되어있는 경우는 true, 그렇지 않은 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:isTouching" name = "Contact:isTouching"><span>Contact:</span><wbr>isTouching</a></p><p class = "function_description">배달 용 지지품지지 용품이 용품 용의 용품 용센스품 용품 용품 용품 용품 용품 용품 용품 용품 용품 용습비 용 용품 용스터 vol 용 용습품품 용스터 vol 용 용습 용습습 vol = volmed 용품 volmed 용품 volmed 용품 volmed 용품</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">touching</span> = Contact:<wbr>isTouching()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">touching</td><td class = "ra_type">boolean</td><td>그들이 만지면 참이거나 그렇지 않다면 거짓이다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:resetFriction" name = "Contact:resetFriction"><span>Contact:</span><wbr>resetFriction</a></p><p class = "function_description">접점 마찰을 두 조명기의 혼합 값으로 재설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Contact:<wbr>resetFriction()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:resetRestitution" name = "Contact:resetRestitution"><span>Contact:</span><wbr>resetRestitution</a></p><p class = "function_description">접점 비히클을 두 조명기의 혼합 값으로 재설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Contact:<wbr>resetRestitution()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:setEnabled" name = "Contact:setEnabled"><span>Contact:</span><wbr>setEnabled</a></p><p class = "function_description">연락처를 사용하거나 사용하지 않도록 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Contact:<wbr>setEnabled( <span class = "arguments">enabled</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enabled</td><td class = "ra_type">boolean</td><td>사용하려면 true, 사용하지 않으려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:setFriction" name = "Contact:setFriction"><span>Contact:</span><wbr>setFriction</a></p><p class = "function_description">접촉 마찰을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Contact:<wbr>setFriction( <span class = "arguments">friction</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">friction</td><td class = "ra_type">number</td><td>접촉 마찰.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Contact:setRestitution" name = "Contact:setRestitution"><span>Contact:</span><wbr>setRestitution</a></p><p class = "function_description">접촉 반발을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Contact:<wbr>setRestitution( <span class = "arguments">restitution</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">restitution</td><td class = "ra_type">number</td><td>접촉 반감.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#EdgeShape" name = "EdgeShape">EdgeShape</a></p><p class = "section_description">EdgeShape는 선 세그먼트입니다. 그것들은 당신의 지형의 경계를 만드는 데 사용될 수 있습니다. 모양에 볼륨이없고 PolygonShape 및 CircleShape에서만 충돌 할 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newEdgeShape">newEdgeShape</a>&emsp;가장자리 모양을 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">EdgeShape:<a href="#EdgeShape:getPoints">getPoints</a>&emsp;모퉁이의 로컬 좌표를 돌려줍니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">EdgeShape:<a href="#EdgeShape:getNextVertex">get</a><span class = "slash">/</span><a href="#EdgeShape:setNextVertex">setNextVertex</a>&emsp;다음 모양에 대한 연결을 설정하는 정점을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">EdgeShape:<a href="#EdgeShape:getPreviousVertex">get</a><span class = "slash">/</span><a href="#EdgeShape:setPreviousVertex">setPreviousVertex</a>&emsp;이전 도형에 대한 연결을 설정하는 꼭짓점을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shape">Shape</a>&emsp;모양은 love.physics에서 사용 된 단단한 2 차원 기하학적 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#EdgeShape:getPoints" name = "EdgeShape:getPoints"><span>EdgeShape:</span><wbr>getPoints</a></p><p class = "function_description">모퉁이의 로컬 좌표를 돌려줍니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x1</span>, <span class = "returns">y1</span>, <span class = "returns">x2</span>, <span class = "returns">y2</span> = EdgeShape:<wbr>getPoints()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x1</td><td class = "ra_type">number</td><td>최초의 정점의 x 성분</td></tr><tr><td class = "returns ra_name">y1</td><td class = "ra_type">number</td><td>최초의 정점의 y 성분</td></tr><tr><td class = "returns ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 꼭짓점의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 꼭지점의 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#EdgeShape:getNextVertex" name = "EdgeShape:getNextVertex"><span>EdgeShape:</span><wbr>getNextVertex</a></p><p class = "function_description">다음 도형에 대한 연결을 설정하는 정점을 가져옵니다.<br /><br />다음 및 이전 EdgeShape 정점을 설정하면 평면 모양이 모서리를 따라 슬라이드하고 새 모양으로 넘어갈 때 원하지 않는 충돌을 방지 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = EdgeShape:<wbr>getNextVertex()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>정점의 x 성분, 또는 EdgeShape : setNextVertex가 불려 가지 않은 경우는 nil</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>정점의 y 성분, 또는 EdgeShape : setNextVertex가 불려 가지 않은 경우는 nil</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#EdgeShape:getPreviousVertex" name = "EdgeShape:getPreviousVertex"><span>EdgeShape:</span><wbr>getPreviousVertex</a></p><p class = "function_description">이전 도형과의 연결을 설정하는 정점을 가져옵니다.<br /><br />다음 및 이전 EdgeShape 정점을 설정하면 평면 모양이 모서리를 따라 슬라이드하고 새 모양으로 넘어갈 때 원하지 않는 충돌을 방지 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = EdgeShape:<wbr>getPreviousVertex()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>정점의 x 성분, 또는 EdgeShape : setPreviousVertex가 불려 가지 않은 경우는 nil</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>정점의 y 성분, 또는 EdgeShape : setPreviousVertex가 불려 가지 않은 경우는 nil</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#EdgeShape:setNextVertex" name = "EdgeShape:setNextVertex"><span>EdgeShape:</span><wbr>setNextVertex</a></p><p class = "function_description">다음 모양에 대한 연결을 설정하는 정점을 설정합니다.<br /><br />이렇게하면 평면 모양이 모서리를 따라 슬라이드하고 새로운 모양으로 넘어갈 때 원하지 않는 충돌을 방지 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">EdgeShape:<wbr>setNextVertex( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>정점의 x 성분.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>정점의 y 성분.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#EdgeShape:setPreviousVertex" name = "EdgeShape:setPreviousVertex"><span>EdgeShape:</span><wbr>setPreviousVertex</a></p><p class = "function_description">이전 도형에 대한 연결을 설정하는 꼭짓점을 설정합니다.<br /><br />이렇게하면 평면 모양이 모서리를 따라 슬라이드하고 새로운 모양으로 넘어갈 때 원하지 않는 충돌을 방지 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">EdgeShape:<wbr>setPreviousVertex( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>정점의 x 성분.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>정점의 y 성분.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#DistanceJoint" name = "DistanceJoint">DistanceJoint</a></p><p class = "section_description">두 시체를 같은 거리에 두십시오.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newDistanceJoint">newDistanceJoint</a>&emsp;두 바디 사이에 거리 조인트를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">DistanceJoint:<a href="#DistanceJoint:getDampingRatio">get</a><span class = "slash">/</span><a href="#DistanceJoint:setDampingRatio">setDampingRatio</a>&emsp;댐핑 비율을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">DistanceJoint:<a href="#DistanceJoint:getFrequency">get</a><span class = "slash">/</span><a href="#DistanceJoint:setFrequency">setFrequency</a>&emsp;응답 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">DistanceJoint:<a href="#DistanceJoint:getLength">get</a><span class = "slash">/</span><a href="#DistanceJoint:setLength">setLength</a>&emsp;두 몸체 사이의 평형 거리를 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#DistanceJoint:getDampingRatio" name = "DistanceJoint:getDampingRatio"><span>DistanceJoint:</span><wbr>getDampingRatio</a></p><p class = "function_description">댐핑 비율을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ratio</span> = DistanceJoint:<wbr>getDampingRatio()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ratio</td><td class = "ra_type">number</td><td>감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#DistanceJoint:getFrequency" name = "DistanceJoint:getFrequency"><span>DistanceJoint:</span><wbr>getFrequency</a></p><p class = "function_description">응답 속도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">Hz</span> = DistanceJoint:<wbr>getFrequency()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">Hz</td><td class = "ra_type">number</td><td>응답 속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#DistanceJoint:getLength" name = "DistanceJoint:getLength"><span>DistanceJoint:</span><wbr>getLength</a></p><p class = "function_description">두 개체 사이의 평형 거리를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">l</span> = DistanceJoint:<wbr>getLength()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">l</td><td class = "ra_type">number</td><td>두 기관 간의 길이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#DistanceJoint:setDampingRatio" name = "DistanceJoint:setDampingRatio"><span>DistanceJoint:</span><wbr>setDampingRatio</a></p><p class = "function_description">댐핑 비율을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">DistanceJoint:<wbr>setDampingRatio( <span class = "arguments">ratio</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ratio</td><td class = "ra_type">number</td><td>감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#DistanceJoint:setFrequency" name = "DistanceJoint:setFrequency"><span>DistanceJoint:</span><wbr>setFrequency</a></p><p class = "function_description">응답 속도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">DistanceJoint:<wbr>setFrequency( <span class = "arguments">Hz</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">Hz</td><td class = "ra_type">number</td><td>응답 속도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#DistanceJoint:setLength" name = "DistanceJoint:setLength"><span>DistanceJoint:</span><wbr>setLength</a></p><p class = "function_description">두 몸체 사이의 평형 거리를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">DistanceJoint:<wbr>setLength( <span class = "arguments">l</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">l</td><td class = "ra_type">number</td><td>두 기관 간의 길이.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Fixture" name = "Fixture">Fixture</a></p><p class = "section_description">치구는 몸체에 도형을 부착합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newFixture">newFixture</a>&emsp;Fixture를 생성하고 본체에 부착합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:destroy">destroy</a>&emsp;정착물 파괴 </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getBody">getBody</a>&emsp;조명기가 부착 된 몸체를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getBoundingBox">getBoundingBox</a>&emsp;조명기 경계 상자의 점을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getMassData">getMassData</a>&emsp;질량, 중심 및 회전 관성을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getShape">getShape</a>&emsp;조명기의 모양을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:isDestroyed">isDestroyed</a>&emsp;조명기가 파괴되었는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:rayCast">rayCast</a>&emsp;조명기 모양에 대해 광선을 투영하고 광선이 부딪 치는 선의 법선 벡터와 선 위치를 반환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getCategory">get</a><span class = "slash">/</span><a href="#Fixture:setCategory">setCategory</a>&emsp;조명기가 속한 카테고리를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getDensity">get</a><span class = "slash">/</span><a href="#Fixture:setDensity">setDensity</a>&emsp;조명기의 밀도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getFilterData">get</a><span class = "slash">/</span><a href="#Fixture:setFilterData">setFilterData</a>&emsp;조명기의 필터 데이터를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getFriction">get</a><span class = "slash">/</span><a href="#Fixture:setFriction">setFriction</a>&emsp;조명기의 마찰을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getGroupIndex">get</a><span class = "slash">/</span><a href="#Fixture:setGroupIndex">setGroupIndex</a>&emsp;조명기가 속한 그룹을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getMask">get</a><span class = "slash">/</span><a href="#Fixture:setMask">setMask</a>&emsp;조명기의 카테고리 마스크를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getRestitution">get</a><span class = "slash">/</span><a href="#Fixture:setRestitution">setRestitution</a>&emsp;조명기의 복원을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:isSensor">is</a><span class = "slash">/</span><a href="#Fixture:setSensor">setSensor</a>&emsp;조명기가 센서로 작동해야하는지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:getUserData">get</a><span class = "slash">/</span><a href="#Fixture:setUserData">setUserData</a>&emsp;Lua 값을 조명기와 연관시킵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Fixture:<a href="#Fixture:testPoint">testPoint</a>&emsp;점이 조명기 모양 안에 있는지 확인합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:destroy" name = "Fixture:destroy"><span>Fixture:</span><wbr>destroy</a></p><p class = "function_description">정착물 파괴</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>destroy()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getBody" name = "Fixture:getBody"><span>Fixture:</span><wbr>getBody</a></p><p class = "function_description">조명기가 부착 된 몸체를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">body</span> = Fixture:<wbr>getBody()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">body</td><td class = "ra_type"><a href="#Body">Body</a></td><td>부모 본문.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getBoundingBox" name = "Fixture:getBoundingBox"><span>Fixture:</span><wbr>getBoundingBox</a></p><p class = "function_description">조명기 경계 상자의 점을 가져옵니다. 조명기에 자식이 여러 개있는 경우 1 기반 인덱스를 지정할 수 있습니다. 예를 들어, 조명기에는 체인 모양의 자식이 여러 개 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">topLeftX</span>, <span class = "returns">topLeftY</span>, <span class = "returns">bottomRightX</span>, <span class = "returns">bottomRightY</span> = Fixture:<wbr>getBoundingBox( <span class = "arguments">index</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">topLeftX</td><td class = "ra_type">number</td><td>좌상 구석의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">topLeftY</td><td class = "ra_type">number</td><td>좌상 구석의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">bottomRightX</td><td class = "ra_type">number</td><td>오른쪽 아래 점의 x 위치입니다.</td></tr><tr><td class = "returns ra_name">bottomRightY</td><td class = "ra_type">number</td><td>오른쪽 아래 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">index <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>조명기의 바운딩 박스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getCategory" name = "Fixture:getCategory"><span>Fixture:</span><wbr>getCategory</a></p><p class = "function_description">조명기가 속한 카테고리를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">category1</span>, <span class = "returns">category2</span>, <span class = "returns">...</span> = Fixture:<wbr>getCategory()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">category1</td><td class = "ra_type">number</td><td>첫 번째 카테고리.</td></tr><tr><td class = "returns ra_name">category2</td><td class = "ra_type">number</td><td>두 번째 범주.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>추가 범주.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getDensity" name = "Fixture:getDensity"><span>Fixture:</span><wbr>getDensity</a></p><p class = "function_description">조명기의 밀도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">density</span> = Fixture:<wbr>getDensity()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">density</td><td class = "ra_type">number</td><td>정착물 밀도는 평방 미터 당 킬로그램입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getFilterData" name = "Fixture:getFilterData"><span>Fixture:</span><wbr>getFilterData</a></p><p class = "function_description">조명기의 필터 데이터를 가져옵니다. 범주 및 마스크는 16 비트 정수의 비트로 인코딩됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">categories</span>, <span class = "returns">mask</span>, <span class = "returns">group</span> = Fixture:<wbr>getFilterData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">categories</td><td class = "ra_type">number</td><td>범주는 0부터 65535 사이의 정수입니다.</td></tr><tr><td class = "returns ra_name">mask</td><td class = "ra_type">number</td><td>마스크는 0부터 65535까지의 정수로 나타냅니다.</td></tr><tr><td class = "returns ra_name">group</td><td class = "ra_type">number</td><td>-32768에서 32767 사이의 정수로 표시된 그룹.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getFriction" name = "Fixture:getFriction"><span>Fixture:</span><wbr>getFriction</a></p><p class = "function_description">조명기의 마찰을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">friction</span> = Fixture:<wbr>getFriction()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">friction</td><td class = "ra_type">number</td><td>고정물 마찰.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getGroupIndex" name = "Fixture:getGroupIndex"><span>Fixture:</span><wbr>getGroupIndex</a></p><p class = "function_description">조명기가 속한 그룹을 가져옵니다. 그룹이 양수이거나 부정적인 경우 충돌하지 않으면 같은 그룹의 조명기가 항상 충돌합니다. 그룹 0은 그룹을 의미하지 않습니다.<br /><br />그룹의 범위는 -32768 ~ 32767입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">group</span> = Fixture:<wbr>getGroupIndex()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">group</td><td class = "ra_type">number</td><td>정착물의 그룹.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getMask" name = "Fixture:getMask"><span>Fixture:</span><wbr>getMask</a></p><p class = "function_description">조명기의 범주 마스크를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">mask1</span>, <span class = "returns">mask2</span>, <span class = "returns">...</span> = Fixture:<wbr>getMask()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">mask1</td><td class = "ra_type">number</td><td>마스크로 선택된 첫 번째 범주입니다.</td></tr><tr><td class = "returns ra_name">mask2</td><td class = "ra_type">number</td><td>마스크로 선택된 두 번째 범주입니다.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>마스크로 선택된 추가 범주입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getMassData" name = "Fixture:getMassData"><span>Fixture:</span><wbr>getMassData</a></p><p class = "function_description">질량, 중심 및 회전 관성을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">mass</span>, <span class = "returns">inertia</span> = Fixture:<wbr>getMassData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>질량 중심의 x 위치입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>질량 중심의 y 위치입니다.</td></tr><tr><td class = "returns ra_name">mass</td><td class = "ra_type">number</td><td>정착물의 질량.</td></tr><tr><td class = "returns ra_name">inertia</td><td class = "ra_type">number</td><td>회전 관성.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getRestitution" name = "Fixture:getRestitution"><span>Fixture:</span><wbr>getRestitution</a></p><p class = "function_description">조명기의 복원을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">restitution</span> = Fixture:<wbr>getRestitution()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">restitution</td><td class = "ra_type">number</td><td>조명기 반발.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getShape" name = "Fixture:getShape"><span>Fixture:</span><wbr>getShape</a></p><p class = "function_description">조명기의 모양을 가져옵니다. 이 모양은 시뮬레이션에 사용 된 실제 데이터에 대한 참조입니다. timestep 사이에서 값을 변경할 수 있습니다.<br /><br />부모 치구가 파손 된 후에는이 모양에 대한 어떤 함수도 호출하지 마십시오. 이 도형은 유효하지 않은 메모리 주소를 가리키며, 더 이상 상호 작용하지 않으면 충돌을 일으킬 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">shape</span> = Fixture:<wbr>getShape()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">shape</td><td class = "ra_type"><a href="#Shape">Shape</a></td><td>정착물의 모양.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:getUserData" name = "Fixture:getUserData"><span>Fixture:</span><wbr>getUserData</a></p><p class = "function_description">이 조명기와 관련된 Lua 값을 가져옵니다.<br /><br />이 함수는 한 스레드에서만 사용하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = Fixture:<wbr>getUserData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">any</td><td>조명기와 관련된 루아 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:isDestroyed" name = "Fixture:isDestroyed"><span>Fixture:</span><wbr>isDestroyed</a></p><p class = "function_description">조명기가 파괴되었는지 여부를 가져옵니다. 파괴 된 조명기는 사용할 수 없습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">destroyed</span> = Fixture:<wbr>isDestroyed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">destroyed</td><td class = "ra_type">boolean</td><td>조명기가 파괴되었는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:isSensor" name = "Fixture:isSensor"><span>Fixture:</span><wbr>isSensor</a></p><p class = "function_description">조명기가 센서인지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">sensor</span> = Fixture:<wbr>isSensor()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">sensor</td><td class = "ra_type">boolean</td><td>조명기가 센서 인 경우.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:rayCast" name = "Fixture:rayCast"><span>Fixture:</span><wbr>rayCast</a></p><p class = "function_description">조명기 모양에 대해 광선을 투영하고 광선이 부딪 치는 선의 법선 벡터와 선 위치를 반환합니다. 광선이 도형을 놓친 경우에는 nil이 반환됩니다.<br /><br />광선은 입력 선의 첫 번째 점에서 시작하여 선의 두 번째 점을 향합니다. 네 번째 인수는 광선이 입력 선 길이의 축척 비율로 이동할 최대 거리입니다.<br /><br />childIndex 매개 변수는 체인 셰이프와 같은 부모 셰이프의 자식이 광선 캐스팅되도록 지정하는 데 사용됩니다. 체인 셰이프의 경우 인덱스 1이 체인의 첫 번째 가장자리입니다. 부모 셰이프를 캐스팅하는 Ray는 지정된 자식 만 테스트 할 것이므로 부모의 모든 셰이프를 테스트하려면 모든 자식을 반복해야합니다.<br /><br />충격의 월드 위치는 선 벡터에 세 번째 반환 값을 곱하여 선 시작점에 추가하여 계산할 수 있습니다.<br /><br />hitx, hity = x1 + (x2 - x1) * 분수, y1 + (y2 - y1) * 분수</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">fraction</span> = Fixture:<wbr>rayCast( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y1</span>, <span class = "arguments">maxFraction</span>, <span class = "arguments">childIndex</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>광선이 도형과 교차하는 x 위치입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>광선이 도형과 교차하는 y 위치입니다.</td></tr><tr><td class = "returns ra_name">fraction</td><td class = "ra_type">number</td><td>교차점이 0에서 1 사이의 숫자로 발생한 입력 벡터의 위치입니다.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>광선 시작점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>광선 시작점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>광선 끝점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>광선 끝점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">maxFraction</td><td class = "ra_type">number</td><td>광선이 이동할 최대 거리입니다 (0에서 1까지의 숫자).</td></tr><tr><td class = "arguments ra_name">childIndex <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>광선이 던져지는 자식의 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setCategory" name = "Fixture:setCategory"><span>Fixture:</span><wbr>setCategory</a></p><p class = "function_description">조명기가 속한 카테고리를 설정합니다. 1에서 16까지의 숫자로 표현되는 최대 16 개의 범주가있을 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setCategory( <span class = "arguments">category1</span>, <span class = "arguments">category2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">category1</td><td class = "ra_type">number</td><td>첫 번째 카테고리.</td></tr><tr><td class = "arguments ra_name">category2</td><td class = "ra_type">number</td><td>두 번째 범주.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 범주.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setDensity" name = "Fixture:setDensity"><span>Fixture:</span><wbr>setDensity</a></p><p class = "function_description">조명기의 밀도를 설정합니다. Body를 호출하면 (자) 즉시 resetMassData를 유효하게 할 필요가있는 경우.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setDensity( <span class = "arguments">density</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">density</td><td class = "ra_type">number</td><td>정착물 밀도는 평방 미터 당 킬로그램입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setFilterData" name = "Fixture:setFilterData"><span>Fixture:</span><wbr>setFilterData</a></p><p class = "function_description">조명기의 필터 데이터를 설정합니다.<br /><br />그룹, 카테고리 및 마스크를 사용하여 조명기의 충돌 동작을 정의 할 수 있습니다.<br /><br />두 개의 조명기가 같은 그룹에 있다면, 그룹이 양수이면 항상 충돌하거나, 음수이면 충돌하지 않습니다. 그룹이 0이거나 일치하지 않으면, 접촉 필터는 조명기가 마스크를 사용하여 다른 조명기의 카테고리를 선택하는지 확인합니다. 조명기가 충돌하지 않습니다. 서로의 범주를 선택하면 사용자 지정 연락처 필터의 반환 값이 사용됩니다. 아무 것도 설정되지 않으면 항상 충돌합니다.<br /><br />최대 16 개의 범주가있을 수 있습니다. 범주 및 마스크는 16 비트 정수의 비트로 인코딩됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setFilterData( <span class = "arguments">categories</span>, <span class = "arguments">mask</span>, <span class = "arguments">group</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">categories</td><td class = "ra_type">number</td><td>범주는 0부터 65535 사이의 정수입니다.</td></tr><tr><td class = "arguments ra_name">mask</td><td class = "ra_type">number</td><td>마스크는 0부터 65535까지의 정수로 나타냅니다.</td></tr><tr><td class = "arguments ra_name">group</td><td class = "ra_type">number</td><td>-32768에서 32767 사이의 정수로 표시된 그룹.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setFriction" name = "Fixture:setFriction"><span>Fixture:</span><wbr>setFriction</a></p><p class = "function_description">조명기의 마찰을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setFriction( <span class = "arguments">friction</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">friction</td><td class = "ra_type">number</td><td>고정물 마찰.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setGroupIndex" name = "Fixture:setGroupIndex"><span>Fixture:</span><wbr>setGroupIndex</a></p><p class = "function_description">조명기가 속한 그룹을 설정합니다. 그룹이 양수이거나 부정적인 경우 충돌하지 않으면 같은 그룹의 조명기가 항상 충돌합니다. 그룹 0은 그룹을 의미하지 않습니다.<br /><br />그룹의 범위는 -32768 ~ 32767입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setGroupIndex( <span class = "arguments">group</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">group</td><td class = "ra_type">number</td><td>-32768에서 32767 사이의 정수로 표시된 그룹.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setMask" name = "Fixture:setMask"><span>Fixture:</span><wbr>setMask</a></p><p class = "function_description">조명기의 카테고리 마스크를 설정합니다. 1에서 16까지의 숫자로 표현되는 최대 16 개의 범주가있을 수 있습니다.<br /><br />이 조명기는 다른 조명기에도이 조명기의 카테고리가 선택된 경우 선택한 카테고리에있는 조명기와 충돌합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setMask( <span class = "arguments">mask1</span>, <span class = "arguments">mask2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">mask1</td><td class = "ra_type">number</td><td>첫 번째 카테고리.</td></tr><tr><td class = "arguments ra_name">mask2</td><td class = "ra_type">number</td><td>두 번째 범주.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">number</td><td>추가 범주.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setRestitution" name = "Fixture:setRestitution"><span>Fixture:</span><wbr>setRestitution</a></p><p class = "function_description">조명기의 복원을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setRestitution( <span class = "arguments">restitution</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">restitution</td><td class = "ra_type">number</td><td>조명기 반발.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setSensor" name = "Fixture:setSensor"><span>Fixture:</span><wbr>setSensor</a></p><p class = "function_description">조명기가 센서로 작동해야하는지 여부를 설정합니다.<br /><br />센서는 충돌 응답을 생성하지 않지만이 조명기에 대한 시작 및 끝 콜백은 여전히 ​​호출됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setSensor( <span class = "arguments">sensor</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">sensor</td><td class = "ra_type">boolean</td><td>센서 상태.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:setUserData" name = "Fixture:setUserData"><span>Fixture:</span><wbr>setUserData</a></p><p class = "function_description">Lua 값을 조명기와 연관시킵니다.<br /><br />이 함수는 한 스레드에서만 사용하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Fixture:<wbr>setUserData( <span class = "arguments">value</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">value</td><td class = "ra_type">any</td><td>조명기와 관련된 루아 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Fixture:testPoint" name = "Fixture:testPoint"><span>Fixture:</span><wbr>testPoint</a></p><p class = "function_description">점이 조명기 모양 안에 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">isInside</span> = Fixture:<wbr>testPoint( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">isInside</td><td class = "ra_type">boolean</td><td>포인트가 안쪽이면 true이고 바깥 쪽이면 false입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>점의 y 위치입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#FrictionJoint" name = "FrictionJoint">FrictionJoint</a></p><p class = "section_description">FrictionJoint는 몸체에 마찰을가합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newFrictionJoint">newFrictionJoint</a>&emsp;두 몸체 사이에 마찰 조인트를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">FrictionJoint:<a href="#FrictionJoint:getMaxForce">get</a><span class = "slash">/</span><a href="#FrictionJoint:setMaxForce">setMaxForce</a>&emsp;최대 마찰력을 뉴턴으로 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">FrictionJoint:<a href="#FrictionJoint:getMaxTorque">get</a><span class = "slash">/</span><a href="#FrictionJoint:setMaxTorque">setMaxTorque</a>&emsp;최대 마찰 토크를 뉴턴 미터 단위로 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#FrictionJoint:getMaxForce" name = "FrictionJoint:getMaxForce"><span>FrictionJoint:</span><wbr>getMaxForce</a></p><p class = "function_description">뉴턴으로 최대 마찰력을 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">force</span> = FrictionJoint:<wbr>getMaxForce()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">force</td><td class = "ra_type">number</td><td>최대 힘 (뉴톤 단위).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#FrictionJoint:getMaxTorque" name = "FrictionJoint:getMaxTorque"><span>FrictionJoint:</span><wbr>getMaxTorque</a></p><p class = "function_description">뉴턴 미터 단위의 최대 마찰 토크를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">torque</span> = FrictionJoint:<wbr>getMaxTorque()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">torque</td><td class = "ra_type">number</td><td>최대 토크 (뉴톤 미터).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#FrictionJoint:setMaxForce" name = "FrictionJoint:setMaxForce"><span>FrictionJoint:</span><wbr>setMaxForce</a></p><p class = "function_description">최대 마찰력을 뉴턴으로 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">FrictionJoint:<wbr>setMaxForce( <span class = "arguments">maxForce</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">maxForce</td><td class = "ra_type">number</td><td>뉴턴에서 최대 힘.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#FrictionJoint:setMaxTorque" name = "FrictionJoint:setMaxTorque"><span>FrictionJoint:</span><wbr>setMaxTorque</a></p><p class = "function_description">최대 마찰 토크를 뉴턴 미터 단위로 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">FrictionJoint:<wbr>setMaxTorque( <span class = "arguments">torque</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">torque</td><td class = "ra_type">number</td><td>최대 토크 (뉴톤 미터).</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#GearJoint" name = "GearJoint">GearJoint</a></p><p class = "section_description">시체를 기어처럼 작동하도록 유지합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newGearJoint">newGearJoint</a>&emsp;두 개의 조인트를 연결하는 기어 조인트를 생성하십시오. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">GearJoint:<a href="#GearJoint:getJoints">getJoints</a>&emsp;이 GearJoint가 연결된 관절을 가져 오십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">GearJoint:<a href="#GearJoint:getRatio">get</a><span class = "slash">/</span><a href="#GearJoint:setRatio">setRatio</a>&emsp;기어 조인트의 비율을 설정하십시오. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#GearJoint:getJoints" name = "GearJoint:getJoints"><span>GearJoint:</span><wbr>getJoints</a></p><p class = "function_description">이 GearJoint가 연결된 관절을 가져 오십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joint1</span>, <span class = "returns">joint2</span> = GearJoint:<wbr>getJoints()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joint1</td><td class = "ra_type"><a href="#Joint">Joint</a></td><td>첫 번째 연결된 조인트입니다.</td></tr><tr><td class = "returns ra_name">joint2</td><td class = "ra_type"><a href="#Joint">Joint</a></td><td>두 번째 연결된 조인트입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#GearJoint:getRatio" name = "GearJoint:getRatio"><span>GearJoint:</span><wbr>getRatio</a></p><p class = "function_description">기어 조인트의 비율을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ratio</span> = GearJoint:<wbr>getRatio()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ratio</td><td class = "ra_type">number</td><td>관절의 비율.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#GearJoint:setRatio" name = "GearJoint:setRatio"><span>GearJoint:</span><wbr>setRatio</a></p><p class = "function_description">기어 조인트의 비율을 설정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">GearJoint:<wbr>setRatio( <span class = "arguments">ratio</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ratio</td><td class = "ra_type">number</td><td>관절의 새로운 비율.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Joint" name = "Joint">Joint</a></p><p class = "section_description">고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오.</p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:destroy">destroy</a>&emsp;명시 적으로 조인트를 파괴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:getAnchors">getAnchors</a>&emsp;조인트의 앵커 포인트를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:getBodies">getBodies</a>&emsp;접합이 연결될 본문을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:getCollideConnected">getCollideConnected</a>&emsp;연결된 Bodies가 충돌하는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:getReactionForce">getReactionForce</a>&emsp;조인트 앵커에서 Body 2의 반력을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:getReactionTorque">getReactionTorque</a>&emsp;두 번째 몸체의 반응 토크를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:getType">getType</a>&emsp;형식을 나타내는 문자열을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:isDestroyed">isDestroyed</a>&emsp;Joint가 소멸되는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Joint:<a href="#Joint:getUserData">get</a><span class = "slash">/</span><a href="#Joint:setUserData">setUserData</a>&emsp;Lua 값을 Joint와 연결합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_subheading">Subtypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#DistanceJoint">DistanceJoint</a>&emsp;두 시체를 같은 거리에 두십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FrictionJoint">FrictionJoint</a>&emsp;FrictionJoint는 몸체에 마찰을가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#GearJoint">GearJoint</a>&emsp;시체를 기어처럼 작동하도록 유지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MotorJoint">MotorJoint</a>&emsp;두 바디 간의 상대 모션을 제어합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MouseJoint">MouseJoint</a>&emsp;마우스로 개체를 제어하는 ​​데 사용됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PrismaticJoint">PrismaticJoint</a>&emsp;Bodies 간의 상대 모션을 하나의 공유 축으로 제한합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PulleyJoint">PulleyJoint</a>&emsp;풀리를 통해 연결된 시체를 시뮬레이션 할 수 있습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RevoluteJoint">RevoluteJoint</a>&emsp;두 개체가 공유 지점을 중심으로 회전하도록 허용합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#RopeJoint">RopeJoint</a>&emsp;RopeJoint는 두 바디에서 두 점 사이의 최대 거리를 적용합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#WeldJoint">WeldJoint</a>&emsp;WeldJoint는 본질적으로 두 개의 몸체를 서로 붙입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#WheelJoint">WheelJoint</a>&emsp;두 번째 본문의 한 점을 첫 번째 본문의 한 행으로 제한합니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Joint:destroy" name = "Joint:destroy"><span>Joint:</span><wbr>destroy</a></p><p class = "function_description">명시 적으로 조인트를 파괴합니다. 가비지 수집을 기다릴 시간이 없으면이 함수를 사용하여 개체를 즉시 해제 할 수 있지만이 함수를 호출 한 후에 개체를 사용하려고하면 오류가 발생합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Joint:<wbr>destroy()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:getAnchors" name = "Joint:getAnchors"><span>Joint:</span><wbr>getAnchors</a></p><p class = "function_description">조인트의 앵커 포인트를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x1</span>, <span class = "returns">y1</span>, <span class = "returns">x2</span>, <span class = "returns">y2</span> = Joint:<wbr>getAnchors()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x1</td><td class = "ra_type">number</td><td>Body 1에있는 앵커의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y1</td><td class = "ra_type">number</td><td>본문 1에있는 앵커의 y 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">x2</td><td class = "ra_type">number</td><td>Body 2에있는 앵커의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y2</td><td class = "ra_type">number</td><td>Body 2에있는 앵커의 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:getBodies" name = "Joint:getBodies"><span>Joint:</span><wbr>getBodies</a></p><p class = "function_description">접합이 연결될 본문을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">bodyA</span>, <span class = "returns">bodyB</span> = Joint:<wbr>getBodies()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">bodyA</td><td class = "ra_type"><a href="#Body">Body</a></td><td>첫 번째 몸.</td></tr><tr><td class = "returns ra_name">bodyB</td><td class = "ra_type"><a href="#Body">Body</a></td><td>두 번째 몸.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:getCollideConnected" name = "Joint:getCollideConnected"><span>Joint:</span><wbr>getCollideConnected</a></p><p class = "function_description">연결된 Bodies가 충돌하는지 여부를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">c</span> = Joint:<wbr>getCollideConnected()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">c</td><td class = "ra_type">boolean</td><td>충돌하는 경우는 true, 그렇지 않은 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:getReactionForce" name = "Joint:getReactionForce"><span>Joint:</span><wbr>getReactionForce</a></p><p class = "function_description">조인트 앵커에서 Body 2의 반력을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = Joint:<wbr>getReactionForce()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>힘의 x 성분.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>힘의 y 성분.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:getReactionTorque" name = "Joint:getReactionTorque"><span>Joint:</span><wbr>getReactionTorque</a></p><p class = "function_description">두 번째 몸체의 반응 토크를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">torque</span> = Joint:<wbr>getReactionTorque( <span class = "arguments">invdt</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">torque</td><td class = "ra_type">number</td><td>두 번째 몸체의 반응 토크.</td></tr><tr><td class = "arguments ra_name">invdt</td><td class = "ra_type">number</td><td>힘이 적용되는 기간. 보통 역 시간 단계 또는 1 / dt.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:getType" name = "Joint:getType"><span>Joint:</span><wbr>getType</a></p><p class = "function_description">형식을 나타내는 문자열을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">type</span> = Joint:<wbr>getType()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">type</td><td class = "ra_type"><a href="#JointType">JointType</a></td><td>접합 유형의 이름이있는 문자열.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:getUserData" name = "Joint:getUserData"><span>Joint:</span><wbr>getUserData</a></p><p class = "function_description">이 조인트와 관련된 루아 값을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = Joint:<wbr>getUserData()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">any</td><td>조인트와 관련된 Lua 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:isDestroyed" name = "Joint:isDestroyed"><span>Joint:</span><wbr>isDestroyed</a></p><p class = "function_description">Joint가 소멸되는지 여부를 가져옵니다. 파괴 된 관절은 사용할 수 없습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">destroyed</span> = Joint:<wbr>isDestroyed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">destroyed</td><td class = "ra_type">boolean</td><td>합동이 파괴되는지.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Joint:setUserData" name = "Joint:setUserData"><span>Joint:</span><wbr>setUserData</a></p><p class = "function_description">Lua 값을 Joint와 연결합니다.<br /><br />참조를 삭제하려면 명시 적으로 nil을 전달하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Joint:<wbr>setUserData( <span class = "arguments">value</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">value</td><td class = "ra_type">any</td><td>Joint와 연결할 Lua 값입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#MotorJoint" name = "MotorJoint">MotorJoint</a></p><p class = "section_description">두 바디 간의 상대 모션을 제어합니다. 위치 오프셋 및 회전 오프셋뿐만 아니라 목표 오프셋에 도달하는 데 적용되는 최대 모터 힘 및 토크도 지정할 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newMotorJoint">newMotorJoint</a>&emsp;두 바디 사이의 상대 모션을 제어하는 ​​두 바디 사이의 조인트를 작성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">MotorJoint:<a href="#MotorJoint:getAngularOffset">get</a><span class = "slash">/</span><a href="#MotorJoint:setAngularOffset">setAngularOffset</a>&emsp;조인트가 부착 된 두 본체 사이의 목표 반사체 간격 띄우기를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">MotorJoint:<a href="#MotorJoint:getLinearOffset">get</a><span class = "slash">/</span><a href="#MotorJoint:setLinearOffset">setLinearOffset</a>&emsp;조인트가 부착 된 두 바디 사이의 목표 선형 오프셋을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#MotorJoint:getAngularOffset" name = "MotorJoint:getAngularOffset"><span>MotorJoint:</span><wbr>getAngularOffset</a></p><p class = "function_description">조인트가 부착 된 두 바디 사이의 목표 각도 오프셋을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">angularoffset</span> = MotorJoint:<wbr>getAngularOffset()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">angularoffset</td><td class = "ra_type">number</td><td>라디안 단위의 목표 각도 오프셋 : 두 번째 몸체 각도에서 첫 번째 몸체 각도를 뺀 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MotorJoint:getLinearOffset" name = "MotorJoint:getLinearOffset"><span>MotorJoint:</span><wbr>getLinearOffset</a></p><p class = "function_description">조인트가 연결된 두 바디 사이의 목표 선형 오프셋을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = MotorJoint:<wbr>getLinearOffset()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>첫 번째 본문을 기준으로 한 대상 선형 오프셋의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>첫 번째 본문을 기준으로 한 대상 선형 오프셋의 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MotorJoint:setAngularOffset" name = "MotorJoint:setAngularOffset"><span>MotorJoint:</span><wbr>setAngularOffset</a></p><p class = "function_description">조인트가 부착 된 두 본체 사이의 목표 반사체 간격 띄우기를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">MotorJoint:<wbr>setAngularOffset( <span class = "arguments">angularoffset</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">angularoffset</td><td class = "ra_type">number</td><td>라디안 단위의 목표 각도 오프셋 : 두 번째 몸체 각도에서 첫 번째 몸체 각도를 뺀 값입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MotorJoint:setLinearOffset" name = "MotorJoint:setLinearOffset"><span>MotorJoint:</span><wbr>setLinearOffset</a></p><p class = "function_description">조인트가 부착 된 두 바디 사이의 목표 선형 오프셋을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">MotorJoint:<wbr>setLinearOffset( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>첫 번째 본문을 기준으로 한 대상 선형 오프셋의 x 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>첫 번째 본문을 기준으로 한 대상 선형 오프셋의 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#MouseJoint" name = "MouseJoint">MouseJoint</a></p><p class = "section_description">마우스로 개체를 제어하는 ​​데 사용됩니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newMouseJoint">newMouseJoint</a>&emsp;몸체와 마우스 사이에 조인트를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">MouseJoint:<a href="#MouseJoint:getDampingRatio">get</a><span class = "slash">/</span><a href="#MouseJoint:setDampingRatio">setDampingRatio</a>&emsp;새로운 댐핑 비율을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">MouseJoint:<a href="#MouseJoint:getFrequency">get</a><span class = "slash">/</span><a href="#MouseJoint:setFrequency">setFrequency</a>&emsp;새로운 빈도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">MouseJoint:<a href="#MouseJoint:getMaxForce">get</a><span class = "slash">/</span><a href="#MouseJoint:setMaxForce">setMaxForce</a>&emsp;인습 투입 용 용습품지지지지 K지지 K지지지지 용품지지지지 용품지지지지 용품지지지지 K지지 K지지 용품지지지지 용품 </p><p class = "section_navigation_link section_navigation_link_minidescription">MouseJoint:<a href="#MouseJoint:getTarget">get</a><span class = "slash">/</span><a href="#MouseJoint:setTarget">setTarget</a>&emsp;목표 지점을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:getDampingRatio" name = "MouseJoint:getDampingRatio"><span>MouseJoint:</span><wbr>getDampingRatio</a></p><p class = "function_description">댐핑 비율을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ratio</span> = MouseJoint:<wbr>getDampingRatio()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ratio</td><td class = "ra_type">number</td><td>새로운 감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:getFrequency" name = "MouseJoint:getFrequency"><span>MouseJoint:</span><wbr>getFrequency</a></p><p class = "function_description">빈도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">freq</span> = MouseJoint:<wbr>getFrequency()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">freq</td><td class = "ra_type">number</td><td>헤르쯔의 주파수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:getMaxForce" name = "MouseJoint:getMaxForce"><span>MouseJoint:</span><wbr>getMaxForce</a></p><p class = "function_description">허용되는 최대 힘을 ​​얻습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">f</span> = MouseJoint:<wbr>getMaxForce()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">f</td><td class = "ra_type">number</td><td>최대 허용 힘.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:getTarget" name = "MouseJoint:getTarget"><span>MouseJoint:</span><wbr>getTarget</a></p><p class = "function_description">타겟 포인트를 취득합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = MouseJoint:<wbr>getTarget()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>대상의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>대상의 x 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:setDampingRatio" name = "MouseJoint:setDampingRatio"><span>MouseJoint:</span><wbr>setDampingRatio</a></p><p class = "function_description">새로운 댐핑 비율을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">MouseJoint:<wbr>setDampingRatio( <span class = "arguments">ratio</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ratio</td><td class = "ra_type">number</td><td>새로운 감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:setFrequency" name = "MouseJoint:setFrequency"><span>MouseJoint:</span><wbr>setFrequency</a></p><p class = "function_description">새로운 빈도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">MouseJoint:<wbr>setFrequency( <span class = "arguments">freq</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">freq</td><td class = "ra_type">number</td><td>헤르쯔의 새로운 주파수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:setMaxForce" name = "MouseJoint:setMaxForce"><span>MouseJoint:</span><wbr>setMaxForce</a></p><p class = "function_description">인습 투입 용 용습품지지지지 K지지 K지지지지 용품지지지지 용품지지지지 용품지지지지 K지지 K지지 용품지지지지 용품</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">MouseJoint:<wbr>setMaxForce( <span class = "arguments">f</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">f</td><td class = "ra_type">number</td><td>최대 허용 힘.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#MouseJoint:setTarget" name = "MouseJoint:setTarget"><span>MouseJoint:</span><wbr>setTarget</a></p><p class = "function_description">목표 지점을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">MouseJoint:<wbr>setTarget( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>대상의 x 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>타겟의 y 컴퍼넌트입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#PolygonShape" name = "PolygonShape">PolygonShape</a></p><p class = "section_description">다각형은 8면까지 볼록한 다각형입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newPolygonShape">newPolygonShape</a>&emsp;새로운 PolygonShape를 작성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newRectangleShape">newRectangleShape</a>&emsp;직사각형 다각형을 만들기위한 속기. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">PolygonShape:<a href="#PolygonShape:getPoints">getPoints</a>&emsp;다각형의 정점의 로컬 좌표를 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Shape">Shape</a>&emsp;모양은 love.physics에서 사용 된 단단한 2 차원 기하학적 객체입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#PolygonShape:getPoints" name = "PolygonShape:getPoints"><span>PolygonShape:</span><wbr>getPoints</a></p><p class = "function_description">다각형의 정점의 로컬 좌표를 가져옵니다.<br /><br />이 함수에는 다양한 수의 반환 값이 있습니다. <a href="#love.graphics.polygon">love.graphics.polygon</a>을 사용하여 중첩 된 방식으로 사용할 수 있습니다.<br /><br />이 함수는 폴리곤의 각 정점에 대해 두 개의 값을 반환하기 때문에 최대 16 개의 반환 값을 가질 수 있습니다. 즉, 최대 8 점의 좌표를 반환 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x1</span>, <span class = "returns">y1</span>, <span class = "returns">x2</span>, <span class = "returns">y2</span>, <span class = "returns">...</span> = PolygonShape:<wbr>getPoints()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x1</td><td class = "ra_type">number</td><td>최초의 정점의 x 성분</td></tr><tr><td class = "returns ra_name">y1</td><td class = "ra_type">number</td><td>최초의 정점의 y 성분</td></tr><tr><td class = "returns ra_name">x2</td><td class = "ra_type">number</td><td>두 번째 꼭짓점의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">y2</td><td class = "ra_type">number</td><td>두 번째 꼭지점의 y 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">number</td><td>추가 x 및 y 값.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#PrismaticJoint" name = "PrismaticJoint">PrismaticJoint</a></p><p class = "section_description">Bodies 간의 상대 모션을 하나의 공유 축으로 제한합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newPrismaticJoint">newPrismaticJoint</a>&emsp;두 몸체 사이에 프리즘 조인트를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getAxis">getAxis</a>&emsp;프리즘 관절의 월드 - 스페이스 축 벡터를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getJointSpeed">getJointSpeed</a>&emsp;현재 관절 각 속도를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getJointTranslation">getJointTranslation</a>&emsp;현재 공동 번역을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getMotorForce">getMotorForce</a>&emsp;현재 모터 힘을 얻으십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getLimits">get</a><span class = "slash">/</span><a href="#PrismaticJoint:setLimits">setLimits</a>&emsp;한계를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:hasLimitsEnabled">has</a><span class = "slash">/</span><a href="#PrismaticJoint:setLimitsEnabled">setLimitsEnabled</a>&emsp;조인트의 한계를 활성화하거나 비활성화합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getLowerLimit">get</a><span class = "slash">/</span><a href="#PrismaticJoint:setLowerLimit">setLowerLimit</a>&emsp;하한을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getMaxMotorForce">get</a><span class = "slash">/</span><a href="#PrismaticJoint:setMaxMotorForce">setMaxMotorForce</a>&emsp;최대 모터 힘을 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:isMotorEnabled">is</a><span class = "slash">/</span><a href="#PrismaticJoint:setMotorEnabled">setMotorEnabled</a>&emsp;조인트 모터를 시작 또는 정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getMotorSpeed">get</a><span class = "slash">/</span><a href="#PrismaticJoint:setMotorSpeed">setMotorSpeed</a>&emsp;모터 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PrismaticJoint:<a href="#PrismaticJoint:getUpperLimit">get</a><span class = "slash">/</span><a href="#PrismaticJoint:setUpperLimit">setUpperLimit</a>&emsp;상한을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getAxis" name = "PrismaticJoint:getAxis"><span>PrismaticJoint:</span><wbr>getAxis</a></p><p class = "function_description">프리즘 관절의 월드 - 스페이스 축 벡터를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = PrismaticJoint:<wbr>getAxis()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>world-space 축 벡터의 x 축 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>월드 - 스페이스 축 벡터의 y 축 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getJointSpeed" name = "PrismaticJoint:getJointSpeed"><span>PrismaticJoint:</span><wbr>getJointSpeed</a></p><p class = "function_description">현재 관절 각 속도를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">s</span> = PrismaticJoint:<wbr>getJointSpeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">s</td><td class = "ra_type">number</td><td>연결 각도 속도 (미터 / 초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getJointTranslation" name = "PrismaticJoint:getJointTranslation"><span>PrismaticJoint:</span><wbr>getJointTranslation</a></p><p class = "function_description">현재 공동 번역을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">t</span> = PrismaticJoint:<wbr>getJointTranslation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">t</td><td class = "ra_type">number</td><td>일반적으로 미터 단위의 합동 번역.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getLimits" name = "PrismaticJoint:getLimits"><span>PrismaticJoint:</span><wbr>getLimits</a></p><p class = "function_description">관절의 경계를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">lower</span>, <span class = "returns">upper</span> = PrismaticJoint:<wbr>getLimits()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">lower</td><td class = "ra_type">number</td><td>하한, 보통 미터 단위.</td></tr><tr><td class = "returns ra_name">upper</td><td class = "ra_type">number</td><td>상한선, 보통 미터 단위.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getLowerLimit" name = "PrismaticJoint:getLowerLimit"><span>PrismaticJoint:</span><wbr>getLowerLimit</a></p><p class = "function_description">하한을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">lower</span> = PrismaticJoint:<wbr>getLowerLimit()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">lower</td><td class = "ra_type">number</td><td>하한, 보통 미터 단위.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getMaxMotorForce" name = "PrismaticJoint:getMaxMotorForce"><span>PrismaticJoint:</span><wbr>getMaxMotorForce</a></p><p class = "function_description">최대 모터 힘을 얻습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">f</span> = PrismaticJoint:<wbr>getMaxMotorForce()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">f</td><td class = "ra_type">number</td><td>최대 모터 힘, 보통 N에서.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getMotorForce" name = "PrismaticJoint:getMotorForce"><span>PrismaticJoint:</span><wbr>getMotorForce</a></p><p class = "function_description">현재 모터 힘을 얻으십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">f</span> = PrismaticJoint:<wbr>getMotorForce()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">f</td><td class = "ra_type">number</td><td>현재 모터 힘, 일반적으로 N.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getMotorSpeed" name = "PrismaticJoint:getMotorSpeed"><span>PrismaticJoint:</span><wbr>getMotorSpeed</a></p><p class = "function_description">모터 속도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">s</span> = PrismaticJoint:<wbr>getMotorSpeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">s</td><td class = "ra_type">number</td><td>모터 속도, 일반적으로 초당 미터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:getUpperLimit" name = "PrismaticJoint:getUpperLimit"><span>PrismaticJoint:</span><wbr>getUpperLimit</a></p><p class = "function_description">상한값을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">upper</span> = PrismaticJoint:<wbr>getUpperLimit()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">upper</td><td class = "ra_type">number</td><td>상한선, 보통 미터 단위.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:hasLimitsEnabled" name = "PrismaticJoint:hasLimitsEnabled"><span>PrismaticJoint:</span><wbr>hasLimitsEnabled</a></p><p class = "function_description">제한이 활성화되어 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = PrismaticJoint:<wbr>hasLimitsEnabled()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>유효하게되어있는 경우는 true, 그렇지 않은 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:isMotorEnabled" name = "PrismaticJoint:isMotorEnabled"><span>PrismaticJoint:</span><wbr>isMotorEnabled</a></p><p class = "function_description">모터가 활성화되어 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = PrismaticJoint:<wbr>isMotorEnabled()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>유효하게되어있는 경우는 true, 무효 인 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:setLimits" name = "PrismaticJoint:setLimits"><span>PrismaticJoint:</span><wbr>setLimits</a></p><p class = "function_description">한계를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PrismaticJoint:<wbr>setLimits( <span class = "arguments">lower</span>, <span class = "arguments">upper</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">lower</td><td class = "ra_type">number</td><td>하한, 보통 미터 단위.</td></tr><tr><td class = "arguments ra_name">upper</td><td class = "ra_type">number</td><td>상한선, 보통 미터 단위.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:setLimitsEnabled" name = "PrismaticJoint:setLimitsEnabled"><span>PrismaticJoint:</span><wbr>setLimitsEnabled</a></p><p class = "function_description">조인트의 한계를 활성화하거나 비활성화합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PrismaticJoint:<wbr>setLimitsEnabled( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>사용하려면 true이고 사용하지 않으려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:setLowerLimit" name = "PrismaticJoint:setLowerLimit"><span>PrismaticJoint:</span><wbr>setLowerLimit</a></p><p class = "function_description">하한을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PrismaticJoint:<wbr>setLowerLimit( <span class = "arguments">lower</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">lower</td><td class = "ra_type">number</td><td>하한, 보통 미터 단위.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:setMaxMotorForce" name = "PrismaticJoint:setMaxMotorForce"><span>PrismaticJoint:</span><wbr>setMaxMotorForce</a></p><p class = "function_description">최대 모터 힘을 설정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PrismaticJoint:<wbr>setMaxMotorForce( <span class = "arguments">f</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">f</td><td class = "ra_type">number</td><td>최대 모터 힘, 보통 N에서.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:setMotorEnabled" name = "PrismaticJoint:setMotorEnabled"><span>PrismaticJoint:</span><wbr>setMotorEnabled</a></p><p class = "function_description">조인트 모터를 시작 또는 정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PrismaticJoint:<wbr>setMotorEnabled( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>사용하려면 true이고 사용하지 않으려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:setMotorSpeed" name = "PrismaticJoint:setMotorSpeed"><span>PrismaticJoint:</span><wbr>setMotorSpeed</a></p><p class = "function_description">모터 속도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PrismaticJoint:<wbr>setMotorSpeed( <span class = "arguments">s</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">s</td><td class = "ra_type">number</td><td>모터 속도, 일반적으로 초당 미터.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PrismaticJoint:setUpperLimit" name = "PrismaticJoint:setUpperLimit"><span>PrismaticJoint:</span><wbr>setUpperLimit</a></p><p class = "function_description">상한을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PrismaticJoint:<wbr>setUpperLimit( <span class = "arguments">upper</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">upper</td><td class = "ra_type">number</td><td>상한선, 보통 미터 단위.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#PulleyJoint" name = "PulleyJoint">PulleyJoint</a></p><p class = "section_description">풀리를 통해 연결된 시체를 시뮬레이션 할 수 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newPulleyJoint">newPulleyJoint</a>&emsp;두 몸체를 서로 결합시키고지면을 연결하는 풀리 조인트를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">PulleyJoint:<a href="#PulleyJoint:getGroundAnchors">getGroundAnchors</a>&emsp;지면 좌표계를 세계 좌표계로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PulleyJoint:<a href="#PulleyJoint:getLengthA">getLengthA</a>&emsp;첫 번째 본문에 연결된 로프 세그먼트의 현재 길이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PulleyJoint:<a href="#PulleyJoint:getLengthB">getLengthB</a>&emsp;두 번째 몸체에 부착 된 로프 세그먼트의 현재 길이를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">PulleyJoint:<a href="#PulleyJoint:getConstant">get</a><span class = "slash">/</span><a href="#PulleyJoint:setConstant">setConstant</a>&emsp;로프의 전체 길이를 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">PulleyJoint:<a href="#PulleyJoint:getMaxLengths">get</a><span class = "slash">/</span><a href="#PulleyJoint:setMaxLengths">setMaxLengths</a>&emsp;로프 세그먼트의 최대 길이를 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">PulleyJoint:<a href="#PulleyJoint:getRatio">get</a><span class = "slash">/</span><a href="#PulleyJoint:setRatio">setRatio</a>&emsp;풀리 비율을 설정하십시오. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:getConstant" name = "PulleyJoint:getConstant"><span>PulleyJoint:</span><wbr>getConstant</a></p><p class = "function_description">로프의 전체 길이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">length</span> = PulleyJoint:<wbr>getConstant()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">length</td><td class = "ra_type">number</td><td>조인트에있는 로프의 길이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:getGroundAnchors" name = "PulleyJoint:getGroundAnchors"><span>PulleyJoint:</span><wbr>getGroundAnchors</a></p><p class = "function_description">지면 좌표계를 세계 좌표계로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">a1x</span>, <span class = "returns">a1y</span>, <span class = "returns">a2x</span>, <span class = "returns">a2y</span> = PulleyJoint:<wbr>getGroundAnchors()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">a1x</td><td class = "ra_type">number</td><td>최초의 엥커의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">a1y</td><td class = "ra_type">number</td><td>최초의 엥커의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">a2x</td><td class = "ra_type">number</td><td>두 번째 앵커의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">a2y</td><td class = "ra_type">number</td><td>두 번째 앵커의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:getLengthA" name = "PulleyJoint:getLengthA"><span>PulleyJoint:</span><wbr>getLengthA</a></p><p class = "function_description">첫 번째 본문에 연결된 로프 세그먼트의 현재 길이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">length</span> = PulleyJoint:<wbr>getLengthA()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">length</td><td class = "ra_type">number</td><td>로프 세그먼트의 길이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:getLengthB" name = "PulleyJoint:getLengthB"><span>PulleyJoint:</span><wbr>getLengthB</a></p><p class = "function_description">두 번째 몸체에 부착 된 로프 세그먼트의 현재 길이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">length</span> = PulleyJoint:<wbr>getLengthB()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">length</td><td class = "ra_type">number</td><td>로프 세그먼트의 길이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:getMaxLengths" name = "PulleyJoint:getMaxLengths"><span>PulleyJoint:</span><wbr>getMaxLengths</a></p><p class = "function_description">로프 세그먼트의 최대 길이를 구하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">len1</span>, <span class = "returns">len2</span> = PulleyJoint:<wbr>getMaxLengths()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">len1</td><td class = "ra_type">number</td><td>첫 번째 로프 세그먼트의 최대 길이.</td></tr><tr><td class = "returns ra_name">len2</td><td class = "ra_type">number</td><td>두 번째 로프 세그먼트의 최대 길이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:getRatio" name = "PulleyJoint:getRatio"><span>PulleyJoint:</span><wbr>getRatio</a></p><p class = "function_description">도르래 비율 가져 오기.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ratio</span> = PulleyJoint:<wbr>getRatio()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ratio</td><td class = "ra_type">number</td><td>조인트의 풀리 비율.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:setConstant" name = "PulleyJoint:setConstant"><span>PulleyJoint:</span><wbr>setConstant</a></p><p class = "function_description">로프의 전체 길이를 설정하십시오.<br /><br />로프의 새 길이를 설정하면 접합부의 최대 길이 값이 업데이트됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PulleyJoint:<wbr>setConstant( <span class = "arguments">length</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">length</td><td class = "ra_type">number</td><td>조인트의 새로운 로프 길이.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:setMaxLengths" name = "PulleyJoint:setMaxLengths"><span>PulleyJoint:</span><wbr>setMaxLengths</a></p><p class = "function_description">로프 세그먼트의 최대 길이를 설정하십시오.<br /><br />물리 모듈은 또한 로프 세그먼트에 최대 값을 부여합니다. 매개 변수가이 값을 초과하면 요청 된 값 대신 최대 값이 설정됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PulleyJoint:<wbr>setMaxLengths( <span class = "arguments">max1</span>, <span class = "arguments">max2</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">max1</td><td class = "ra_type">number</td><td>첫 번째 세그먼트의 새로운 최대 길이입니다.</td></tr><tr><td class = "arguments ra_name">max2</td><td class = "ra_type">number</td><td>두 번째 세그먼트의 새로운 최대 길이입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#PulleyJoint:setRatio" name = "PulleyJoint:setRatio"><span>PulleyJoint:</span><wbr>setRatio</a></p><p class = "function_description">풀리 비율을 설정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">PulleyJoint:<wbr>setRatio( <span class = "arguments">ratio</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ratio</td><td class = "ra_type">number</td><td>조인트의 새로운 풀리 비율.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#RevoluteJoint" name = "RevoluteJoint">RevoluteJoint</a></p><p class = "section_description">두 개체가 공유 지점을 중심으로 회전하도록 허용합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newRevoluteJoint">newRevoluteJoint</a>&emsp;두 바디 사이에 피벗 조인트를 작성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:hasLimitsEnabled">has</a><span class = "slash">/</span><a href="#RevoluteJoint:setLimitsEnabled">setLimitsEnabled</a>&emsp;조인트 제한을 활성화하거나 비활성화합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:isMotorEnabled">is</a><span class = "slash">/</span><a href="#RevoluteJoint:setMotorEnabled">setMotorEnabled</a>&emsp;조인트 모터를 시작 또는 정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getJointAngle">getJointAngle</a>&emsp;현재 관절 각을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getJointSpeed">getJointSpeed</a>&emsp;현재 관절 각 속도를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getMotorTorque">getMotorTorque</a>&emsp;현재 모터 힘을 얻으십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getLimits">get</a><span class = "slash">/</span><a href="#RevoluteJoint:setLimits">setLimits</a>&emsp;한계를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getLowerLimit">get</a><span class = "slash">/</span><a href="#RevoluteJoint:setLowerLimit">setLowerLimit</a>&emsp;하한을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getMaxMotorTorque">get</a><span class = "slash">/</span><a href="#RevoluteJoint:setMaxMotorTorque">setMaxMotorTorque</a>&emsp;최대 모터 힘을 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getMotorSpeed">get</a><span class = "slash">/</span><a href="#RevoluteJoint:setMotorSpeed">setMotorSpeed</a>&emsp;모터 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">RevoluteJoint:<a href="#RevoluteJoint:getUpperLimit">get</a><span class = "slash">/</span><a href="#RevoluteJoint:setUpperLimit">setUpperLimit</a>&emsp;상한을 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:setLimitsEnabled" name = "RevoluteJoint:setLimitsEnabled"><span>RevoluteJoint:</span><wbr>setLimitsEnabled</a></p><p class = "function_description">조인트 제한을 활성화하거나 비활성화합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RevoluteJoint:<wbr>setLimitsEnabled( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>사용하려면 true이고 사용하지 않으려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:setMotorEnabled" name = "RevoluteJoint:setMotorEnabled"><span>RevoluteJoint:</span><wbr>setMotorEnabled</a></p><p class = "function_description">조인트 모터를 시작 또는 정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RevoluteJoint:<wbr>setMotorEnabled( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>사용하려면 true이고 사용하지 않으려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getJointAngle" name = "RevoluteJoint:getJointAngle"><span>RevoluteJoint:</span><wbr>getJointAngle</a></p><p class = "function_description">현재 관절 각을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">angle</span> = RevoluteJoint:<wbr>getJointAngle()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">angle</td><td class = "ra_type">number</td><td>관절 각 (라디안)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getJointSpeed" name = "RevoluteJoint:getJointSpeed"><span>RevoluteJoint:</span><wbr>getJointSpeed</a></p><p class = "function_description">현재 관절 각 속도를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">s</span> = RevoluteJoint:<wbr>getJointSpeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">s</td><td class = "ra_type">number</td><td>연결 각도 속도 (라디안 / 초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getLimits" name = "RevoluteJoint:getLimits"><span>RevoluteJoint:</span><wbr>getLimits</a></p><p class = "function_description">관절의 경계를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">lower</span>, <span class = "returns">upper</span> = RevoluteJoint:<wbr>getLimits()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">lower</td><td class = "ra_type">number</td><td>하한 (라디안).</td></tr><tr><td class = "returns ra_name">upper</td><td class = "ra_type">number</td><td>상한선 (라디안).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getLowerLimit" name = "RevoluteJoint:getLowerLimit"><span>RevoluteJoint:</span><wbr>getLowerLimit</a></p><p class = "function_description">하한을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">lower</span> = RevoluteJoint:<wbr>getLowerLimit()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">lower</td><td class = "ra_type">number</td><td>하한 (라디안).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getMaxMotorTorque" name = "RevoluteJoint:getMaxMotorTorque"><span>RevoluteJoint:</span><wbr>getMaxMotorTorque</a></p><p class = "function_description">최대 모터 힘을 얻습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">f</span> = RevoluteJoint:<wbr>getMaxMotorTorque()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">f</td><td class = "ra_type">number</td><td>최대 모터 힘 (Nm).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getMotorSpeed" name = "RevoluteJoint:getMotorSpeed"><span>RevoluteJoint:</span><wbr>getMotorSpeed</a></p><p class = "function_description">모터 속도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">s</span> = RevoluteJoint:<wbr>getMotorSpeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">s</td><td class = "ra_type">number</td><td>모터 속도, 초당 라디안.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getMotorTorque" name = "RevoluteJoint:getMotorTorque"><span>RevoluteJoint:</span><wbr>getMotorTorque</a></p><p class = "function_description">현재 모터 힘을 얻으십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">f</span> = RevoluteJoint:<wbr>getMotorTorque()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">f</td><td class = "ra_type">number</td><td>현재 모터 힘, Nm.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:getUpperLimit" name = "RevoluteJoint:getUpperLimit"><span>RevoluteJoint:</span><wbr>getUpperLimit</a></p><p class = "function_description">상한값을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">upper</span> = RevoluteJoint:<wbr>getUpperLimit()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">upper</td><td class = "ra_type">number</td><td>상한선 (라디안).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:hasLimitsEnabled" name = "RevoluteJoint:hasLimitsEnabled"><span>RevoluteJoint:</span><wbr>hasLimitsEnabled</a></p><p class = "function_description">한계가 활성화되어 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = RevoluteJoint:<wbr>hasLimitsEnabled()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>유효하게되어있는 경우는 true, 그렇지 않은 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:isMotorEnabled" name = "RevoluteJoint:isMotorEnabled"><span>RevoluteJoint:</span><wbr>isMotorEnabled</a></p><p class = "function_description">모터가 활성화되어 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = RevoluteJoint:<wbr>isMotorEnabled()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>유효하게되어있는 경우는 true, 무효 인 경우는 false</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:setLimits" name = "RevoluteJoint:setLimits"><span>RevoluteJoint:</span><wbr>setLimits</a></p><p class = "function_description">한계를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RevoluteJoint:<wbr>setLimits( <span class = "arguments">lower</span>, <span class = "arguments">upper</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">lower</td><td class = "ra_type">number</td><td>하한 (라디안).</td></tr><tr><td class = "arguments ra_name">upper</td><td class = "ra_type">number</td><td>상한선 (라디안).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:setLowerLimit" name = "RevoluteJoint:setLowerLimit"><span>RevoluteJoint:</span><wbr>setLowerLimit</a></p><p class = "function_description">하한을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RevoluteJoint:<wbr>setLowerLimit( <span class = "arguments">lower</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">lower</td><td class = "ra_type">number</td><td>하한 (라디안).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:setMaxMotorTorque" name = "RevoluteJoint:setMaxMotorTorque"><span>RevoluteJoint:</span><wbr>setMaxMotorTorque</a></p><p class = "function_description">최대 모터 힘을 설정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RevoluteJoint:<wbr>setMaxMotorTorque( <span class = "arguments">f</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">f</td><td class = "ra_type">number</td><td>최대 모터 힘 (Nm).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:setMotorSpeed" name = "RevoluteJoint:setMotorSpeed"><span>RevoluteJoint:</span><wbr>setMotorSpeed</a></p><p class = "function_description">모터 속도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RevoluteJoint:<wbr>setMotorSpeed( <span class = "arguments">s</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">s</td><td class = "ra_type">number</td><td>모터 속도, 초당 라디안.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#RevoluteJoint:setUpperLimit" name = "RevoluteJoint:setUpperLimit"><span>RevoluteJoint:</span><wbr>setUpperLimit</a></p><p class = "function_description">상한을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">RevoluteJoint:<wbr>setUpperLimit( <span class = "arguments">upper</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">upper</td><td class = "ra_type">number</td><td>상한선 (라디안).</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#RopeJoint" name = "RopeJoint">RopeJoint</a></p><p class = "section_description">RopeJoint는 두 바디에서 두 점 사이의 최대 거리를 적용합니다. 다른 효과는 없습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newRopeJoint">newRopeJoint</a>&emsp;두 몸체 사이에 조인트를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">RopeJoint:<a href="#RopeJoint:getMaxLength">getMaxLength</a>&emsp;RopeJoint의 최대 길이를 가져옵니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#RopeJoint:getMaxLength" name = "RopeJoint:getMaxLength"><span>RopeJoint:</span><wbr>getMaxLength</a></p><p class = "function_description">RopeJoint의 최대 길이를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">maxLength</span> = RopeJoint:<wbr>getMaxLength()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">maxLength</td><td class = "ra_type">number</td><td>RopeJoint의 최대 길이입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Shape" name = "Shape">Shape</a></p><p class = "section_description">모양은 love.physics에서 사용 된 단단한 2 차원 기하학적 객체입니다.<br /><br />셰이프는 조명기를 통해 몸체에 부착됩니다. 이 경우 Shape 객체가 복사됩니다. 모양 위치는 본체 위치를 기준으로합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newChainShape">newChainShape</a>&emsp;새로운 ChainShape를 만듭니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newEdgeShape">newEdgeShape</a>&emsp;가장자리 모양을 만듭니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newPolygonShape">newPolygonShape</a>&emsp;새로운 PolygonShape를 작성합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newRectangleShape">newRectangleShape</a>&emsp;직사각형 다각형을 만들기위한 속기. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Shape:<a href="#Shape:computeAABB">computeAABB</a>&emsp;변형 된 모양에 대한 경계 상자의 점을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shape:<a href="#Shape:computeMass">computeMass</a>&emsp;지정된 밀도로 모양의 질량 특성을 계산합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shape:<a href="#Shape:getChildCount">getChildCount</a>&emsp;셰이프에있는 자식 수를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shape:<a href="#Shape:getRadius">getRadius</a>&emsp;도형의 반지름을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shape:<a href="#Shape:getType">getType</a>&emsp;Shape를 나타내는 캐릭터 라인을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shape:<a href="#Shape:rayCast">rayCast</a>&emsp;모양에 대해 광선을 투영하고 광선이 닿는 선의 법선 벡터와 선 위치를 반환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Shape:<a href="#Shape:testPoint">testPoint</a>&emsp;점이 도형 안에 있는지 확인합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_subheading">Subtypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#ChainShape">ChainShape</a>&emsp;ChainShape는 여러 선 세그먼트로 구성됩니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#CircleShape">CircleShape</a>&emsp;원은 모양을 확장하고 반경과 로컬 위치를 추가합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#EdgeShape">EdgeShape</a>&emsp;EdgeShape는 선 세그먼트입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PolygonShape">PolygonShape</a>&emsp;다각형은 8면까지 볼록한 다각형입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Shape:computeAABB" name = "Shape:computeAABB"><span>Shape:</span><wbr>computeAABB</a></p><p class = "function_description">변형 된 모양에 대한 경계 상자의 점을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">topLeftX</span>, <span class = "returns">topLeftY</span>, <span class = "returns">bottomRightX</span>, <span class = "returns">bottomRightY</span> = Shape:<wbr>computeAABB( <span class = "arguments">tx</span>, <span class = "arguments">ty</span>, <span class = "arguments">tr</span>, <span class = "arguments">childIndex</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">topLeftX</td><td class = "ra_type">number</td><td>좌상 구석의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">topLeftY</td><td class = "ra_type">number</td><td>좌상 구석의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">bottomRightX</td><td class = "ra_type">number</td><td>오른쪽 아래 점의 x 위치입니다.</td></tr><tr><td class = "returns ra_name">bottomRightY</td><td class = "ra_type">number</td><td>오른쪽 아래 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">tx</td><td class = "ra_type">number</td><td>x 축상의 도형의 변환.</td></tr><tr><td class = "arguments ra_name">ty</td><td class = "ra_type">number</td><td>y 축상의 형상의 평행 이동입니다.</td></tr><tr><td class = "arguments ra_name">tr</td><td class = "ra_type">number</td><td>모양 회전.</td></tr><tr><td class = "arguments ra_name">childIndex <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>경계 상자를 계산할 자식 인덱스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shape:computeMass" name = "Shape:computeMass"><span>Shape:</span><wbr>computeMass</a></p><p class = "function_description">지정된 밀도로 모양의 질량 특성을 계산합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">mass</span>, <span class = "returns">inertia</span> = Shape:<wbr>computeMass( <span class = "arguments">density</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>질량 중심의 x postition.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>질량 중심의 후퇴.</td></tr><tr><td class = "returns ra_name">mass</td><td class = "ra_type">number</td><td>모양의 질량.</td></tr><tr><td class = "returns ra_name">inertia</td><td class = "ra_type">number</td><td>회전 관성.</td></tr><tr><td class = "arguments ra_name">density</td><td class = "ra_type">number</td><td>형상 밀도.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shape:getChildCount" name = "Shape:getChildCount"><span>Shape:</span><wbr>getChildCount</a></p><p class = "function_description">셰이프에있는 자식 수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">count</span> = Shape:<wbr>getChildCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">count</td><td class = "ra_type">number</td><td>아이들의 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shape:getRadius" name = "Shape:getRadius"><span>Shape:</span><wbr>getRadius</a></p><p class = "function_description">도형의 반지름을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">radius</span> = Shape:<wbr>getRadius()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">radius</td><td class = "ra_type">number</td><td>도형의 반지름입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shape:getType" name = "Shape:getType"><span>Shape:</span><wbr>getType</a></p><p class = "function_description">Shape를 나타내는 캐릭터 라인을 가져옵니다. 이 함수는 조건부 디버그 그리기에 유용 할 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">type</span> = Shape:<wbr>getType()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">type</td><td class = "ra_type"><a href="#ShapeType">ShapeType</a></td><td>Shape의 형태.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shape:rayCast" name = "Shape:rayCast"><span>Shape:</span><wbr>rayCast</a></p><p class = "function_description">모양에 대해 광선을 투영하고 광선이 닿는 선의 법선 벡터와 선 위치를 반환합니다. 광선이 도형을 놓친 경우에는 nil이 반환됩니다. Shape는 원하는 위치로 이동하도록 변형 될 수 있습니다.<br /><br />광선은 입력 선의 첫 번째 점에서 시작하여 선의 두 번째 점을 향합니다. 네 번째 인수는 광선이 입력 선 길이의 축척 비율로 이동할 최대 거리입니다.<br /><br />childIndex 매개 변수는 체인 셰이프와 같은 부모 셰이프의 자식이 광선 캐스팅되도록 지정하는 데 사용됩니다. 체인 셰이프의 경우 인덱스 1이 체인의 첫 번째 가장자리입니다. 부모 셰이프를 캐스팅하는 Ray는 지정된 자식 만 테스트 할 것이므로 부모의 모든 셰이프를 테스트하려면 모든 자식을 반복해야합니다.<br /><br />충격의 월드 위치는 선 벡터에 세 번째 반환 값을 곱하여 선 시작점에 추가하여 계산할 수 있습니다.<br /><br />hitx, hity = x1 + (x2 - x1) * 분수, y1 + (y2 - y1) * 분수</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">xn</span>, <span class = "returns">yn</span>, <span class = "returns">fraction</span> = Shape:<wbr>rayCast( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">maxFraction</span>, <span class = "arguments">tx</span>, <span class = "arguments">ty</span>, <span class = "arguments">tr</span>, <span class = "arguments">childIndex</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">xn</td><td class = "ra_type">number</td><td>광선이 모양에 부딪히는 가장자리의 법선 벡터의 x 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">yn</td><td class = "ra_type">number</td><td>광선이 모양에 부딪히는 가장자리의 법선 벡터의 y 구성 요소입니다.</td></tr><tr><td class = "returns ra_name">fraction</td><td class = "ra_type">number</td><td>교차점이 선 길이의 요소로 발생한 입력 선의 위치입니다.</td></tr><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>입력 행의 시작점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>입력 행의 시점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>입력 행 끝점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>입력 행 종점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">maxFraction</td><td class = "ra_type">number</td><td>광선 길이 매개 변수.</td></tr><tr><td class = "arguments ra_name">tx</td><td class = "ra_type">number</td><td>x 축상의 도형의 변환.</td></tr><tr><td class = "arguments ra_name">ty</td><td class = "ra_type">number</td><td>y 축상의 형상의 평행 이동입니다.</td></tr><tr><td class = "arguments ra_name">tr</td><td class = "ra_type">number</td><td>모양 회전.</td></tr><tr><td class = "arguments ra_name">childIndex <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>광선이 던져지는 자식의 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Shape:testPoint" name = "Shape:testPoint"><span>Shape:</span><wbr>testPoint</a></p><p class = "function_description">점이 도형 안에 있는지 확인합니다. 이것은 마우스가 도형과 상호 작용할 때 특히 유용합니다. 모든 모양을 반복하고이 함수로 마우스 위치를 테스트하면 마우스가 어떤 모양을 만지는 지 찾을 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">hit</span> = Shape:<wbr>testPoint( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">hit</td><td class = "ra_type">boolean</td><td>내부이면 true, 외부이면 false</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>점의 x 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>점의 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#WeldJoint" name = "WeldJoint">WeldJoint</a></p><p class = "section_description">WeldJoint는 본질적으로 두 개의 몸체를 서로 붙입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newWeldJoint">newWeldJoint</a>&emsp;두 바디 사이에 구속 조건 조인트를 작성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">WeldJoint:<a href="#WeldJoint:getDampingRatio">get</a><span class = "slash">/</span><a href="#WeldJoint:setDampingRatio">setDampingRatio</a>&emsp;새로운 감쇠비. </p><p class = "section_navigation_link section_navigation_link_minidescription">WeldJoint:<a href="#WeldJoint:getFrequency">get</a><span class = "slash">/</span><a href="#WeldJoint:setFrequency">setFrequency</a>&emsp;새로운 빈도를 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#WeldJoint:getDampingRatio" name = "WeldJoint:getDampingRatio"><span>WeldJoint:</span><wbr>getDampingRatio</a></p><p class = "function_description">접합부의 감쇠비를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ratio</span> = WeldJoint:<wbr>getDampingRatio()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ratio</td><td class = "ra_type">number</td><td>감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WeldJoint:getFrequency" name = "WeldJoint:getFrequency"><span>WeldJoint:</span><wbr>getFrequency</a></p><p class = "function_description">빈도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">freq</span> = WeldJoint:<wbr>getFrequency()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">freq</td><td class = "ra_type">number</td><td>헤르쯔의 주파수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WeldJoint:setDampingRatio" name = "WeldJoint:setDampingRatio"><span>WeldJoint:</span><wbr>setDampingRatio</a></p><p class = "function_description">새로운 감쇠비.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">WeldJoint:<wbr>setDampingRatio( <span class = "arguments">ratio</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ratio</td><td class = "ra_type">number</td><td>새로운 감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WeldJoint:setFrequency" name = "WeldJoint:setFrequency"><span>WeldJoint:</span><wbr>setFrequency</a></p><p class = "function_description">새로운 빈도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">WeldJoint:<wbr>setFrequency( <span class = "arguments">freq</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">freq</td><td class = "ra_type">number</td><td>헤르쯔의 새로운 주파수.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#WheelJoint" name = "WheelJoint">WheelJoint</a></p><p class = "section_description">두 번째 본문의 한 점을 첫 번째 본문의 한 행으로 제한합니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newWheelJoint">newWheelJoint</a>&emsp;휠 조인트를 만듭니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getAxis">getAxis</a>&emsp;Wheel Joint의 월드 - 스페이스 축 벡터를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getJointSpeed">getJointSpeed</a>&emsp;현재 공동 번역 속도를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getJointTranslation">getJointTranslation</a>&emsp;현재 공동 번역을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getMotorTorque">getMotorTorque</a>&emsp;모터의 현재 토크를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getMaxMotorTorque">get</a><span class = "slash">/</span><a href="#WheelJoint:setMaxMotorTorque">setMaxMotorTorque</a>&emsp;새로운 최대 모터 토크를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:setMotorEnabled">setMotorEnabled</a>&emsp;조인트 모터를 시작 및 정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getMotorSpeed">get</a><span class = "slash">/</span><a href="#WheelJoint:setMotorSpeed">setMotorSpeed</a>&emsp;모터의 새로운 속도를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getSpringDampingRatio">get</a><span class = "slash">/</span><a href="#WheelJoint:setSpringDampingRatio">setSpringDampingRatio</a>&emsp;새로운 댐핑 비율을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">WheelJoint:<a href="#WheelJoint:getSpringFrequency">get</a><span class = "slash">/</span><a href="#WheelJoint:setSpringFrequency">setSpringFrequency</a>&emsp;새 스프링 빈도를 설정합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Joint">Joint</a>&emsp;고유 한 방식으로 상호 작용할 수 있도록 여러 본문을 연결하십시오. </p></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getAxis" name = "WheelJoint:getAxis"><span>WheelJoint:</span><wbr>getAxis</a></p><p class = "function_description">Wheel <a href="#Joint">Joint</a>의 월드 - 스페이스 축 벡터를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = WheelJoint:<wbr>getAxis()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>world-space 축 벡터의 x 축 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>월드 - 스페이스 축 벡터의 y 축 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getJointSpeed" name = "WheelJoint:getJointSpeed"><span>WheelJoint:</span><wbr>getJointSpeed</a></p><p class = "function_description">현재 공동 번역 속도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">speed</span> = WheelJoint:<wbr>getJointSpeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">speed</td><td class = "ra_type">number</td><td>조인트의 변환 속도 (초당 미터).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getJointTranslation" name = "WheelJoint:getJointTranslation"><span>WheelJoint:</span><wbr>getJointTranslation</a></p><p class = "function_description">현재 공동 번역을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">position</span> = WheelJoint:<wbr>getJointTranslation()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">position</td><td class = "ra_type">number</td><td>관절을 미터 단위로 번역 한 것입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getMaxMotorTorque" name = "WheelJoint:getMaxMotorTorque"><span>WheelJoint:</span><wbr>getMaxMotorTorque</a></p><p class = "function_description">최대 모터 토크를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">maxTorque</span> = WheelJoint:<wbr>getMaxMotorTorque()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">maxTorque</td><td class = "ra_type">number</td><td>조인트 모터의 최대 토크 (단위 : 뉴톤).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getMotorSpeed" name = "WheelJoint:getMotorSpeed"><span>WheelJoint:</span><wbr>getMotorSpeed</a></p><p class = "function_description">모터의 속도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">speed</span> = WheelJoint:<wbr>getMotorSpeed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">speed</td><td class = "ra_type">number</td><td>조인트 모터의 속도는 초당 라디안 단위입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getMotorTorque" name = "WheelJoint:getMotorTorque"><span>WheelJoint:</span><wbr>getMotorTorque</a></p><p class = "function_description">모터의 현재 토크를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">torque</span> = WheelJoint:<wbr>getMotorTorque( <span class = "arguments">invdt</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">torque</td><td class = "ra_type">number</td><td>모터의 토크 (단위 : 뉴톤).</td></tr><tr><td class = "arguments ra_name">invdt</td><td class = "ra_type">number</td><td>힘이 적용되는 기간. 보통 역 시간 단계 또는 1 / dt.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getSpringDampingRatio" name = "WheelJoint:getSpringDampingRatio"><span>WheelJoint:</span><wbr>getSpringDampingRatio</a></p><p class = "function_description">댐핑 비율을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ratio</span> = WheelJoint:<wbr>getSpringDampingRatio()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ratio</td><td class = "ra_type">number</td><td>감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:getSpringFrequency" name = "WheelJoint:getSpringFrequency"><span>WheelJoint:</span><wbr>getSpringFrequency</a></p><p class = "function_description">스프링 빈도를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">freq</span> = WheelJoint:<wbr>getSpringFrequency()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">freq</td><td class = "ra_type">number</td><td>헤르쯔의 주파수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:setMaxMotorTorque" name = "WheelJoint:setMaxMotorTorque"><span>WheelJoint:</span><wbr>setMaxMotorTorque</a></p><p class = "function_description">새로운 최대 모터 토크를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">WheelJoint:<wbr>setMaxMotorTorque( <span class = "arguments">maxTorque</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">maxTorque</td><td class = "ra_type">number</td><td>조인트 모터의 새로운 최대 토크 (단위 : 뉴턴).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:setMotorEnabled" name = "WheelJoint:setMotorEnabled"><span>WheelJoint:</span><wbr>setMotorEnabled</a></p><p class = "function_description">조인트 모터를 시작 및 정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">WheelJoint:<wbr>setMotorEnabled( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>True는 모터를 켜고 false는 모터를 끕니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:setMotorSpeed" name = "WheelJoint:setMotorSpeed"><span>WheelJoint:</span><wbr>setMotorSpeed</a></p><p class = "function_description">모터의 새로운 속도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">WheelJoint:<wbr>setMotorSpeed( <span class = "arguments">speed</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">speed</td><td class = "ra_type">number</td><td>조인트 모터의 새 속도 (라디안 / 초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:setSpringDampingRatio" name = "WheelJoint:setSpringDampingRatio"><span>WheelJoint:</span><wbr>setSpringDampingRatio</a></p><p class = "function_description">새로운 댐핑 비율을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">WheelJoint:<wbr>setSpringDampingRatio( <span class = "arguments">ratio</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">ratio</td><td class = "ra_type">number</td><td>새로운 감쇠비.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#WheelJoint:setSpringFrequency" name = "WheelJoint:setSpringFrequency"><span>WheelJoint:</span><wbr>setSpringFrequency</a></p><p class = "function_description">새 스프링 빈도를 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">WheelJoint:<wbr>setSpringFrequency( <span class = "arguments">freq</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">freq</td><td class = "ra_type">number</td><td>헤르쯔의 새로운 주파수.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#World" name = "World">World</a></p><p class = "section_description">세상은 모든 몸과 관절을 포함하는 대상입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.physics.<a href="#love.physics.newWorld">newWorld</a>&emsp;새로운 세계를 창조합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:destroy">destroy</a>&emsp;모든 시체, 관절, 비품 및 모양을 함께 가져 와서 세상을 파괴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getBodyCount">getBodyCount</a>&emsp;세계의 시체 수를 구하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getBodyList">getBodyList</a>&emsp;모든 본문이있는 테이블을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getContactCount">getContactCount</a>&emsp;세계의 연락처 수를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getContactList">getContactList</a>&emsp;모든 연락처가있는 테이블을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getJointCount">getJointCount</a>&emsp;세계의 관절 수를 구하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getJointList">getJointList</a>&emsp;모든 관절이있는 테이블을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:isDestroyed">isDestroyed</a>&emsp;세계가 파괴되었는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:isLocked">isLocked</a>&emsp;세계가 상태를 갱신하고 있을지 어떨지를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:queryBoundingBox">queryBoundingBox</a>&emsp;지정된 영역 안의 각 조명기에 대한 함수를 호출합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:rayCast">rayCast</a>&emsp;광선을 전달하고 교차하는 각 조명기에 대해 함수를 호출합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getCallbacks">get</a><span class = "slash">/</span><a href="#World:setCallbacks">setCallbacks</a>&emsp;월드 업데이트 중에 콜리 전 콜백 함수를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getContactFilter">get</a><span class = "slash">/</span><a href="#World:setContactFilter">setContactFilter</a>&emsp;충돌 필터링을위한 함수를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:getGravity">get</a><span class = "slash">/</span><a href="#World:setGravity">setGravity</a>&emsp;세계의 중력을 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:isSleepingAllowed">is</a><span class = "slash">/</span><a href="#World:setSleepingAllowed">setSleepingAllowed</a>&emsp;세계의 수면 행동을 설정하십시오. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:translateOrigin">translateOrigin</a>&emsp;세계의 기원을 번역합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">World:<a href="#World:update">update</a>&emsp;세계의 상태를 업데이트하십시오. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#World:destroy" name = "World:destroy"><span>World:</span><wbr>destroy</a></p><p class = "function_description">모든 시체, 관절, 비품 및 모양을 함께 가져 와서 세상을 파괴합니다.<br /><br />이 함수를 호출 한 후 소멸 된 객체를 사용하려고하면 오류가 발생합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>destroy()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getBodyCount" name = "World:getBodyCount"><span>World:</span><wbr>getBodyCount</a></p><p class = "function_description">세계의 시체 수를 구하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">n</span> = World:<wbr>getBodyCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">n</td><td class = "ra_type">number</td><td>세계의 시체 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getBodyList" name = "World:getBodyList"><span>World:</span><wbr>getBodyList</a></p><p class = "function_description">모든 본문이있는 테이블을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">bodies</span> = World:<wbr>getBodyList()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">bodies</td><td class = "ra_type">table</td><td>모든 시체와 시퀀스.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getCallbacks" name = "World:getCallbacks"><span>World:</span><wbr>getCallbacks</a></p><p class = "function_description">월드 업데이트 중에 콜백 함수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">beginContact</span>, <span class = "returns">endContact</span>, <span class = "returns">preSolve</span>, <span class = "returns">postSolve</span> = World:<wbr>getCallbacks()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">beginContact</td><td class = "ra_type">function</td><td>두 개의 조명기가 겹쳐지기 시작할 때 호출됩니다.</td></tr><tr><td class = "returns ra_name">endContact</td><td class = "ra_type">function</td><td>두 개의 조명기가 겹쳐지지 않을 때 호출됩니다.</td></tr><tr><td class = "returns ra_name">preSolve</td><td class = "ra_type">function</td><td>충돌이 해결되기 전에 호출됩니다.</td></tr><tr><td class = "returns ra_name">postSolve</td><td class = "ra_type">function</td><td>충돌이 해결 된 후에 호출됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getContactCount" name = "World:getContactCount"><span>World:</span><wbr>getContactCount</a></p><p class = "function_description">세계의 연락처 수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">n</span> = World:<wbr>getContactCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">n</td><td class = "ra_type">number</td><td>전 세계의 연락처 수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getContactFilter" name = "World:getContactFilter"><span>World:</span><wbr>getContactFilter</a></p><p class = "function_description">충돌 필터링의 함수를 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">contactFilter</span> = World:<wbr>getContactFilter()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">contactFilter</td><td class = "ra_type">function</td><td>연락처 필터링을 처리하는 함수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getContactList" name = "World:getContactList"><span>World:</span><wbr>getContactList</a></p><p class = "function_description">모든 연락처가있는 테이블을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">contacts</span> = World:<wbr>getContactList()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">contacts</td><td class = "ra_type">table</td><td>모든 연락처가있는 시퀀스입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getGravity" name = "World:getGravity"><span>World:</span><wbr>getGravity</a></p><p class = "function_description">세계의 중력을 얻으십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = World:<wbr>getGravity()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>중력의 x 성분.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>중력의 y 성분.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getJointCount" name = "World:getJointCount"><span>World:</span><wbr>getJointCount</a></p><p class = "function_description">세계의 관절 수를 구하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">n</span> = World:<wbr>getJointCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">n</td><td class = "ra_type">number</td><td>세계의 관절 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:getJointList" name = "World:getJointList"><span>World:</span><wbr>getJointList</a></p><p class = "function_description">모든 관절이있는 테이블을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">joints</span> = World:<wbr>getJointList()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">joints</td><td class = "ra_type">table</td><td>모든 관절이있는 순서.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:isDestroyed" name = "World:isDestroyed"><span>World:</span><wbr>isDestroyed</a></p><p class = "function_description">세계가 파괴되었는지 여부를 가져옵니다. 파괴 된 세계는 사용할 수 없습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">destroyed</span> = World:<wbr>isDestroyed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">destroyed</td><td class = "ra_type">boolean</td><td>세계가 파괴되는지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:isLocked" name = "World:isLocked"><span>World:</span><wbr>isLocked</a></p><p class = "function_description">세계가 상태를 갱신하고 있을지 어떨지를 가져옵니다.<br /><br />이것은 World : setCallbacks의 콜백 내에서 true를 반환합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">locked</span> = World:<wbr>isLocked()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">locked</td><td class = "ra_type">boolean</td><td>세계가 상태를 업데이트하는 과정에있는 경우 true가됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:isSleepingAllowed" name = "World:isSleepingAllowed"><span>World:</span><wbr>isSleepingAllowed</a></p><p class = "function_description">세계의 수면 동작을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">allowSleep</span> = World:<wbr>isSleepingAllowed()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">allowSleep</td><td class = "ra_type">boolean</td><td>시체가 수면을 허용하면 참이거나 그렇지 않은 경우 거짓입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:queryBoundingBox" name = "World:queryBoundingBox"><span>World:</span><wbr>queryBoundingBox</a></p><p class = "function_description">지정된 영역 안의 각 조명기에 대한 함수를 호출합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>queryBoundingBox( <span class = "arguments">topLeftX</span>, <span class = "arguments">topLeftY</span>, <span class = "arguments">bottomRightX</span>, <span class = "arguments">bottomRightY</span>, <span class = "arguments">callback</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">topLeftX</td><td class = "ra_type">number</td><td>좌상 구석의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">topLeftY</td><td class = "ra_type">number</td><td>좌상 구석의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">bottomRightX</td><td class = "ra_type">number</td><td>오른쪽 아래 점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">bottomRightY</td><td class = "ra_type">number</td><td>오른쪽 아래 점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">callback</td><td class = "ra_type">function</td><td>이 함수는 하나의 인수 인 조명기를 전달 받고 부울을 반환해야합니다. 검색이 참이면 검색을 계속하고 거짓이면 검색을 중단합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:rayCast" name = "World:rayCast"><span>World:</span><wbr>rayCast</a></p><p class = "function_description">광선을 전달하고 교차하는 각 조명기에 대해 함수를 호출합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>rayCast( <span class = "arguments">x1</span>, <span class = "arguments">y1</span>, <span class = "arguments">x2</span>, <span class = "arguments">y2</span>, <span class = "arguments">callback</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x1</td><td class = "ra_type">number</td><td>광선의 시작점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y1</td><td class = "ra_type">number</td><td>광선의 시작점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">x2</td><td class = "ra_type">number</td><td>광선 끝점의 x 위치입니다.</td></tr><tr><td class = "arguments ra_name">y2</td><td class = "ra_type">number</td><td>광선의 종점의 y 위치입니다.</td></tr><tr><td class = "arguments ra_name">callback</td><td class = "ra_type">function</td><td>이 함수는 6 개의 인수를 가지며 숫자를 반환해야합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:setCallbacks" name = "World:setCallbacks"><span>World:</span><wbr>setCallbacks</a></p><p class = "function_description">월드 업데이트 중에 콜리 전 콜백 함수를 설정합니다.<br /><br />네 개의 루아 함수가 인수로 주어질 수 있습니다. nil 값은 함수를 제거합니다.<br /><br />호출되면 각 함수는 세 개의 인수를 전달합니다. 처음 두 인수는 충돌하는 조명기이고 세 번째 인수는 그들 사이의 접촉입니다. PostSolve 콜백은 각 접점에 대한 정상 및 접선 임펄스를 추가로 얻습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>setCallbacks( <span class = "arguments">beginContact</span>, <span class = "arguments">endContact</span>, <span class = "arguments">preSolve</span>, <span class = "arguments">postSolve</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">beginContact</td><td class = "ra_type">function</td><td>두 개의 조명기가 겹쳐지기 시작할 때 호출됩니다.</td></tr><tr><td class = "arguments ra_name">endContact</td><td class = "ra_type">function</td><td>두 개의 조명기가 겹쳐지지 않을 때 호출됩니다.</td></tr><tr><td class = "arguments ra_name">preSolve</td><td class = "ra_type">function</td><td>충돌이 해결되기 전에 호출됩니다.</td></tr><tr><td class = "arguments ra_name">postSolve</td><td class = "ra_type">function</td><td>충돌이 해결 된 후에 호출됩니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:setContactFilter" name = "World:setContactFilter"><span>World:</span><wbr>setContactFilter</a></p><p class = "function_description">충돌 필터링을위한 함수를 설정합니다.<br /><br />그룹 및 카테고리 필터링이 충돌 결정을 생성하지 않으면,이 함수는 두 개의 조명기를 인수로 호출합니다. 함수는 부울 값을 반환해야합니다. true는 조명기가 충돌한다는 것을 의미하고 false는 서로 통과한다는 것을 의미합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>setContactFilter( <span class = "arguments">filter</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">filter</td><td class = "ra_type">function</td><td>연락처 필터링을 처리하는 함수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:setGravity" name = "World:setGravity"><span>World:</span><wbr>setGravity</a></p><p class = "function_description">세계의 중력을 설정하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>setGravity( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>중력의 x 성분.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>중력의 y 성분.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:setSleepingAllowed" name = "World:setSleepingAllowed"><span>World:</span><wbr>setSleepingAllowed</a></p><p class = "function_description">세계의 수면 행동을 설정하십시오.<br /><br />수면 시체는 깨어있을 때보 다 시뮬레이션하는 것이 훨씬 효율적입니다.<br /><br />수면이 허용되면 휴식을 취한 모든 신체가 자게됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>setSleepingAllowed( <span class = "arguments">allowSleep</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">allowSleep</td><td class = "ra_type">boolean</td><td>시체가 수면을 허용하면 참이거나 그렇지 않은 경우 거짓입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:translateOrigin" name = "World:translateOrigin"><span>World:</span><wbr>translateOrigin</a></p><p class = "function_description">세계의 기원을 번역합니다. 원점에서 먼 거리에서 부동 소수점 정밀도 문제가 눈에 띄는 큰 곳에서 유용합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>translateOrigin( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>이전 원점에 대한 새로운 원점의 x 구성 요소입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>이전 원점에 대한 새로운 원점의 y 구성 요소입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#World:update" name = "World:update"><span>World:</span><wbr>update</a></p><p class = "function_description">세계의 상태를 업데이트하십시오.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">World:<wbr>update( <span class = "arguments">dt</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">dt</td><td class = "ra_type">number</td><td>물리 시뮬레이션을 진행할 시간 (초).</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.sound" name = "love.sound">love.sound</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#SoundData">SoundData</a>&emsp;실제 오디오 데이터를 메모리에 가지고 있는 객체입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.sound.newSoundData" name = "love.sound.newSoundData"><span>love.sound.</span><wbr>newSoundData</a></p><p class = "function_description">새로운 <a href="#SoundData">SoundData</a>를 생성합니다.<br /><br />생성자 가운데 파일 이름, <a href="#File">File</a>, <a href="#Decoder">Decoder</a>를 인수로 취하는 것은 모두 내부적으로 <a href="#Decoder">Decoder</a>를 사용합니다. 다만 사운드를 모두 디코딩해 메모리에 올려놓습니다.<br /><br />마지막 생성자는 샘플 레이트와 채널 등을 이용해 빈 메모리 공간을 할당합니다만 자주 사용되는 방법은 아닙니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">soundData</span> = love.sound.<wbr>newSoundData( <span class = "arguments">file</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">soundData</td><td class = "ra_type"><a href="#SoundData">SoundData</a></td><td>새로운 SoundData 객체입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>로드 할 파일의 파일 경로 / File / FileData.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">soundData</span> = love.sound.<wbr>newSoundData( <span class = "arguments">samples</span>, <span class = "arguments">samplingRate</span>, <span class = "arguments">bitRate</span>, <span class = "arguments">channelCount</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">soundData</td><td class = "ra_type"><a href="#SoundData">SoundData</a></td><td>새로운 SoundData 객체.</td></tr><tr><td class = "arguments ra_name">samples</td><td class = "ra_type">number</td><td>총 샘플 수.</td></tr><tr><td class = "arguments ra_name">samplingRate <span class = "default">(44100)</span></td><td class = "ra_type">number</td><td>샘플 레이트.</td></tr><tr><td class = "arguments ra_name">bitRate <span class = "default">(16)</span></td><td class = "ra_type">number</td><td>샘플 당 비트 수. 8 혹은 16.</td></tr><tr><td class = "arguments ra_name">channelCount <span class = "default">(2)</span></td><td class = "ra_type">number</td><td>채널 수. 1은 모노, 2는 스테레오.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#SoundData" name = "SoundData">SoundData</a></p><p class = "section_description">실제 오디오 데이터를 메모리에 가지고 있는 객체입니다.<br /><br />객체 생성 즉시 사운드 파일을 전부 메모리에 올립니다. 따라서 실제 재생되고 있는 위치에 따라 부분부분 메모리에 등재하는 디코더와는 달리 빠른 반응속도를 기대할 수 있습니다. 그러나 파일이 통째로 메모리에 올라가기 때문에 너무 큰 파일을 SoundData로 불러들이는 것은 메모리를 과도하게 차지할 수도 있습니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.sound.<a href="#love.sound.newSoundData">newSoundData</a>&emsp;새로운 SoundData를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">SoundData:<a href="#SoundData:getSample">get</a><span class = "slash">/</span><a href="#SoundData:setSample">setSample</a>&emsp;특정 위치의 샘플을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SoundData:<a href="#SoundData:getSampleCount">getSampleCount</a>&emsp;샘플 수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SoundData:<a href="#SoundData:getDuration">getDuration</a>&emsp;총 재생 시간을 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SoundData:<a href="#SoundData:getSampleRate">getSampleRate</a>&emsp;샘플 레이트를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SoundData:<a href="#SoundData:getBitDepth">getBitDepth</a>&emsp;샘플 당 비트 수를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">SoundData:<a href="#SoundData:getChannels">getChannels</a>&emsp;채널 수를 구합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Data">Data</a>&emsp;모든 데이터 타입의 최상위 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#SoundData:getBitDepth" name = "SoundData:getBitDepth"><span>SoundData:</span><wbr>getBitDepth</a></p><p class = "function_description">샘플 당 비트 수를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">bits</span> = SoundData:<wbr>getBitDepth()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">bits</td><td class = "ra_type">number</td><td>8 혹은 16.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SoundData:getChannels" name = "SoundData:getChannels"><span>SoundData:</span><wbr>getChannels</a></p><p class = "function_description">채널 수를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">channels</span> = SoundData:<wbr>getChannels()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">channels</td><td class = "ra_type">number</td><td>1은 모노, 2는 스테레오.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SoundData:getDuration" name = "SoundData:getDuration"><span>SoundData:</span><wbr>getDuration</a></p><p class = "function_description">총 재생 시간을 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">duration</span> = SoundData:<wbr>getDuration()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">duration</td><td class = "ra_type">number</td><td>총 재생 시간(초).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SoundData:getSample" name = "SoundData:getSample"><span>SoundData:</span><wbr>getSample</a></p><p class = "function_description">특정 위치의 샘플을 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">sample</span> = SoundData:<wbr>getSample( <span class = "arguments">i</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">sample</td><td class = "ra_type">number</td><td>정규화된 샘플(-1.0부터 1.0 사이).</td></tr><tr><td class = "arguments ra_name">i</td><td class = "ra_type">number</td><td>샘플의 위치(0은 첫 번째 샘플을 의미).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SoundData:getSampleCount" name = "SoundData:getSampleCount"><span>SoundData:</span><wbr>getSampleCount</a></p><p class = "function_description">샘플 수를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">count</span> = SoundData:<wbr>getSampleCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">count</td><td class = "ra_type">number</td><td>총 샘플 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SoundData:getSampleRate" name = "SoundData:getSampleRate"><span>SoundData:</span><wbr>getSampleRate</a></p><p class = "function_description">샘플 레이트를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">rate</span> = SoundData:<wbr>getSampleRate()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">rate</td><td class = "ra_type">number</td><td>초당 샘플 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#SoundData:setSample" name = "SoundData:setSample"><span>SoundData:</span><wbr>setSample</a></p><p class = "function_description">특정 위치의 샘플을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">SoundData:<wbr>setSample( <span class = "arguments">i</span>, <span class = "arguments">sample</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">i</td><td class = "ra_type">number</td><td>샘플의 위치(0은 첫 번째 샘플을 의미).</td></tr><tr><td class = "arguments ra_name">sample</td><td class = "ra_type">number</td><td>정규화된 샘플(-1.0부터 1.0 사이).</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.system" name = "love.system">love.system</a></p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.system.<a href="#love.system.openURL">openURL</a>&emsp;사용자의 웹 브라우저 또는 파일 브라우저를 통하여 URL을 엽니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.system.<a href="#love.system.getClipboardText">get</a><span class = "slash">/</span><a href="#love.system.setClipboardText">setClipboardText</a>&emsp;클립보드에 텍스트를 저장합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.system.<a href="#love.system.vibrate">vibrate</a>&emsp;가능한 경우 장치를 진동시킵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.system.<a href="#love.system.getOS">getOS</a>&emsp;현재 동작중인 OS를 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.system.<a href="#love.system.getPowerInfo">getPowerInfo</a>&emsp;배터리를 사용하는 기기에서 전원 공급에 관한 정보를 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.system.<a href="#love.system.getProcessorCount">getProcessorCount</a>&emsp;시스템의 CPU 코어 수를 조사합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#PowerState">PowerState</a>&emsp;배터리를 사용하는 기기에서 간단한 전원 공급 상태를 나타냅니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.system.getClipboardText" name = "love.system.getClipboardText"><span>love.system.</span><wbr>getClipboardText</a></p><p class = "function_description">클립보드에 저장된 텍스트를 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">text</span> = love.system.<wbr>getClipboardText()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">text</td><td class = "ra_type">string</td><td>현재 클립보드에 들어있는 텍스트.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.system.getOS" name = "love.system.getOS"><span>love.system.</span><wbr>getOS</a></p><p class = "function_description">현재 동작중인 OS를 조사합니다. 일반적으로 L&Ouml;VE에서는 OS를 완전히 추상화하기 때문에 지금 동작하고 있는 OS를 조사할 필요는 없습니다. 그렇지만 이 정보가 유용하게 사용되는 특정한 경우가 있긴 합니다 (os.execute를 이용해 OS에 종속적인 명령어를 실행해야 할 때가 대표적인 경우겠죠).</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">osString</span> = love.system.<wbr>getOS()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">osString</td><td class = "ra_type">string</td><td>현재 동작중인 OS. "OS X", "Windows", or "Linux".</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.system.getPowerInfo" name = "love.system.getPowerInfo"><span>love.system.</span><wbr>getPowerInfo</a></p><p class = "function_description">배터리를 사용하는 기기에서 전원 공급에 관한 정보를 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">state</span>, <span class = "returns">percent</span>, <span class = "returns">seconds</span> = love.system.<wbr>getPowerInfo()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">state</td><td class = "ra_type"><a href="#PowerState">PowerState</a></td><td>간단한 전원 공급 상태.</td></tr><tr><td class = "returns ra_name">percent</td><td class = "ra_type">number</td><td>잔여 배터리량. 0부터 100 사이의 값으로 나타냄. 배터리가 없거나 배터리의 상태를 명확히 확인할 없을 경우 nil.</td></tr><tr><td class = "returns ra_name">seconds</td><td class = "ra_type">number</td><td>잔여 배터리 시간(초). 배터리가 없거나 배터리의 상태를 명확히 확인할 없을 경우 nil.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.system.getProcessorCount" name = "love.system.getProcessorCount"><span>love.system.</span><wbr>getProcessorCount</a></p><p class = "function_description">시스템의 CPU 코어 수를 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">cores</span> = love.system.<wbr>getProcessorCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">cores</td><td class = "ra_type">number</td><td>CPU 코어의 개수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.system.openURL" name = "love.system.openURL"><span>love.system.</span><wbr>openURL</a></p><p class = "function_description">사용자의 웹 브라우저 또는 파일 브라우저를 통하여 URL을 엽니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.system.<wbr>openURL( <span class = "arguments">url</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공적으로 열었으면 true.</td></tr><tr><td class = "arguments ra_name">url</td><td class = "ra_type">string</td><td>열 URL. 정확한 URL 형식이 갖추어져야 함.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.system.setClipboardText" name = "love.system.setClipboardText"><span>love.system.</span><wbr>setClipboardText</a></p><p class = "function_description">클립보드에 텍스트를 저장합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.system.<wbr>setClipboardText( <span class = "arguments">text</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">text</td><td class = "ra_type">string</td><td>클립 보드에 저장할 새로운 텍스트.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.system.vibrate" name = "love.system.vibrate"><span>love.system.</span><wbr>vibrate</a></p><p class = "function_description">가능한 경우 장치를 진동시킵니다. 현재이 기능은 진동 모터가 내장 된 Android 및 iOS 기기에서만 작동합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.system.<wbr>vibrate( <span class = "arguments">seconds</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">seconds <span class = "default">(0.5)</span></td><td class = "ra_type">number</td><td>진동 할 시간. iOS 기기에서 호출되면 iOS 시스템 API의 제한으로 인해 0.5 초 동안 항상 진동합니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#PowerState" name = "PowerState">PowerState</a></p><p class = "constant_name">unknown</p><p class = "constant_description">상태를 알 수 없음.</p><p class = "constant_name">battery</p><p class = "constant_description">전원이 공급되고 있지 않아 배터리를 소모하는 중.</p><p class = "constant_name">nobattery</p><p class = "constant_description">전원이 공급되고 있긴 하나 배터리를 사용할 수 없음.</p><p class = "constant_name">charging</p><p class = "constant_description">전원이 공급되고 있으며 배터리 충전중.</p><p class = "constant_name">charged</p><p class = "constant_description">전원이 공급되고 있으며 배터리가 완충되어 있음.</p></div><div class = "section"><p class = "section_heading"><a href = "#love.thread" name = "love.thread">love.thread</a></p><p class = "section_navigation_subheading">Types</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Thread">Thread</a>&emsp;스레드를 표현하는 타입입니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Channel">Channel</a>&emsp;서로 다른 스레드 사이에 데이터를 주고받는 데 사용되는 객체입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.thread.getChannel" name = "love.thread.getChannel"><span>love.thread.</span><wbr>getChannel</a></p><p class = "function_description">이름 있는 스레드 채널을 생성하거나 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">channel</span> = love.thread.<wbr>getChannel( <span class = "arguments">name</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">channel</td><td class = "ra_type"><a href="#Channel">Channel</a></td><td>채널 객체.</td></tr><tr><td class = "arguments ra_name">name</td><td class = "ra_type">string</td><td>생성할, 혹은 받아올 채널의 이름.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.thread.newChannel" name = "love.thread.newChannel"><span>love.thread.</span><wbr>newChannel</a></p><p class = "function_description">이름 없는 스레드 채널을 생성합니다.<br /><br />이름 없는 채널을 사용하는 방법중 하나는 이름있는 채널의 Channel:push를 통해 다른 스레드에게 이름없는 채널을 건네주는 것이 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">channel</span> = love.thread.<wbr>newChannel()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">channel</td><td class = "ra_type"><a href="#Channel">Channel</a></td><td>채널 객체.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.thread.newThread" name = "love.thread.newThread"><span>love.thread.</span><wbr>newThread</a></p><p class = "function_description">루아 파일이나 FileData로부터 새로운 스레드를 생성합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">thread</span> = love.thread.<wbr>newThread( <span class = "arguments">file</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">thread</td><td class = "ra_type"><a href="#Thread">Thread</a></td><td>아직 시작되지 않은 새 스레드입니다.</td></tr><tr><td class = "arguments ra_name">file</td><td class = "ra_type">string / <a href="#File">File</a> / <a href="#FileData">FileData</a></td><td>소스로 사용할 Lua 파일의 파일 경로 / File / FileData.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">thread</span> = love.thread.<wbr>newThread( <span class = "arguments">codestring</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">thread</td><td class = "ra_type"><a href="#Thread">Thread</a></td><td>아직 실행되지 않은 새 스레드.</td></tr><tr><td class = "arguments ra_name">codestring</td><td class = "ra_type">string</td><td>루아로 짜여진 소스 코드 파일의 이름.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Thread" name = "Thread">Thread</a></p><p class = "section_description">스레드를 표현하는 타입입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.thread.<a href="#love.thread.newThread">newThread</a>&emsp;루아 파일이나 FileData로부터 새로운 스레드를 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Thread:<a href="#Thread:start">start</a>&emsp;스레드를 실행합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Thread:<a href="#Thread:wait">wait</a>&emsp;스레드가 완료되기를 기다립니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Thread:<a href="#Thread:getError">getError</a>&emsp;스레드에서 에러가 발생되었을 경우 메시지를 리턴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Thread:<a href="#Thread:isRunning">isRunning</a>&emsp;스레드가 현재 실행중인지 확인합니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Thread:getError" name = "Thread:getError"><span>Thread:</span><wbr>getError</a></p><p class = "function_description">스레드에서 에러가 발생되었을 경우 메시지를 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">message</span> = Thread:<wbr>getError()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">message</td><td class = "ra_type">string</td><td>에러 메시지.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Thread:start" name = "Thread:start"><span>Thread:</span><wbr>start</a></p><p class = "function_description">스레드를 실행합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Thread:<wbr>start()</span></span></p><table class = "ra_table"></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Thread:<wbr>start( <span class = "arguments">arg1</span>, <span class = "arguments">arg2</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">arg1</td><td class = "ra_type">Variant</td><td>문자열, 숫자, 부울, L-VE 오브젝트 또는 간단한 테이블.</td></tr><tr><td class = "arguments ra_name">arg2</td><td class = "ra_type">Variant</td><td>문자열, 숫자, 부울, L-VE 오브젝트 또는 간단한 테이블.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">Variant</td><td>스레드에 계속 값을 전달할 수 있습니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Thread:wait" name = "Thread:wait"><span>Thread:</span><wbr>wait</a></p><p class = "function_description">스레드가 완료되기를 기다립니다.<br /><br />이 함수를 호출하면 해당 스레드가 끝날 때까지 무한정 대기합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Thread:<wbr>wait()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Thread:isRunning" name = "Thread:isRunning"><span>Thread:</span><wbr>isRunning</a></p><p class = "function_description">스레드가 현재 실행중인지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">running</span> = Thread:<wbr>isRunning()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">running</td><td class = "ra_type">boolean</td><td>실행중이면 true.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#Channel" name = "Channel">Channel</a></p><p class = "section_description">서로 다른 스레드 사이에 데이터를 주고받는 데 사용되는 객체입니다.</p><p class = "section_navigation_subheading">Constructors</p><p class = "section_navigation_link section_navigation_link_minidescription">love.thread.<a href="#love.thread.getChannel">getChannel</a>&emsp;이름 있는 스레드 채널을 생성하거나 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.thread.<a href="#love.thread.newChannel">newChannel</a>&emsp;이름 없는 스레드 채널을 생성합니다. </p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:push">push</a>&emsp;채널로 메시지를 전송합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:pop">pop</a>&emsp;채널에서 메시지를 얻어온 후 메시지 큐에서 메시지를 삭제합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:supply">supply</a>&emsp;채널로 메시지를 전송한 후, 다른 스레드가 메시지를 받을 때까지 대기합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:demand">demand</a>&emsp;채널에 메시지가 도착할 때까지 무한정 기다린 후 메시지가 도착하면 메시지를 얻어옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:peek">peek</a>&emsp;채널에서 메시지를 얻어옵니다만, 메시지 큐에서 삭제하지는 않습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:clear">clear</a>&emsp;메시지 큐를 모두 비웁니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:performAtomic">performAtomic</a>&emsp;이 채널에 대해 지정된 함수를 원자 적으로 실행합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">Channel:<a href="#Channel:getCount">getCount</a>&emsp;메시지 큐에 메시지가 몇 개나 쌓여있는지 세어봅니다. </p><p class = "section_navigation_subheading">Supertypes</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#Object">Object</a>&emsp;L&Ouml;VE의 최상위 타입입니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#Channel:clear" name = "Channel:clear"><span>Channel:</span><wbr>clear</a></p><p class = "function_description">메시지 큐를 모두 비웁니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Channel:<wbr>clear()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#Channel:demand" name = "Channel:demand"><span>Channel:</span><wbr>demand</a></p><p class = "function_description">채널에 메시지가 도착할 때까지 무한정 기다린 후 메시지가 도착하면 메시지를 얻어옵니다. 얻어온 메시지는 메시지 큐에서 삭제합니다.<br /><br />메시지의 value 타입은 논리형, 문자열, 수치형, L&Ouml;VE의 <a href="#Object">Object</a>를 상속받는 객체, 혹은 이들을 원소로 가지고 있는 테이블만을 지원합니다. 함수, 테이블 내의 테이블, L&Ouml;VE에서 지원하지 않는 유저데이터는 지원되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = Channel:<wbr>demand()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">Variant</td><td>메시지의 내용.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Channel:getCount" name = "Channel:getCount"><span>Channel:</span><wbr>getCount</a></p><p class = "function_description">메시지 큐에 메시지가 몇 개나 쌓여있는지 세어봅니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">count</span> = Channel:<wbr>getCount()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">count</td><td class = "ra_type">number</td><td>메시지 큐에 쌓인 메시지의 수.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Channel:peek" name = "Channel:peek"><span>Channel:</span><wbr>peek</a></p><p class = "function_description">채널에서 메시지를 얻어옵니다만, 메시지 큐에서 삭제하지는 않습니다.<br /><br />메시지의 value 타입은 논리형, 문자열, 수치형, L&Ouml;VE의 <a href="#Object">Object</a>를 상속받는 객체, 혹은 이들을 원소로 가지고 있는 테이블만을 지원합니다. 함수, 테이블 내의 테이블, L&Ouml;VE에서 지원하지 않는 유저데이터는 지원되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = Channel:<wbr>peek()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">Variant</td><td>메시지의 내용.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Channel:performAtomic" name = "Channel:performAtomic"><span>Channel:</span><wbr>performAtomic</a></p><p class = "function_description">이 채널에 대해 지정된 함수를 원자 적으로 실행합니다.<br /><br />같은 채널에있는 여러 메소드를 연속적으로 호출하면 유용합니다. 다만, 복수의 thread가이 채널의 메소드를 동시에 호출하고있는 경우, 각 thread로 다른 호출이 인터리브되어 버릴 가능성이 있습니다 (예를 들어, 1 번째의 thread의 호출 중 1 개 이상이 최초의 thread의 호출 사이에서 발생할 가능성이 있습니다).<br /><br />이 메소드는 지정된 함수가 리턴 될 때까지 메소드를 호출하는 스레드가 채널에 독점적으로 액세스 할 수있게하여 해당 문제점을 피합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">ret1</span>, <span class = "returns">...</span> = Channel:<wbr>performAtomic( <span class = "arguments">func</span>, <span class = "arguments">arg1</span>, <span class = "arguments">...</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">ret1</td><td class = "ra_type">any</td><td>주어진 함수의 첫 번째 반환 값 (있는 경우).</td></tr><tr><td class = "returns ra_name">...</td><td class = "ra_type">any</td><td>다른 반환 값.</td></tr><tr><td class = "arguments ra_name">func</td><td class = "ra_type">function</td><td>호출 할 함수, 함수의 형식 (channel, arg1, arg2, ...) end. 채널은 호출 될 때 첫 번째 인수로 함수에 전달됩니다.</td></tr><tr><td class = "arguments ra_name">arg1</td><td class = "ra_type">any</td><td>해당 함수가 호출 될 때 받게 될 추가 인수입니다.</td></tr><tr><td class = "arguments ra_name">...</td><td class = "ra_type">any</td><td>해당 함수가 호출 될 때 받게 될 추가 인수입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Channel:pop" name = "Channel:pop"><span>Channel:</span><wbr>pop</a></p><p class = "function_description">채널에서 메시지를 얻어온 후 메시지 큐에서 메시지를 삭제합니다.<br /><br />메시지의 value 타입은 논리형, 문자열, 수치형, L&Ouml;VE의 <a href="#Object">Object</a>를 상속받는 객체, 혹은 이들을 원소로 가지고 있는 테이블만을 지원합니다. 함수, 테이블 내의 테이블, L&Ouml;VE에서 지원하지 않는 유저데이터는 지원되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = Channel:<wbr>pop()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">Variant</td><td>메시지의 내용.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Channel:push" name = "Channel:push"><span>Channel:</span><wbr>push</a></p><p class = "function_description">채널로 메시지를 전송합니다.<br /><br />메시지의 value 타입은 논리형, 문자열, 수치형, L&Ouml;VE의 <a href="#Object">Object</a>를 상속받는 객체, 혹은 이들을 원소로 가지고 있는 테이블만을 지원합니다. 함수, 테이블 내의 테이블, L&Ouml;VE에서 지원하지 않는 유저데이터는 지원되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Channel:<wbr>push( <span class = "arguments">value</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">value</td><td class = "ra_type">Variant</td><td>메시지의 내용.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#Channel:supply" name = "Channel:supply"><span>Channel:</span><wbr>supply</a></p><p class = "function_description">채널로 메시지를 전송한 후, 다른 스레드가 메시지를 받을 때까지 대기합니다.<br /><br />메시지의 value 타입은 논리형, 문자열, 수치형, L&Ouml;VE의 <a href="#Object">Object</a>를 상속받는 객체, 혹은 이들을 원소로 가지고 있는 테이블만을 지원합니다. 함수, 테이블 내의 테이블, L&Ouml;VE에서 지원하지 않는 유저데이터는 지원되지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">Channel:<wbr>supply( <span class = "arguments">value</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">value</td><td class = "ra_type">Variant</td><td>메시지의 내용.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.timer" name = "love.timer">love.timer</a></p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.timer.<a href="#love.timer.getTime">getTime</a>&emsp;불명확한 시작 시간으로부터 현재까지의 소요 시간을 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.timer.<a href="#love.timer.getFPS">getFPS</a>&emsp;현재 FPS를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.timer.<a href="#love.timer.getAverageDelta">getAverageDelta</a>&emsp;최근 1초에서 평균 델타 시간(프레임당 소요 시간)을 초 단위로 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.timer.<a href="#love.timer.getDelta">getDelta</a>&emsp;최근 두 프레임 간의 시간 간격(델타)을 리턴합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.timer.<a href="#love.timer.sleep">sleep</a>&emsp;일정 시간동안 현재 스레드를 일시 정지합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.timer.<a href="#love.timer.step">step</a>&emsp;두 프레임 사이의 시간을 측정합니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.timer.getAverageDelta" name = "love.timer.getAverageDelta"><span>love.timer.</span><wbr>getAverageDelta</a></p><p class = "function_description">최근 1초에서 평균 델타 시간(프레임당 소요 시간)을 초 단위로 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">delta</span> = love.timer.<wbr>getAverageDelta()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">delta</td><td class = "ra_type">number</td><td>최근 1초에서의 평균 델타 초.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.timer.getDelta" name = "love.timer.getDelta"><span>love.timer.</span><wbr>getDelta</a></p><p class = "function_description">최근 두 프레임 간의 시간 간격(델타)을 리턴합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">dt</span> = love.timer.<wbr>getDelta()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">dt</td><td class = "ra_type">number</td><td>시간 간격(초 단위).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.timer.getFPS" name = "love.timer.getFPS"><span>love.timer.</span><wbr>getFPS</a></p><p class = "function_description">현재 FPS를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fps</span> = love.timer.<wbr>getFPS()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fps</td><td class = "ra_type">number</td><td>현재 FPS.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.timer.getTime" name = "love.timer.getTime"><span>love.timer.</span><wbr>getTime</a></p><p class = "function_description">불명확한 시작 시간으로부터 현재까지의 소요 시간을 구합니다.<br /><br />시작 시간이 정확히 언제인지는 알 수 없습니다. 따라서 이 함수는 오직 두 시점간의 간격만을 구하는 데 사용해야 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">time</span> = love.timer.<wbr>getTime()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">time</td><td class = "ra_type">number</td><td>소요 시간(초 단위).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.timer.sleep" name = "love.timer.sleep"><span>love.timer.</span><wbr>sleep</a></p><p class = "function_description">일정 시간동안 현재 스레드를 일시 정지합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.timer.<wbr>sleep( <span class = "arguments">s</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">s</td><td class = "ra_type">number</td><td>일시 정지할 시간(초 단위).</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.timer.step" name = "love.timer.step"><span>love.timer.</span><wbr>step</a></p><p class = "function_description">두 프레임 사이의 시간을 측정합니다. 이것을 호출하면 <a href="#love.timer.getDelta">love.timer.getDelta</a>의 반환 값이 변경됩니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.timer.<wbr>step()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "section_heading"><a href = "#love.touch" name = "love.touch">love.touch</a></p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.touch.<a href="#love.touch.getTouches">getTouches</a>&emsp;모든 활성 터치 프레스의 목록을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.touch.<a href="#love.touch.getPosition">getPosition</a>&emsp;지정된 터치 프레스의 현재 위치를 픽셀 단위로 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.touch.<a href="#love.touch.getPressure">getPressure</a>&emsp;지정된 터치 프레스의 현재 압력을 가져옵니다. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.touch.getPosition" name = "love.touch.getPosition"><span>love.touch.</span><wbr>getPosition</a></p><p class = "function_description">지정된 터치 프레스의 현재 위치를 픽셀 단위로 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = love.touch.<wbr>getPosition( <span class = "arguments">id</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>윈도우 내부의 터치 - 프레스의 x- 축을 따르는 위치 (픽셀 단위).</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>윈도우 내부의 터치 - 프레스의 Y 축을 따르는 위치 (픽셀 단위).</td></tr><tr><td class = "arguments ra_name">id</td><td class = "ra_type">light userdata</td><td>터치 프레스의 식별자입니다. touch id 값을 얻으려면 <a href="#love.touch.getTouches">love.touch.getTouches</a>, love.touchpressed 또는 love.touchmoved를 사용하십시오.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.touch.getPressure" name = "love.touch.getPressure"><span>love.touch.</span><wbr>getPressure</a></p><p class = "function_description">지정된 터치 프레스의 현재 압력을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">pressure</span> = love.touch.<wbr>getPressure( <span class = "arguments">id</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">pressure</td><td class = "ra_type">number</td><td>터치 프레스의 압력. 대부분의 터치 스크린은 압력에 민감하지 않습니다.이 경우 압력은 1이됩니다.</td></tr><tr><td class = "arguments ra_name">id</td><td class = "ra_type">light userdata</td><td>터치 프레스의 식별자입니다. touch id 값을 얻으려면 <a href="#love.touch.getTouches">love.touch.getTouches</a>, love.touchpressed 또는 love.touchmoved를 사용하십시오.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.touch.getTouches" name = "love.touch.getTouches"><span>love.touch.</span><wbr>getTouches</a></p><p class = "function_description">모든 활성 터치 프레스의 목록을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">touches</span> = love.touch.<wbr>getTouches()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">touches</td><td class = "ra_type">table</td><td><a href="#love.touch.getPosition">love.touch.getPosition</a>과 함께 사용할 수있는 활성 터치 프레스 ID 값의 목록입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#love.video" name = "love.video">love.video</a></p></div><div class = "section"><p class = "section_heading"><a href = "#love.window" name = "love.window">love.window</a></p><p class = "section_navigation_subheading">Functions</p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getTitle">get</a><span class = "slash">/</span><a href="#love.window.setTitle">setTitle</a>&emsp;윈도우 타이틀을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getIcon">get</a><span class = "slash">/</span><a href="#love.window.setIcon">setIcon</a>&emsp;게임이 종료될 때까지 사용할 윈도우 아이콘을 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getFullscreenModes">getFullscreenModes</a>&emsp;(한국어)|normal 모드에서 사용 가능한 해상도 리스트를 구합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getMode">get</a><span class = "slash">/</span><a href="#love.window.setMode">setMode</a>&emsp;윈도우의 총괄적인 상태를 변경합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getFullscreen">get</a><span class = "slash">/</span><a href="#love.window.setFullscreen">setFullscreen</a>&emsp;전체 화면 모드로 진입하거나 빠져 나옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getPosition">get</a><span class = "slash">/</span><a href="#love.window.setPosition">setPosition</a>&emsp;화면의 윈도우 위치를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.hasFocus">hasFocus</a>&emsp;윈도우가 키보드 포커스를 가지고 있는지 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.hasMouseFocus">hasMouseFocus</a>&emsp;윈도우가 마우스 포커스를 가지고 있는지 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.maximize">maximize</a>&emsp;가능한 한 윈도우를 크게 만듭니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.minimize">minimize</a>&emsp;창을 시스템의 작업 표시 줄 / 독에 최소화합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.isMaximized">isMaximized</a>&emsp;Window가 현재 최대화되어 있는지 여부를 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.isVisible">isVisible</a>&emsp;게임 윈도우가 보이는지에 대한 여부를 조사합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.isOpen">isOpen</a>&emsp;창이 열려 있는지 확인합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.close">close</a>&emsp;창을 닫습니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.requestAttention">requestAttention</a>&emsp;포 그라운드에 있지 않은 경우 창에서 사용자의주의를 요청합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getDisplayName">getDisplayName</a>&emsp;표시 장치의 이름을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.isDisplaySleepEnabled">is</a><span class = "slash">/</span><a href="#love.window.setDisplaySleepEnabled">setDisplaySleepEnabled</a>&emsp;프로그램이 실행되는 동안 디스플레이가 절전 모드로 전환 될 수 있는지 여부를 설정합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.showMessageBox">showMessageBox</a>&emsp;사랑 창 위에 메시지 상자 대화 상자를 표시합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.fromPixels">fromPixels</a>&emsp;픽셀에서 밀도 독립적 단위로 숫자를 변환합니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.getPixelScale">getPixelScale</a>&emsp;윈도우와 연결된 DPI 비율을 가져옵니다. </p><p class = "section_navigation_link section_navigation_link_minidescription">love.window.<a href="#love.window.toPixels">toPixels</a>&emsp;숫자를 밀도 독립적 단위에서 픽셀 단위로 변환합니다. </p><p class = "section_navigation_subheading">Enums</p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#FullscreenType">FullscreenType</a>&emsp;전체 화면 모드의 종류를 나타냅니다. </p><p class = "section_navigation_link section_navigation_link_minidescription"><a href="#MessageBoxType">MessageBoxType</a>&emsp;메시지 상자 대화 상자의 유형. </p></div><div class = "section"><p class = "function_heading"><a href = "#love.window.close" name = "love.window.close"><span>love.window.</span><wbr>close</a></p><p class = "function_description">창을 닫습니다. <a href="#love.window.setMode">love.window.setMode</a>로 다시 열 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.window.<wbr>close()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.fromPixels" name = "love.window.fromPixels"><span>love.window.</span><wbr>fromPixels</a></p><p class = "function_description">픽셀에서 밀도 독립적 단위로 숫자를 변환합니다.<br /><br />창의 내부 픽셀 밀도는 창의 "크기"보다 클 수 있습니다. 예를 들어, highdpi 윈도우 플래그가 활성화 된 Mac OS X의 망막 스크린에서 윈도우는 800x600 윈도우와 동일한 실제 크기를 차지할 수 있지만 윈도우 내부의 영역은 1600x1200 픽셀을 사용합니다. love.window.fromPixels (1600)은이 경우 800을 반환합니다.<br /><br />이 함수는 픽셀의 좌표를 사용자가 화면 상에 표시 할 것으로 예상하는 크기로 변환합니다. <a href="#love.window.toPixels">love.window.toPixels</a>는 그 반대입니다. Mac OS X 및 iOS에서 Retina 화면의 전체 픽셀 밀도를 사용하려면 highdpi 창 플래그를 사용하도록 설정해야합니다. 이 플래그는 현재 Windows 및 Linux에서는 아무 작업도 수행하지 않으며, Android에서는 실제로이 플래그가 항상 활성화되어 있습니다.<br /><br />대부분의 L-VE 함수는 값을 반환하고 밀도 독립 단위가 아닌 픽셀 단위로 인수를 예상합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">value</span> = love.window.<wbr>fromPixels( <span class = "arguments">pixelvalue</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">value</td><td class = "ra_type">number</td><td>밀도에 의존하지 않는 단위로 변환 된 숫자.</td></tr><tr><td class = "arguments ra_name">pixelvalue</td><td class = "ra_type">number</td><td>밀도 독립 단위로 변환 할 픽셀 단위의 숫자입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span> = love.window.<wbr>fromPixels( <span class = "arguments">px</span>, <span class = "arguments">py</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>변환 된 x 축 좌표 값 (밀도 독립 단위).</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>변환 된 좌표의 y 축 값입니다 (밀도와 무관 한 단위).</td></tr><tr><td class = "arguments ra_name">px</td><td class = "ra_type">number</td><td>좌표의 x 축 값 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">py</td><td class = "ra_type">number</td><td>좌표의 Y 축 값 (픽셀 단위)입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getDisplayName" name = "love.window.getDisplayName"><span>love.window.</span><wbr>getDisplayName</a></p><p class = "function_description">표시 장치의 이름을 가져옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">name</span> = love.window.<wbr>getDisplayName( <span class = "arguments">displayindex</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">name</td><td class = "ra_type">string</td><td>지정된 디스플레이의 이름.</td></tr><tr><td class = "arguments ra_name">displayindex</td><td class = "ra_type">number</td><td>디스플레이의 이름을 가져올 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getFullscreen" name = "love.window.getFullscreen"><span>love.window.</span><wbr>getFullscreen</a></p><p class = "function_description">현재 전체 화면으로 동작하고 있는지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">fullscreen</span>, <span class = "returns">fstype</span> = love.window.<wbr>getFullscreen()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">fullscreen</td><td class = "ra_type">boolean</td><td>전체 화면이면 true.</td></tr><tr><td class = "returns ra_name">fstype</td><td class = "ra_type"><a href="#FullscreenType">FullscreenType</a></td><td>사용되고 있는 전체 화면 모드의 종류.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getFullscreenModes" name = "love.window.getFullscreenModes"><span>love.window.</span><wbr>getFullscreenModes</a></p><p class = "function_description">(한국어)|normal 모드에서 사용 가능한 해상도 리스트를 구합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">modes</span> = love.window.<wbr>getFullscreenModes( <span class = "arguments">display</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">modes</td><td class = "ra_type">table</td><td>너비 / 높이 쌍의 테이블입니다. (순서가 맞지 않을 수도 있습니다.)</td></tr><tr><td class = "arguments ra_name">display <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>여러 모니터를 사용할 수있는 경우 디스플레이의 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getIcon" name = "love.window.getIcon"><span>love.window.</span><wbr>getIcon</a></p><p class = "function_description">윈도우 아이콘을 얻어옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">imagedata</span> = love.window.<wbr>getIcon()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">imagedata</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>윈도우 아이콘. <a href="#love.window.setIcon">love.window.setIcon</a>으로 아이콘이 설정된 적이 없을 경우 nil을 리턴.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getMode" name = "love.window.getMode"><span>love.window.</span><wbr>getMode</a></p><p class = "function_description">윈도우의 총괄적인 상태를 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">width</span>, <span class = "returns">height</span>, <span class = "returns">flags</span> = love.window.<wbr>getMode()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">width</td><td class = "ra_type">number</td><td>창 너비.</td></tr><tr><td class = "returns ra_name">height</td><td class = "ra_type">number</td><td>창 높이.</td></tr><tr><td class = "returns ra_name">flags</td><td class = "ra_type">table</td><td>창 특성을 포함하는 표.</td></tr><tr><td class = "returns ra_name">flags.fullscreen</td><td class = "ra_type">boolean</td><td>전체 화면 (true) 또는 창 (false).</td></tr><tr><td class = "returns ra_name">flags.fullscreentype</td><td class = "ra_type"><a href="#FullscreenType">FullscreenType</a></td><td>사용 된 전체 화면 모드의 유형입니다.</td></tr><tr><td class = "returns ra_name">flags.vsync</td><td class = "ra_type">boolean</td><td>그래픽 프레임 속도가 모니터의 재생 빈도와 동기화되면 true이고, 그렇지 않으면 false입니다.</td></tr><tr><td class = "returns ra_name">flags.msaa</td><td class = "ra_type">number</td><td>사용 된 앤티 엘리 어싱 샘플의 수 (MSAA가 비활성화 된 경우 0)입니다.</td></tr><tr><td class = "returns ra_name">flags.resizable</td><td class = "ra_type">boolean</td><td>윈도우가 윈도우 모드로 사이즈 변경 가능한 경우는 true, 그렇지 않은 경우는 false</td></tr><tr><td class = "returns ra_name">flags.borderless</td><td class = "ra_type">boolean</td><td>윈도우가 윈도우 모드에서 경계선이없는 경우는 true, 그렇지 않은 경우는 false입니다.</td></tr><tr><td class = "returns ra_name">flags.centered</td><td class = "ra_type">boolean</td><td>윈도우가 윈도우 모드의 중앙에있는 경우는 true, 그렇지 않은 경우는 false</td></tr><tr><td class = "returns ra_name">flags.display</td><td class = "ra_type">number</td><td>복수의 모니터를 이용할 수있는 경우, 윈도우가 현재 존재하고있는 디스플레이의 인덱스.</td></tr><tr><td class = "returns ra_name">flags.minwidth</td><td class = "ra_type">number</td><td>윈도우의 최소폭입니다 (사이즈를 변경할 수있는 경우).</td></tr><tr><td class = "returns ra_name">flags.minheight</td><td class = "ra_type">number</td><td>윈도우의 최소 높이입니다 (사이즈를 재조정 할 수있는 경우).</td></tr><tr><td class = "returns ra_name">flags.highdpi</td><td class = "ra_type">boolean</td><td>OS-X 및 iOS의 Retina 디스플레이에서 높은 dpi 모드를 사용해야하는 경우 True입니다. 비 망막 디스플레이에는 아무 것도 표시되지 않습니다. 0.9.1에 추가되었습니다.</td></tr><tr><td class = "returns ra_name">flags.refreshrate</td><td class = "ra_type">number</td><td>화면의 현재 디스플레이 모드의 새로 고침 빈도 (Hz)입니다. 값을 판별 할 수 없으면 0이 될 수 있습니다.</td></tr><tr><td class = "returns ra_name">flags.x</td><td class = "ra_type">number</td><td>현재 디스플레이에서 창의 위치의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">flags.y</td><td class = "ra_type">number</td><td>현재 디스플레이에서 창의 위치의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getPixelScale" name = "love.window.getPixelScale"><span>love.window.</span><wbr>getPixelScale</a></p><p class = "function_description">윈도우와 연결된 DPI 비율을 가져옵니다.<br /><br />창의 내부 픽셀 밀도는 창의 "크기"보다 클 수 있습니다. 예를 들어, highdpi 윈도우 플래그가 활성화 된 Mac OS X의 망막 스크린에서 윈도우는 800x600 윈도우와 동일한 실제 크기를 차지할 수 있지만 윈도우 내부의 영역은 1600x1200 픽셀을 사용합니다. love.window.getPixelScale ()은이 경우 2.0을 반환합니다.<br /><br />사랑 .window.from 픽셀 및 사랑 .window.toPixels 함수는 또한 단위를 변환하는 데 사용할 수 있습니다.<br /><br />Mac OS X 및 iOS에서 Retina 화면의 전체 픽셀 밀도를 사용하려면 highdpi 창 플래그를 사용하도록 설정해야합니다. 이 플래그는 현재 Windows 및 Linux에서는 아무 작업도 수행하지 않으며, Android에서는 실제로이 플래그가 항상 활성화되어 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">scale</span> = love.window.<wbr>getPixelScale()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">scale</td><td class = "ra_type">number</td><td>윈도우와 관련된 픽셀 축척 비율입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getPosition" name = "love.window.getPosition"><span>love.window.</span><wbr>getPosition</a></p><p class = "function_description">화면상의 윈도우 위치를 가져옵니다.<br /><br />창 위치는 현재있는 디스플레이의 좌표 공간에 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">x</span>, <span class = "returns">y</span>, <span class = "returns">display</span> = love.window.<wbr>getPosition()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">x</td><td class = "ra_type">number</td><td>윈도우 위치의 x 좌표입니다.</td></tr><tr><td class = "returns ra_name">y</td><td class = "ra_type">number</td><td>윈도우의 위치의 y 좌표입니다.</td></tr><tr><td class = "returns ra_name">display</td><td class = "ra_type">number</td><td>윈도우가있는 디스플레이 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.getTitle" name = "love.window.getTitle"><span>love.window.</span><wbr>getTitle</a></p><p class = "function_description">윈도우 타이틀을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">title</span> = love.window.<wbr>getTitle()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">title</td><td class = "ra_type">string</td><td>현재 윈도우 타이틀.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.hasFocus" name = "love.window.hasFocus"><span>love.window.</span><wbr>hasFocus</a></p><p class = "function_description">윈도우가 키보드 포커스를 가지고 있는지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">focus</span> = love.window.<wbr>hasFocus()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">focus</td><td class = "ra_type">boolean</td><td>포커스를 가지고 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.hasMouseFocus" name = "love.window.hasMouseFocus"><span>love.window.</span><wbr>hasMouseFocus</a></p><p class = "function_description">윈도우가 마우스 포커스를 가지고 있는지 조사합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">focus</span> = love.window.<wbr>hasMouseFocus()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">focus</td><td class = "ra_type">boolean</td><td>포커스를 가지고 있으면 true.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.isDisplaySleepEnabled" name = "love.window.isDisplaySleepEnabled"><span>love.window.</span><wbr>isDisplaySleepEnabled</a></p><p class = "function_description">프로그램이 실행되는 동안 디스플레이가 잠자기 할 수 있는지 여부를 가져옵니다.<br /><br />디스플레이 절전 모드는 기본적으로 비활성화되어 있습니다. 일부 유형의 입력 (예 : 조이스틱 버튼 누름)으로 인해 디스플레이 절전이 허용되는 경우 디스플레이가 절전 모드로 전환되지 않을 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">enabled</span> = love.window.<wbr>isDisplaySleepEnabled()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">enabled</td><td class = "ra_type">boolean</td><td>시스템 표시 슬립이 활성화 / 허용되면 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.isMaximized" name = "love.window.isMaximized"><span>love.window.</span><wbr>isMaximized</a></p><p class = "function_description">Window가 현재 최대화되어 있는지 여부를 가져옵니다.<br /><br />창이 전체 화면이 아니며 크기를 재조정 할 수없는 경우 윈도우를 최대화 할 수 있으며 사용자가 윈도우의 최대화 버튼을 누르거나 <a href="#love.window.maximize">love.window.maximize</a>가 호출되었습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">maximized</span> = love.window.<wbr>isMaximized()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">maximized</td><td class = "ra_type">boolean</td><td>윈도우가 현재 윈도우 모드에서 최대화되어 있으면 true이고, 그렇지 않으면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.isOpen" name = "love.window.isOpen"><span>love.window.</span><wbr>isOpen</a></p><p class = "function_description">창이 열려 있는지 확인합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">open</span> = love.window.<wbr>isOpen()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">open</td><td class = "ra_type">boolean</td><td>윈도우가 열려 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.isVisible" name = "love.window.isVisible"><span>love.window.</span><wbr>isVisible</a></p><p class = "function_description">게임 윈도우가 보이는지에 대한 여부를 조사합니다.<br /><br />윈도우가 최소화되거나 완전히 숨겨진 게 아니면 항상 보이는 것으로 간주합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">visible</span> = love.window.<wbr>isVisible()</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">visible</td><td class = "ra_type">boolean</td><td>윈도우 가시성.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.maximize" name = "love.window.maximize"><span>love.window.</span><wbr>maximize</a></p><p class = "function_description">가능한 한 윈도우를 크게 만듭니다.<br /><br />이 함수는 윈도우의 크기를 조정할 수없는 경우 효과적이지 않습니다. 기본적으로 프로그래밍 방식으로 윈도우의 "최대화"버튼을 누르기 때문입니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.window.<wbr>maximize()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.minimize" name = "love.window.minimize"><span>love.window.</span><wbr>minimize</a></p><p class = "function_description">창을 시스템의 작업 표시 줄 / 독에 최소화합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.window.<wbr>minimize()</span></span></p><table class = "ra_table"></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.requestAttention" name = "love.window.requestAttention"><span>love.window.</span><wbr>requestAttention</a></p><p class = "function_description">포 그라운드에 있지 않은 경우 창에서 사용자의주의를 요청합니다.<br /><br />Windows에서는 작업 표시 줄 아이콘이 깜박이고 OS X에서는 도크 아이콘이 튀어 나옵니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.window.<wbr>requestAttention( <span class = "arguments">continuous</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">continuous <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>윈도우가 활성화 될 때까지 지속적으로주의를 요청할지 아니면 한 번만 수행 할지를 지정합니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.setDisplaySleepEnabled" name = "love.window.setDisplaySleepEnabled"><span>love.window.</span><wbr>setDisplaySleepEnabled</a></p><p class = "function_description">프로그램이 실행되는 동안 디스플레이가 절전 모드로 전환 될 수 있는지 여부를 설정합니다.<br /><br />디스플레이 절전 모드는 기본적으로 비활성화되어 있습니다. 일부 유형의 입력 (예 : 조이스틱 버튼 누름)으로 인해 디스플레이 절전이 허용되는 경우 디스플레이가 절전 모드로 전환되지 않을 수 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.window.<wbr>setDisplaySleepEnabled( <span class = "arguments">enable</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">enable</td><td class = "ra_type">boolean</td><td>시스템 디스플레이 절전을 활성화하려면 true이고, 비활성화하려면 false입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.setFullscreen" name = "love.window.setFullscreen"><span>love.window.</span><wbr>setFullscreen</a></p><p class = "function_description">전체 화면 모드로 진입하거나 빠져 나옵니다. 다중 모니터 환경일 경우 현재 모니터가 위치한 모니터에서 전체 화면 모드로 진입합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.window.<wbr>setFullscreen( <span class = "arguments">fullscreen</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공하면 true.</td></tr><tr><td class = "arguments ra_name">fullscreen</td><td class = "ra_type">boolean</td><td>전체 화면에 진입할지 빠져 나갈지 결정.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.window.<wbr>setFullscreen( <span class = "arguments">fullscreen</span>, <span class = "arguments">fstype</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공하면 true.</td></tr><tr><td class = "arguments ra_name">fullscreen</td><td class = "ra_type">boolean</td><td>전체 화면에 진입할지 빠져 나갈지 결정.</td></tr><tr><td class = "arguments ra_name">fstype</td><td class = "ra_type"><a href="#FullscreenType">FullscreenType</a></td><td>전체 화면 모드 종류.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.setIcon" name = "love.window.setIcon"><span>love.window.</span><wbr>setIcon</a></p><p class = "function_description">게임이 종료될 때까지 사용할 윈도우 아이콘을 설정합니다. 일부 OS에서는 큰 크기의 아이콘을 지원하지 않습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.window.<wbr>setIcon( <span class = "arguments">imagedata</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>아이콘이 성공적으로 설정되었는지 여부.</td></tr><tr><td class = "arguments ra_name">imagedata</td><td class = "ra_type"><a href="#ImageData">ImageData</a></td><td>윈도우 아이콘 이미지</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.setMode" name = "love.window.setMode"><span>love.window.</span><wbr>setMode</a></p><p class = "function_description">윈도우의 총괄적인 상태를 변경합니다.<br /><br />모니터 전체의 크기로 너비나 높이를 변경하려면 이들의 값을 0으로 설정하세요.<br /><br />이 함수를 사용할 경우 Canvas가 초기화되는 둥 여러가지 부수 효과가 발생할 수도 있습니다. 해당 데이터에 중요한 정보가 담겨 있다면 보존해 두어야 합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.window.<wbr>setMode( <span class = "arguments">width</span>, <span class = "arguments">height</span>, <span class = "arguments">flags</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다.</td></tr><tr><td class = "arguments ra_name">width</td><td class = "ra_type">number</td><td>너비를 표시하십시오.</td></tr><tr><td class = "arguments ra_name">height</td><td class = "ra_type">number</td><td>높이 표시.</td></tr><tr><td class = "arguments ra_name">flags</td><td class = "ra_type">table</td><td>옵션이있는 flags 테이블은 다음과 같습니다.</td></tr><tr><td class = "arguments ra_name">flags.fullscreen <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>전체 화면 (true) 또는 창 (false).</td></tr><tr><td class = "arguments ra_name">flags.fullscreentype <span class = "default">("desktop")</span></td><td class = "ra_type"><a href="#FullscreenType">FullscreenType</a></td><td>사용할 전체 화면 유형입니다. 이 기본값은 0.9.2 및 이전 버전에서 "normal"입니다.</td></tr><tr><td class = "arguments ra_name">flags.vsync <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>L-VE가 vsync를 대기해야하는 경우에는 true이고, 그렇지 않으면 false입니다.</td></tr><tr><td class = "arguments ra_name">flags.msaa <span class = "default">(0)</span></td><td class = "ra_type">number</td><td>앤티 앨리어싱 샘플의 수입니다.</td></tr><tr><td class = "arguments ra_name">flags.resizable <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>윈도우가 윈도우 모드로 사이즈 변경 가능한 경우는 true, 그렇지 않은 경우는 false</td></tr><tr><td class = "arguments ra_name">flags.borderless <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>윈도우가 윈도우 모드에서 경계가없는 경우는 true, 그렇지 않은 경우는 false</td></tr><tr><td class = "arguments ra_name">flags.centered <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>윈도우가 윈도우 모드의 중앙에 있어야하는 경우는 true, 그렇지 않은 경우는 false</td></tr><tr><td class = "arguments ra_name">flags.display <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>여러 모니터를 사용할 수있는 경우 창을 표시 할 디스플레이 색인입니다.</td></tr><tr><td class = "arguments ra_name">flags.minwidth <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>윈도우의 최소폭입니다 (사이즈를 변경할 수있는 경우). 1보다 작을 수 없습니다.</td></tr><tr><td class = "arguments ra_name">flags.minheight <span class = "default">(1)</span></td><td class = "ra_type">number</td><td>윈도우의 최소 높이입니다 (사이즈를 재조정 할 수있는 경우). 1보다 작을 수 없습니다.</td></tr><tr><td class = "arguments ra_name">flags.highdpi <span class = "default">(false)</span></td><td class = "ra_type">boolean</td><td>OS-X의 Retina 디스플레이에서 높은 dpi 모드를 사용해야하는 경우 True로, Retina가 아닌 디스플레이에는 아무 것도 표시하지 않습니다.</td></tr><tr><td class = "arguments ra_name">flags.x <span class = "default">(nil)</span></td><td class = "ra_type">number</td><td>지정된 디스플레이에서 윈도우 위치의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">flags.y <span class = "default">(nil)</span></td><td class = "ra_type">number</td><td>지정된 디스플레이에서의 윈도우 위치의 y 좌표입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.setPosition" name = "love.window.setPosition"><span>love.window.</span><wbr>setPosition</a></p><p class = "function_description">화면의 윈도우 위치를 설정합니다.<br /><br />창 위치는 지정된 디스플레이의 좌표 공간에 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.window.<wbr>setPosition( <span class = "arguments">x</span>, <span class = "arguments">y</span>, <span class = "arguments">display</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>윈도우 위치의 x 좌표입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>윈도우의 위치의 y 좌표입니다.</td></tr><tr><td class = "arguments ra_name">display</td><td class = "ra_type">number</td><td>새 창 위치가 상대적인 디스플레이 색인입니다.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.setTitle" name = "love.window.setTitle"><span>love.window.</span><wbr>setTitle</a></p><p class = "function_description">윈도우 타이틀을 설정합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative">love.window.<wbr>setTitle( <span class = "arguments">title</span> )</span></span></p><table class = "ra_table"><tr><td class = "arguments ra_name">title</td><td class = "ra_type">string</td><td>새 윈도우 타이틀.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.showMessageBox" name = "love.window.showMessageBox"><span>love.window.</span><wbr>showMessageBox</a></p><p class = "function_description">사랑 창 위에 메시지 상자 대화 상자를 표시합니다. 메시지 상자에는 제목, 선택적 텍스트 및 단추가 있습니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">success</span> = love.window.<wbr>showMessageBox( <span class = "arguments">title</span>, <span class = "arguments">message</span>, <span class = "arguments">type</span>, <span class = "arguments">attachtowindow</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">success</td><td class = "ra_type">boolean</td><td>메시지 상자가 성공적으로 표시되었는지 여부입니다.</td></tr><tr><td class = "arguments ra_name">title</td><td class = "ra_type">string</td><td>메시지 상자의 제목입니다.</td></tr><tr><td class = "arguments ra_name">message</td><td class = "ra_type">string</td><td>메시지 상자 안의 텍스트.</td></tr><tr><td class = "arguments ra_name">type <span class = "default">("info")</span></td><td class = "ra_type"><a href="#MessageBoxType">MessageBoxType</a></td><td>메시지 상자의 유형입니다.</td></tr><tr><td class = "arguments ra_name">attachtowindow <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>메시지 상자가 사랑 창에 첨부되어야하는지 또는 자유롭게 떠 다니는 지 여부.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">pressedbutton</span> = love.window.<wbr>showMessageBox( <span class = "arguments">title</span>, <span class = "arguments">message</span>, <span class = "arguments">buttonlist</span>, <span class = "arguments">type</span>, <span class = "arguments">attachtowindow</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">pressedbutton</td><td class = "ra_type">number</td><td>사용자가 누른 버튼의 인덱스입니다. 메시지 상자 대화 상자가 버튼을 누르지 않고 닫힌 경우 0 일 수 있습니다.</td></tr><tr><td class = "arguments ra_name">title</td><td class = "ra_type">string</td><td>메시지 상자의 제목입니다.</td></tr><tr><td class = "arguments ra_name">message</td><td class = "ra_type">string</td><td>메시지 상자 안의 텍스트.</td></tr><tr><td class = "arguments ra_name">buttonlist</td><td class = "ra_type">table</td><td>표시 할 단추 이름 목록을 포함하는 표. 테이블에는 enterbutton 및 escapebutton 필드도 포함될 수 있습니다.이 필드는 사용자가 각각 'enter'또는 'escape'를 누를 때 사용할 기본 단추의 인덱스 여야합니다.</td></tr><tr><td class = "arguments ra_name">type <span class = "default">("info")</span></td><td class = "ra_type"><a href="#MessageBoxType">MessageBoxType</a></td><td>메시지 상자의 유형입니다.</td></tr><tr><td class = "arguments ra_name">attachtowindow <span class = "default">(true)</span></td><td class = "ra_type">boolean</td><td>메시지 상자가 사랑 창에 첨부되어야하는지 또는 자유롭게 떠 다니는 지 여부.</td></tr></table></div><div class = "section"><p class = "function_heading"><a href = "#love.window.toPixels" name = "love.window.toPixels"><span>love.window.</span><wbr>toPixels</a></p><p class = "function_description">숫자를 밀도 독립적 단위에서 픽셀 단위로 변환합니다.<br /><br />창의 내부 픽셀 밀도는 창의 "크기"보다 클 수 있습니다. 예를 들어, highdpi 윈도우 플래그가 활성화 된 Mac OS X의 망막 스크린에서 윈도우는 800x600 윈도우와 동일한 실제 크기를 차지할 수 있지만 윈도우 내부의 영역은 1600x1200 픽셀을 사용합니다. love.window.toPixels (800)은이 경우 1600을 반환합니다.<br /><br />이는 사용자가 화면 상에 픽셀로 표시 할 것으로 기대하는 크기의 좌표를 변환하는 데 사용됩니다. love.window.from 픽셀은 그 반대입니다. Mac OS X 및 iOS에서 Retina 화면의 전체 픽셀 밀도를 사용하려면 highdpi 창 플래그를 사용하도록 설정해야합니다. 이 플래그는 현재 Windows 및 Linux에서는 아무 작업도 수행하지 않으며, Android에서는 실제로이 플래그가 항상 활성화되어 있습니다.<br /><br />대부분의 L-VE 함수는 값을 반환하고 밀도 독립 단위가 아닌 픽셀 단위로 인수를 예상합니다.</p><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">pixelvalue</span> = love.window.<wbr>toPixels( <span class = "arguments">value</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">pixelvalue</td><td class = "ra_type">number</td><td>변환 된 숫자 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">value</td><td class = "ra_type">number</td><td>픽셀로 변환 할 밀도 독립적 인 단위의 숫자입니다.</td></tr></table><p class = "synopsis"><span class = "synopsis_background"><span class = "relative"><span class = "returns">px</span>, <span class = "returns">py</span> = love.window.<wbr>toPixels( <span class = "arguments">x</span>, <span class = "arguments">y</span> )</span></span></p><table class = "ra_table"><tr><td class = "returns ra_name">px</td><td class = "ra_type">number</td><td>좌표로 변환 된 x 축 값 (픽셀 단위)입니다.</td></tr><tr><td class = "returns ra_name">py</td><td class = "ra_type">number</td><td>변환 된 좌표의 y 축 값 (픽셀 단위)입니다.</td></tr><tr><td class = "arguments ra_name">x</td><td class = "ra_type">number</td><td>픽셀로 변환 할 밀도 독립적 단위로 표시된 좌표의 x 축 값입니다.</td></tr><tr><td class = "arguments ra_name">y</td><td class = "ra_type">number</td><td>픽셀로 변환 할 밀도 독립적 단위로 표시된 좌표의 y 축 값입니다.</td></tr></table></div><div class = "section"><p class = "section_heading"><a href = "#FullscreenType" name = "FullscreenType">FullscreenType</a></p><p class = "constant_name">desktop</p><p class = "constant_description">전체 화면 크기의 테두리 없는 윈도우를 사용하는 모드입니다. OS의 모든 GUI 요소(Windows의 작업표시줄, OS X의 독) 앞에 생성되며, 윈도우의 크기는 모니터 전체의 크기로 자동 조정됩니다. 이때 크기는 변경할 수 없습니다.</p><p class = "constant_name">exclusive</p><p class = "constant_description">표준 독점 - 전체 화면 모드. 모니터의 디스플레이 모드 (실제 해상도)를 변경합니다.</p></div><div class = "section"><p class = "section_heading"><a href = "#MessageBoxType" name = "MessageBoxType">MessageBoxType</a></p><p class = "constant_name">info</p><p class = "constant_description">정보 대화 상자.</p><p class = "constant_name">warning</p><p class = "constant_description">경고 대화 상자.</p><p class = "constant_name">error</p><p class = "constant_description">오류 대화 상자.</p></div></div></body></html>